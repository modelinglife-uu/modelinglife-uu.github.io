<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>genereg_2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="genereg_2_files/libs/clipboard/clipboard.min.js"></script>
<script src="genereg_2_files/libs/quarto-html/quarto.js"></script>
<script src="genereg_2_files/libs/quarto-html/popper.min.js"></script>
<script src="genereg_2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="genereg_2_files/libs/quarto-html/anchor.min.js"></script>
<link href="genereg_2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="genereg_2_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="genereg_2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="genereg_2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="genereg_2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="gene-regulation-in-space" class="level1">
<h1>Gene regulation in space</h1>
<section id="todo-for" class="level2">
<h2 class="anchored" data-anchor-id="todo-for">TODO FOR</h2>
<ul>
<li><span class="citation" data-cites="Monica">@Monica</span>, check labels for questions (‘mathematical thinking’, ‘biology’, etc)</li>
<li><span class="citation" data-cites="Monica">@Monica</span>, figure out how/where to share the files and answers</li>
</ul>
</section>
<section id="section" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="section"></h2>
<center>
<em>How wonderful that we have met with a paradox. <br> Now we have some hope of making progress – Niehls Bohr</em>
</center>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In this practical you will study the effects of auxin, a plant hormone, on gene regulation in the root. Auxin is a hormone virtually involved in all developmental processes in plants, from embryo patterning and floral organ determination to leaf disposition and root growth. In each context, auxin triggers specific responses, which can be explained by the underlying regulatory networks—namely by the redundancy of molecular players in the auxin signalling pathway (the auxin response factors, ARFs), and how they are expressed in different tissues.</p>
<p>In the root, researchers have found an auxin–WOX5 paradox: some experiments show that auxin promotes the expression of WOX5 (a root stem cell transcription factor), while others found WOX5 repression. This opposite auxin regulation is mediated by different ARFs—ARF5 and ARF10—posing the possibility that accounting for both ARF5 and ARF10 regulatory networks can reconcile the results. To this end, you will use an in silico root model to address this paradox and propose an explanation.</p>
</section>
<section id="biological-background" class="level2">
<h2 class="anchored" data-anchor-id="biological-background">Biological background</h2>
<p>Plant roots grow thanks to the presence of stem cells housed in a niche at the root tip. A subset of these cells expresses WOX5, maintaining the surrounding cells as stem cells. WOX5 is regulated by several factors, and network models help us understand how.</p>
<p>The Boolean network used last week describes the gene and hormonal activity configurations of the cells in the root apex. In this model WOX5 is regulated positively by ARF5 and negatively by ARF10 and CLE40. Auxin regulates stem cell activity in the roots, and multiple links exist between auxin and the regulators in the Boolean network. Both ARF5 and ARF10 are auxin response factors activated by auxin. Moreover, root transcription factors control ARF5 and ARF10 expression such that they are not expressed in every cell of the root apex. This regulation is included in the Boolean model we studied last week. Whether this is relevant to understanding the auxin–WOX5 paradox is unclear. Here, each cell of the in silico root model carries a copy of the Boolean network, which allows us to test hypotheses and find an explanation.</p>
</section>
<section id="the-model" class="level2">
<h2 class="anchored" data-anchor-id="the-model">The model</h2>
<p>The model simulates a root apex, showing the stem cell niche at the apex (lime green cells in the cell graphics; purple cells in the WOX5 visualization). The different tissues of the root are spatially organized. Each cell has a different set of expressed genes, which we account for by initializing each cell’s Boolean network in the QC, Vascular, Endodermis, and Columella attractors. (Cortex and epidermis are not modeled.) Multiple grids store different cell properties: cell-type, auxin levels, and expression of each gene.</p>
<p>You can visualize ARF10, ARF5, MGP, and WOX5 expression using the provided plotting function.</p>
</section>
<section id="files" class="level2">
<h2 class="anchored" data-anchor-id="files">Files</h2>
<p><code>Rootfunctions.py</code> – contains model functions. You do not need to modify them but should understand what they do.</p>
<p><code>Root-model-Auxin.py</code> – code to simulate the in silico root.</p>
<p><code>auxin_grid.npy</code> – initial auxin levels in each cell.</p>
</section>
<section id="questions" class="level2">
<h2 class="anchored" data-anchor-id="questions">Questions</h2>
<div id="exr-tur" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 1</strong></span> Algorithmic thinking</p>
<p>Familiarize yourself with the model. Examine Rootfunctions.py to see how each process is modeled and how they are coupled.</p>
</div>
<div id="exr-tur" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 2</strong></span> Biology</p>
<p>What happens if you update the network every timestep? Does that make biological sense? Where in the code can you make this modification?</p>
</div>
<div id="exr-tur" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 3</strong></span> Biology &amp; algorithmic thinking</p>
<p>Simulate an auxin treatment by changing the AuxinTreatment parameter. Try values of 10 and 750. This increases auxin levels in all cells by the given amount.</p>
<p>How does auxin treatment affect gene expression in the root? (You can visualize different genes by changing the grid provided to plotGrids().)</p>
<p>Does the model output correspond to the transcriptional reporter of WOX5 shown in Figure 1? Do you see activation or repression as reported experimentally?</p>
</div>
<div id="exr-tur" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 4</strong></span> Biology &amp; algorithmic/mathematical thinking</p>
<p>The model does not yet reproduce the experiments. To account for quantitative effects of auxin, implement two hypotheses based on the literature:</p>
<p>Auxin represses MGP expression.</p>
<p>Extremely high auxin levels (unrealistic in vivo) repress WOX5 expression.</p>
<p>Modify the equations for MGP and WOX5 in rootNetwork accordingly.</p>
<p>For MGP, retain its logical rule but multiply its production term by a saturation function of auxin (Km = 45):</p>
<p>dMGP = (45/(45+auxininput))<em>((-np.exp(0.5 </em> h) + np.exp(-h * w_MGP)) / ((1 - np.exp(0.5 * h)) * (1 + np.exp(-h * (w_MGP - 0.5))))) - (lambda_ * MGP)</p>
<p>Similarly, add a negative regulation by auxin to the WOX5 equation (Km = 1000).</p>
<p>Run control and auxin treatments with (i) updated MGP, (ii) updated WOX5, and (iii) both updates.</p>
<p>Do you now see the differences reported by experimentalists?</p>
</div>
<div id="exr-tur" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 5</strong></span> Biological interpretation</p>
<p>You should observe that WOX5 expression gradually expands into the endodermis and disappears from QC cells when both equations are updated. This matches experimental microscopy. To explain repression:</p>
<p>Why do different parts of the root respond differently to auxin? Why does induction occur mainly in upper cells and repression in basal cells?</p>
</div>
<div id="exr-tur" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 6</strong></span> Algorithmic thinking</p>
<p>Experimental repression of WOX5 was detected by RT-PCR at the very apex. Reproduce this in silico by saving the average WOX5 levels of cells at the apex (y &lt; 40) at the end of the simulation for all three treatments. Plot them.</p>
<p>What is the root apex response to auxin treatments? Considering that the root contains mixed cell types, which cells best represent your plotted values?</p>
</div>
<div id="exr-tur" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 7</strong></span> Biology &amp; algorithmic thinking</p>
<p>Repeat the analysis for all cells, for QC cells, and for endodermis cells. Compare WOX5 regulation across tissues.</p>
<p>Do you see a difference between your observations and the simulated RT-PCR plot? Why?</p>
</div>
<div id="exr-tur" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 8</strong></span> Biology &amp; algorithmic thinking</p>
<p>Changes in WOX5 expression depend on tissue context and auxin dosage. Simulate a range of auxin treatments from 0 to 750 (choose your step size).</p>
<p>Can you now explain the auxin–WOX5 paradox? What mechanism do you propose?</p>
</div>
<div id="exr-tur" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 9</strong></span> Biology &amp; conceptual thinking</p>
<p>Perform an in silico intervention to alter WOX5 dosage responsiveness. For example, enforce continuous induction or block its induction in the endodermis. How would you test these model predictions experimentally?</p>
</div>
<div id="exr-tur" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 10</strong></span> Biological thinking</p>
<p>All models are wrong, but some are useful. The model should offer mechanistic insight into paradoxical auxin responses. Yet the original experiments used different auxin analogs: NAA (transported independently of PINs), IAA (PIN-transported), and NPA (blocks PINs, increasing auxin in the apex). How does this information change your conclusions? What extensions to the model would account for these differences?</p>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>