[
  {
    "objectID": "morpho_practical_1.html",
    "href": "morpho_practical_1.html",
    "title": "9  Practical 4",
    "section": "",
    "text": "9.1 Gene regulation in time\nIn this practical you will get hands on experience into making gene regulatory networks models. First you will practice how to encode regulatory interactions into ordinary differential equations and logical rules. Next you will study how many interactions produce self-sustained activity configurations (attractors) in a Boolean network model. Lastly, you will learn how to predict the genes that cause cell fate transitions (attractor changes).\nToday we will use the following python file: circuitsfunctions.py. In this file you will find the code of the functions we use throughout the practical, have a quick look at it. Look at the name of the functions, inputs and outputs.",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Practical 4</span>"
    ]
  },
  {
    "objectID": "morpho_practical_1.html#part-ii-gene-regulatory-network",
    "href": "morpho_practical_1.html#part-ii-gene-regulatory-network",
    "title": "9  Practical 4",
    "section": "9.3 Part II – Gene regulatory network",
    "text": "9.3 Part II – Gene regulatory network\nNow let’s move to a network model made of many individual regulatory interactions. This model includes regulatory interactions experimentally determined in the cells of plant roots, here they encoded as logical rules. The model consists of 18 nodes representing transcription factors, hormones, peptides, and multitude regulatory interactions among them. Look at the rootNetwork() function in the circuitFunctions.py file. See how the activity of each node is determined by the state of its regulators using and combining the logical operators AND, OR and NOT. Find the model here: https://www.nature.com/articles/s41598-020-60251-8\nLet’s define a random initial condition for each of these 18 nodes, and the timesteps to solve the system using the logical functions. To find the state of the nodes in the network the next timestep, we need to give the state of our nodes to the rootNetwork() function, and then save the output of this function. We will save in matrix the initial condition, and how these 18 nodes change in the timesteps defined. At the end the function plotBooleanTimecourse() will show us the network changes in the simulated timesteps. * tip: 100 timesteps is enough to reach the attractors. For the initial condition you can also use that of one of the attractors reported in the paper and check what happens when you update them.\ntimesteps=20\nnodes=18\nmatrix = np.zeros((timesteps+1, nodes), dtype=int) \nmatrix[0,:] = np.random.randint(0, 2, size=nodes) #Random initial condition\nfor i in range(timesteps):\n    parameters= {'CK': matrix[i,0], 'ARR1': matrix[i,1], 'SHY2': matrix[i,2], 'AUXIAAR': matrix[i,3], 'ARFR': matrix[i,4], 'ARF10': matrix[i,5], 'ARF5': matrix[i,6], 'XAL1': matrix[i,7], 'PLT': matrix[i,8], 'AUX': matrix[i,9], 'SCR': matrix[i,10], 'SHR': matrix[i,11], 'MIR165': matrix[i,12], 'PHB': matrix[i,13], 'JKD': matrix[i,14], 'MGP': matrix[i,15], 'WOX5': matrix[i,16], 'CLE40': matrix[i,17]}\n    matrix[i+1, :] = rootNetwork(parameters)\n\nplotBooleanTimecourse(matrix,timesteps)\nInstead of a random initial condition try this one:\nmatrix[0,:]=[0,1,1,0,1,1,0,0,1,0,1,1,1,1,1,0,1,0]\nUse the asynchronous updating scheme by changing the function to rootNetworkAsynchronous() and see what happens to this initial condition.\nQ4 What happens now and why? What does an asyncrhonous update is doing?\nThis network has 18 nodes, and then 218 = 262,144 possible states. We can either solve each of these conditions, or instead explore just a subset of them. Using the previous code, add for loop to solve 100 random initial conditions, and then save the final activity configurations (attractors) in the attractors matrix. *tip: 100 initial conditons is a good number to start with. # The attractors matrix should have the shape (initial_conditions, nodes) so that you can plot the results using the function plotBooleanAttractors.\nICs=100\nattractors = np.zeros((ICs, len(parameters))) # new\n\n# your code\n\nplotBooleanAttractors(attractors) # it takes as argument your matrix of attractors\nYou probably found many different attractors. First, let’s use a multidimensional reduction technique to see if each of initial conditions form groups of similar cells.\nUMAPBoolean(attractors)\nQ5 Why do you see clearly defined groups and not a continuous distribution of attractors?\nNow let’s analyse the attractors you found. First, let’s group similar attractors:\nattractors_sorted = np.array(sorted(attractors.tolist()))\nplotBooleanAttractors(attractors_sorted) \nQ6 Do some attractors occur more frequently than others. Do they all have the same basin size of attraction? Why is this?\nQ6.1 Some nodes are active (1) in most attractors, others in half, and others in very few. In how many of them is the node SHR active? What does this suggest about their regulation?\nNow let’s remove the repeated rows (duplicate attractor states) to see unique attractors:\n_, unique_indices = np.unique(attractors, axis=0, return_index=True)\nattractors_unique = attractors[np.sort(unique_indices)]\nplotBooleanAttractors(attractors_unique) \nQ7 How many unique attractors did you find? Compare them with the ones reported in the paper. Are they all fixed points?",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Practical 4</span>"
    ]
  },
  {
    "objectID": "morpho_practical_1.html#part-iii-cell-differentiation-jumping-from-one-attractor-to-another",
    "href": "morpho_practical_1.html#part-iii-cell-differentiation-jumping-from-one-attractor-to-another",
    "title": "9  Practical 4",
    "section": "9.4 Part III – Cell differentiation – jumping from one attractor to another",
    "text": "9.4 Part III – Cell differentiation – jumping from one attractor to another\nDepending on what we want to answer a continuous or discrete model may be more appropriate for a model. To study the role of many genes in cell differentiation, a Boolean model might be better particularly if we lack details of the parameters underlying each reaction. If we want to study how cells jump from one state to another, a continuous model might be more appropriate.\nHere we will see how we can convert the Boolean model to a continuous one and use it to predict which regulators are able of causing a change in the state of the system (changes in cell fate!)\nCompare the code of the functions rootNetwork() and rootNetworkODE(). Notice how in rootNetworkODE() the logical rules are represented with min and max functions, and then used in a sigmoidal function to create a continuous ODE model. * AND operator is a min function, OR operator is a max function, and NOT operator is 1-x. Use the code below to run a random initial condition for the 18 nodes (IC) and see how the system behaves.\ntimerunning=10.1 \ntimes = np.arange(0, timerunning, 0.1)\n\nIC = np.random.randint(0, 2, size=18).tolist() #random initial condition\nparameters = {'decayrate': 1, 'h': 50} \ncells = odeint(rootNetworkODE, IC, times, args=(parameters,)) \n\nplotODEroot(cells,times)\nQ8 Do the attractors match those recovered with the Boolean network?\nNow let’s use the model to study cell differentiation. Let’s start in the following initial condition (IC vector), and find a change in a node that produce a jump to another attractor (end). For this you can simply flip the activity of a gene in the initial condition (from 0 -&gt;1 or 1-&gt;0) and see the final attractor matches the desired end state.\n# We start here: \nIC=[0,0,0,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0]\n# We want to end here. \nend=[1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,0,0,1]\n# node order\n# CK, ARR1, SHY2, AUXIAAR, ARFR, ARF10, ARF5, XAL1, PLT, AUX, SCR, SHR, MIR165, PHB, JKD, MGP, WOX5, CLE40\n\n# your code \n\nplotODErootTransition(cells,times) # use this function to plot your result\nQ9 What regulator causes the transition between these attractors? How many nodes change their activity between the initial and final state? what could be the biological meaning of this switch? how would you test this experimentally?\nQ10 Finally, use the model to predict the rest of the attractor transitions because of single node changes. Are all attractor transitions possible, or are there preferred differentiation routes?",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Practical 4</span>"
    ]
  },
  {
    "objectID": "morpho_practical_1.html#gene-regulation-in-time",
    "href": "morpho_practical_1.html#gene-regulation-in-time",
    "title": "9  Practical 4",
    "section": "",
    "text": "Part I - Encoding regulatory interactions\nOpen Boolean_practical.py and familiarize yourself with the functions ODEgeneRegulation() and logicalRule().\nBoth functions model an AND gate where nodeA and nodeB positively regulate nodeC. This could represent that A and B are transcription factors that form a protein complex, and that is via this complex that they can regulate the expression of C. While ODEgeneRegulation() encodes this regulation with an ordinary differential equation that requires several parameters, logicalRule() only needs the logical operator relating the input genes.\ndef ODEgeneRegulation(a,t,parameters): \n    prod=parameters['prod']\n    decay=parameters['decay']\n    Ksat=parameters['Ksat']\n    nodeA=parameters['nodeA']\n    nodeB=parameters['nodeB']\n    n=parameters['n']\n    outputC=a[0]\n    doutputC=prod*nodeA**n/(Ksat**n+nodeA**n)*nodeB**n/(Ksat**n+nodeB**n)-decay*outputC  \n    return(doutputC)\n\ndef logicalRule(nodeA,nodeB):\n    return(nodeA and nodeB)\nQ1 What is the minimum information you need to encode a regulatory interaction with either function? In what cases would you prefer to use an ODE or a logical rule for a model?\nLet’s run the model to simulate what happens if nodeA and nodeB are both active/expressed. Do this for the ODE and the Boolean logic code model using the following lines inside the main().\n# ODE model - see the parameters used in circuitsfunctions.py\n# ODErun has three arguments: model, geneA, geneB\nA=10\nB=10\nODErun(ODEgeneRegulation,A,B) \n\n# Boolean model\n# look at the terminal for the result:\nA=1\nB=1\nprint(\"the boolean operation of nodeA \",A,\" AND nodeB\",B,\" is:\", logicalRule(A,B))\nNow, let’s explore the output of each function using different values of nodeA and nodeB. We are going to use the code below to plot the output of the ODE and the Boolean model in a 2D heatmap.\n# First, Boolean network simulation - AND gate\nexplorationvalue=2 # a Boolean model assumes there is only 2 possible states: 0 or 1\nbool_output = np.zeros((explorationvalue, explorationvalue))\nfor nodeA in range(0, explorationvalue):\n    for nodeB in range(0, explorationvalue):\n        bool_output[nodeA, nodeB] = nodeA and nodeB #AND # CHANGE THIS\n\n# Now, ODE model simulation\nexplorationvalue = 11 # an ODE model allows us to explore more values than a boolean model\node_output = np.zeros((explorationvalue, explorationvalue))\nfor nodeA in range(0, explorationvalue):\n    for nodeB in range(0, explorationvalue):\n        parameters = {'prod': 0.01, 'decay': 0.001,'Ksat': 4, 'n': 2,'nodeA':nodeA,'nodeB':nodeB} # prod, decay, Ksat, n, and initial values for A and B\n        cells = odeint(ODEgeneRegulation, 0, np.arange(0, 1000.1 , 0.1), args=(parameters,)) #np.shape\n        ode_output[nodeA, nodeB] = cells[-1, 0]\n\n# use this code to see your ode and boolean results side by side\nODEBooleanPlot(ode_output, bool_output)\nQ2 What differences do you see in each case?\nNow let’s compare how ODE and Boolean logic represent different logical gates. You can use the same code in the previous box. Remember to modify the logical operator in the Boolean section, and to modify the doutputC equation in ODEgeneRegulation:\n\neither nodeA or nodeB can activate outputC (OR gate)\nthat nodeA represses outputC (NOT gate)\nthat both nodeA and nodeB repress outputC (NOT nodeA & NOT nodeB )\nthat nodeA represses outputC but nodeB activates it (NOT nodeA, yes nodeB)\nthat nodeA or nodeB can activate outputC, but not both at the same time (XOR gate)\nany other biological scenario yon can think of!\n\n\ntip: include an extra input node, and make a 3-node logical gate.\n\nQ3 Is there a logical gate that can be better represented with an ODE than with Boolean logic? Think of examples of biological regulatory interactions that can be described with each logical gate?",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Practical 4</span>"
    ]
  },
  {
    "objectID": "morpho_practical_1.html#q1",
    "href": "morpho_practical_1.html#q1",
    "title": "9  Practical 4",
    "section": "9.1 Q1",
    "text": "9.1 Q1\nWhat is the minimum information you need to encode a regulatory interaction with either function? In what cases would you prefer to use an ODE or a logical rule for a model?\nLet’s run the model to simulate what happens if nodeA and nodeB are both active/expressed. Do this for the ODE and the Boolean logic code model using the following lines inside the main().\n# ODE model - see the parameters used in circuitsfunctions.py\n# ODErun has three arguments: model, geneA, geneB\nA=10\nB=10\nODErun(ODEgeneRegulation,A,B) \n\n# Boolean model\n# look at the terminal for the result:\nA=1\nB=1\nprint(\"the boolean operation of nodeA \",A,\" AND nodeB\",B,\" is:\", logicalRule(A,B))\nNow, let’s explore the output of each function using different values of nodeA and nodeB. We are going to use the code below to plot the output of the ODE and the Boolean model in a 2D heatmap.\n# First, Boolean network simulation - AND gate\nexplorationvalue=2 # a Boolean model assumes there is only 2 possible states: 0 or 1\nbool_output = np.zeros((explorationvalue, explorationvalue))\nfor nodeA in range(0, explorationvalue):\n    for nodeB in range(0, explorationvalue):\n        bool_output[nodeA, nodeB] = nodeA and nodeB #AND # CHANGE THIS\n\n# Now, ODE model simulation\nexplorationvalue = 11 # an ODE model allows us to explore more values than a boolean model\node_output = np.zeros((explorationvalue, explorationvalue))\nfor nodeA in range(0, explorationvalue):\n    for nodeB in range(0, explorationvalue):\n        parameters = {'prod': 0.01, 'decay': 0.001,'Ksat': 4, 'n': 2,'nodeA':nodeA,'nodeB':nodeB} # prod, decay, Ksat, n, and initial values for A and B\n        cells = odeint(ODEgeneRegulation, 0, np.arange(0, 1000.1 , 0.1), args=(parameters,)) #np.shape\n        ode_output[nodeA, nodeB] = cells[-1, 0]\n\n# use this code to see your ode and boolean results side by side\nODEBooleanPlot(ode_output, bool_output)\nQ2 What differences do you see in each case?\nNow let’s compare how ODE and Boolean logic represent different logical gates. You can use the same code in the previous box. Remember to modify the logical operator in the Boolean section, and to modify the doutputC equation in ODEgeneRegulation:\n\neither nodeA or nodeB can activate outputC (OR gate)\nthat nodeA represses outputC (NOT gate)\nthat both nodeA and nodeB repress outputC (NOT nodeA & NOT nodeB )\nthat nodeA represses outputC but nodeB activates it (NOT nodeA, yes nodeB)\nthat nodeA or nodeB can activate outputC, but not both at the same time (XOR gate)\nany other biological scenario yon can think of!\n\n\ntip: include an extra input node, and make a 3-node logical gate.\n\nQ3 Is there a logical gate that can be better represented with an ODE than with Boolean logic? Think of examples of biological regulatory interactions that can be described with each logical gate?",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Practical 4</span>"
    ]
  },
  {
    "objectID": "morpho_practical_1.html#part-i---encoding-regulatory-interactions",
    "href": "morpho_practical_1.html#part-i---encoding-regulatory-interactions",
    "title": "9  Practical 4",
    "section": "9.2 Part I - Encoding regulatory interactions",
    "text": "9.2 Part I - Encoding regulatory interactions\nOpen Boolean_practical.py and familiarize yourself with the functions ODEgeneRegulation() and logicalRule().\nBoth functions model an AND gate where nodeA and nodeB positively regulate nodeC. This could represent that A and B are transcription factors that form a protein complex, and that is via this complex that they can regulate the expression of C. While ODEgeneRegulation() encodes this regulation with an ordinary differential equation that requires several parameters, logicalRule() only needs the logical operator relating the input genes.\ndef ODEgeneRegulation(a,t,parameters): \n    prod=parameters['prod']\n    decay=parameters['decay']\n    Ksat=parameters['Ksat']\n    nodeA=parameters['nodeA']\n    nodeB=parameters['nodeB']\n    n=parameters['n']\n    outputC=a[0]\n    doutputC=prod*nodeA**n/(Ksat**n+nodeA**n)*nodeB**n/(Ksat**n+nodeB**n)-decay*outputC  \n    return(doutputC)\n\ndef logicalRule(nodeA,nodeB):\n    return(nodeA and nodeB)\nQ1 What is the minimum information you need to encode a regulatory interaction with either function? In what cases would you prefer to use an ODE or a logical rule for a model?\nLet’s run the model to simulate what happens if nodeA and nodeB are both active/expressed. Do this for the ODE and the Boolean logic code model using the following lines inside the main().\n# ODE model - see the parameters used in circuitsfunctions.py\n# ODErun has three arguments: model, geneA, geneB\nA=10\nB=10\nODErun(ODEgeneRegulation,A,B) \n\n# Boolean model\n# look at the terminal for the result:\nA=1\nB=1\nprint(\"the boolean operation of nodeA \",A,\" AND nodeB\",B,\" is:\", logicalRule(A,B))\nNow, let’s explore the output of each function using different values of nodeA and nodeB. We are going to use the code below to plot the output of the ODE and the Boolean model in a 2D heatmap.\n# First, Boolean network simulation - AND gate\nexplorationvalue=2 # a Boolean model assumes there is only 2 possible states: 0 or 1\nbool_output = np.zeros((explorationvalue, explorationvalue))\nfor nodeA in range(0, explorationvalue):\n    for nodeB in range(0, explorationvalue):\n        bool_output[nodeA, nodeB] = nodeA and nodeB #AND # CHANGE THIS\n\n# Now, ODE model simulation\nexplorationvalue = 11 # an ODE model allows us to explore more values than a boolean model\node_output = np.zeros((explorationvalue, explorationvalue))\nfor nodeA in range(0, explorationvalue):\n    for nodeB in range(0, explorationvalue):\n        parameters = {'prod': 0.01, 'decay': 0.001,'Ksat': 4, 'n': 2,'nodeA':nodeA,'nodeB':nodeB} # prod, decay, Ksat, n, and initial values for A and B\n        cells = odeint(ODEgeneRegulation, 0, np.arange(0, 1000.1 , 0.1), args=(parameters,)) #np.shape\n        ode_output[nodeA, nodeB] = cells[-1, 0]\n\n# use this code to see your ode and boolean results side by side\nODEBooleanPlot(ode_output, bool_output)\nQ2 What differences do you see in each case?\nNow let’s compare how ODE and Boolean logic represent different logical gates. You can use the same code in the previous box. Remember to modify the logical operator in the Boolean section, and to modify the doutputC equation in ODEgeneRegulation:\n\neither nodeA or nodeB can activate outputC (OR gate)\nthat nodeA represses outputC (NOT gate)\nthat both nodeA and nodeB repress outputC (NOT nodeA & NOT nodeB )\nthat nodeA represses outputC but nodeB activates it (NOT nodeA, yes nodeB)\nthat nodeA or nodeB can activate outputC, but not both at the same time (XOR gate)\nany other biological scenario yon can think of!\n\n\ntip: include an extra input node, and make a 3-node logical gate.\n\nQ3 Is there a logical gate that can be better represented with an ODE than with Boolean logic? Think of examples of biological regulatory interactions that can be described with each logical gate?",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Practical 4</span>"
    ]
  },
  {
    "objectID": "morpho_answers.html",
    "href": "morpho_answers.html",
    "title": "11  Answers exercises",
    "section": "",
    "text": "11.1 Answers practical 4 (gene regulation in time)\nQ1 To make an ODE model it is needed: the two nodes interacting interaction, direction and effect, and several parameters (4: prod, decay, Ksat, n). For Boolean you need the two nodes interacting interaction, direction and effect; no parameters needed.\nQ2 Quantitative differences in output (continuous can have values between 0 and 1, but also over 1).\nQ3 All logical gates can be modelled correctly with either approach. With Boolean models we look quantitative resolution, with ODE we can model many more values than 0 and 1. Biological examples that can be modelled with the logical gates: - AND gate can be that both genes form a protein complex that binds promoter. - OR is that either TF can bind promoter and activate transcription. - NOT is that a TF blocks the promoter so that activating TF cannot bind. - NOT A & NOT B is that both TFs are repressors of the same gene. - NOT A, yes B is that A is a repressor and B is an activator. - XOR gate can be a promoter where either A or B can bind, the complex AB cannot bind.\nQ4 The initial condition now converges to a fixed point attractor; the cyclic behaviour recovered with the synchronous updating scheme was an artifact of updating all the nodes at the same time.\nQ5 We see clearly defined groups because we are doing the UMAP with the cells in the final attractors, and not while they are in their trajectory towards the attractor.\nQ6 Yes, some attractors occur more often than others, and this is a consequence of the regulatory interactions integrated in the model. The number of initial conditions you found in each attractor is a reflection of the size of their basin of attraction. Indeed, the basins of attraction (all conditions that converge to an attractor) are shaped by the AND, OR, and NOT gates in each of the modelled nodes. Imagine cells are moving in a multidimensional landscape (as many dimensions as nodes in the model), such that the regulatory interactions define the “rolling” direction until eventually they land in different basins.\nQ6.1 This is defined by their logical rules, and how many regulators they have. For example, SHR logical rule is SHR = SHR. This splits the state space perfectly in two halves: one with SHR active and another with SHR inactive.\nQ7 This depends on how many initial conditions you test. The more initial conditions, the more likely you will find the maximum of 6 fixed point attractors this model can produce.\nQ8 Yes. The ODE model is built with the same regulatory interactions from the Boolean model. The difference is that this model allows us to describe quantitative differences in the activity of the nodes.\nQ9 SHR OFF (0) causes the transition between the specified activity configurations. We can interpret this change between attractors as a cell fate change, in which the decrease in SHR activity triggers changes in other nodes of the network resulting in the differentiation of the cells.\nQ10 Finally, use the model to predict the rest of the attractor transitions because of single node changes. Are all attractor transitions possible, or are there preferred differentiation routes? Not all attractor transitions are possible by single node changes. This is because the regulatory interactions in the model constrain how this perturbation is interpreted, and with it the differentiation trajectories.",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Answers exercises</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html",
    "href": "pattern_practical_1.html",
    "title": "5  Practical 1",
    "section": "",
    "text": "TODO",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#morphogen-gradients-and-patterning",
    "href": "pattern_practical_1.html#morphogen-gradients-and-patterning",
    "title": "5  Practical 1",
    "section": "5.1 Morphogen Gradients and Patterning",
    "text": "5.1 Morphogen Gradients and Patterning\nIn this practical, we a going to look at how an organism can form segments along its body axis . The mathematical model that we will implement and study is an implementation of the so-called French flag conceptual model first proposed by Lewis Wolpert (Wolpert 1969). It assumes the spatially graded expression of a morphogen “M” that influences the expression of some downstream genes A, B and C. Their expression is often visualized by red, white and blue and the arising pattern resembles the French flag, hence the name (see the power of visualization).\nOne of the most well-studied organisms when it comes to body axis segmentation (although its segmentation mechanism is evolutionary derived and a-typical!) is the development of the fruit fly Drosophila melanogaster. Supporting the ideas of Wolpert, it was found that through tethering maternal Bicoid mRNA to one side of the embryo, Bicoid protein can form a gradient extending along the anterior-posterior axis, with so called gap genes as a first tier in the segmentation hierarchy differentially responding to different Bicoid protein levels (Driever and Nüsslein-Volhard 1988). Later it was found that often at least two opposing morphogen gradients drive downstream gene expression and genes typically respond to multiple inputs.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#model-system",
    "href": "pattern_practical_1.html#model-system",
    "title": "5  Practical 1",
    "section": "5.2 Model system",
    "text": "5.2 Model system\nOne of the most well-studied organisms when it comes to segmentation is the development of fruit fly Drosophila melanogaster.\n\nDetails about bicoid gradient and the genes getting expressed\nBicoid gradient equations\n\nThe mathematical model that we will implement and study today is a so called French flag model. It starts with a morphogen M that influences the expression of the genes A, B and C. Their expression is often visualized by red, white and blue and the arising pattern resembles the French flag, hence the name (see the power of visualization).",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#mathematical-modeling---integrating-multiple-signals",
    "href": "pattern_practical_1.html#mathematical-modeling---integrating-multiple-signals",
    "title": "5  Practical 1",
    "section": "5.2 Mathematical modeling - integrating multiple signals",
    "text": "5.2 Mathematical modeling - integrating multiple signals\nPromotors/enhancers driving gene expression frequently make use of so called OR and AND gates to integrate inputs from different transcription factors. An OR gate can be implemented mathematically with a sum of the effect of the transcription factors, while an AND can be implemented mathematically with a product. Some examples:\n\n\\(\\frac{dX}{dt} = a(\\text{tf1}) + b(\\text{tf2})\\): Gene X is induced by transcription factor 1 and 2 in an OR fashion, either \\(a(\\text{tf1})\\) or \\(b(\\text{tf2})\\) needs to be high to give high transcription of X.\n\\(\\frac{dY}{dt} = a(\\text{tf1})\\cdot b(\\text{tf2})\\): Gene Y is induced by transcription factor 1 and 2 in an AND fashion, both \\(a(\\text{tf1})\\) and \\(b(\\text{tf2})\\), which are being multiplied, need to be high to give high transcription of X.\n\nNote that the shape of \\(a(\\text{tf1})\\) and \\(b(\\text{tf2})\\) (increasing or decreasing function of the transcription factor) determines whether tf1 and tf2 are repressing or activating.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#relevant-literature",
    "href": "pattern_practical_1.html#relevant-literature",
    "title": "5  Practical 1",
    "section": "5.4 Relevant literature",
    "text": "5.4 Relevant literature\nFrench flag -&gt; morphogen induced regionalization",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#python-code",
    "href": "pattern_practical_1.html#python-code",
    "title": "5  Practical 1",
    "section": "5.4 Python code",
    "text": "5.4 Python code\n\n\n\n\n\n\nStarting code for this practical\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nLx = 40.0  # Length of the domain in x in microm\nLy = 10.0  # Length of the domain in y in microm\nT = 200  # Total time in seconds\ndx = 0.5  # Grid spacing in x\ndt = 0.1  # Time step\nnx = int(Lx/dx)+2  # Number of grid points in x + padding grid points\nny = int(Ly/dx)+2  # Number of grid points in y + padding grid points\n# Padding grid points to account for boundary conditions\nnt = int(T/dt)  # Number of time steps\nD = 0.4  # Diffusion coefficient in mm^2/s\ndecayM =0.01 # Decay rate in 1/s\n\n\n# Parameters for A, B, C\n... # TODO create parameters for A, B, C as needed in Q5\n\n# Stability criterion\nif D * dt / dx**2 &gt; 0.5:\n    raise ValueError(\"Stability criterion not met\")\n\n# Initial condition\nu = np.zeros((nx, ny))\nu[0, :] = 100\n\n# A, B and C are required for later exercises.\nA = np.zeros((nx, ny))\nB = np.zeros((nx, ny))\nC = np.zeros((nx, ny))\n\n# Reaction-diffusion equation\ndef reaction_diffusion_step(u, D, dt, dx, decay):\n    un = u.copy()\n    u[1:-1, 1:-1] = un[1:-1, 1:-1] +  D *dt / dx**2 * (un[2:, 1:-1] + un[:-2, 1:-1] + \\\n                    un[1:-1, 2:]  + un[1:-1, :-2] - 4 * un[1:-1, 1:-1]) - \\\n                    decay * un[1:-1, 1:-1] * dt\n    ## for loop version to understand the equation\n    # for i in range(1, nx-1):\n    #     for j in range(1, ny-1):\n    #         u[i, j] = (un[i, j] +\n    #                    D * dt / dx**2 * (un[i+1, j] + un[i-1, j] - 2 * un[i, j] +\n    #                    un[i, j+1] + un[i, j-1] - 4 * un[i, j]) -\n    #                    decay * un[i, j] * dt)\n    \n\n    #boundary conditions\n    u[-1, :] = (u[-2, :]/u[-3, :])*u[-2, :]  if sum(u[-3, :]) != 0 else np.zeros(ny)\n    u[:, 0] = u[:, 1]\n    u[:, -1] = u[:, -2]\n\n    return u\n\ndef reaction_diffusion_gradient(t, u, D, dx, decay, switch_time = None, noise = False):\n    '''\n    Function to create a gradient in the u array that could decay after a certain time.\n    t: current time step\n    u: array to create the gradient in\n    D: diffusion coefficient\n    dx: grid spacing\n    decay: decay rate\n    switch_time: time step after which the gradient decays. If no switch is desired, set to None\n    noise: whether to add noise to the gradient\n    '''\n    # TODO for student: write code for the noise and the switch.\n    added_noise = np.zeros_like(u)  # Initialize noise array\n    if noise:\n        ...  # TODO: add noise generation code here for Q10\n    \n    if switch_time is None or t &lt;= switch_time:\n        # define a exponential decay gradient over the array in the x direction with numpy array operations using the index\n        for i in range(u.shape[0]):\n            u[i, :] = np.maximum(100 * np.exp(-i*dx/np.sqrt(D/decay))+added_noise[i, :], 0)\n        return u\n    if t &gt; switch_time:\n        ...# TODO Q7: implement a different gradient that decays over time, otherwise return the original u array\n        return u\n    # In all other cases, return the original u array        \n    return u\n\ndef hill(x, Km, pow):\n    \"\"\"Hill function for the reaction kinetics.\"\"\"\n    return (x**pow) / (Km**pow + x**pow) \n\ndef ihill(y, Km, pow):\n    \"\"\"Inverse Hill function for the reaction kinetics.\"\"\"\n    return( (Km**pow) / (y **pow  + Km**pow))\n\n# TODO for student: write update functions for A, B, C as needed in Q5\n\n\n# initilize figure and axes for plotting\n# TODO for student: Add a new axis for the ABC flag visualization as suggested in Q5\nfig, (ax_M, ax_lines) = plt.subplots(2, figsize=(10, 8), gridspec_kw={'height_ratios': [3, 1]})  # Make the first graph 3 times the height of the second\n\n# Time-stepping simulation loop\nfor n in range(nt):\n    # Update all variables\n    u = reaction_diffusion_step(u, D, dt, dx, decayM)\n    # TODO for student: use precomputed gradient, update A, B, C as needed in Q5\n    \n    if n == 0:  # Initial plot\n        imshow_M_plot = ax_M.imshow(u.T, cmap='viridis', origin='lower', aspect='auto')\n        ax_M.set_title(f\"Time: {n*dt}\")\n        ax_M.set_xlabel('x direction')\n        ax_M.set_ylabel('y direction')\n        ax_M.set_xticks([])\n        ax_M.set_yticks([])\n\n        # Plot the concentration at a specific y index (e.g., y=2)    \n        line_plot = ax_lines.plot([x*dx for x in range(nx)], u[:, 2], label='M', color='green')\n        # TODO: Add lines for A, B, C as needed in Q5\n\n        \n        ax_lines.legend(loc='upper right')\n        ax_lines.set_ylim(0, 100)\n        ax_lines.tick_params(axis='y')\n        ax_lines.set_xlim(0, dx*nx)\n        ax_lines.set_xlabel('x')\n        ax_lines.set_ylabel('Concentration at y=2')\n        ax_lines.tick_params(axis='x')\n\n    if n % 20 == 0:  # Update plot every so many time steps\n        #update the imshow M plot with the new data\n        imshow_M_plot.set_data(u.T)\n        ax_M.set_title(f\"Time: {n*dt}\")\n            \n        # Update the line plots with new data\n        line_plot[0].set_ydata(u[:, 2])\n        # TODO: Update A, B, C line plots as needed in Q5\n\n    plt.pause(0.001)  # Pause to refresh the plot\n\n# And keep the last plot open\n# plt.show()\n\n# Or close the plot window when done\nplt.close(fig)",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#exercises",
    "href": "pattern_practical_1.html#exercises",
    "title": "5  Practical 1",
    "section": "5.5 Exercises",
    "text": "5.5 Exercises\n\nPurely algorithmic thinking Have a look at the reaction-diffusion equation for the morphogen and the implementation of it in the file morphogengradient_to_segments.py in the reaction_diffusion_step function. Which terms in the function correspond to reaction and which to diffusion? How is the diffusion term discretized in the function and can you relate each of these terms? (You can also look at the double for loop in the commented-out code: this works exactly the same, but doesn’t use the properties of numpy arrays, and hence is slower in runtime.)\n\nAnswer We have a decay term, which is only multiplied by \\(dt\\) to get a numerical integral. And we have the diffusion term, multiplied by both \\(dt\\) and \\(dx\\) to get the numerical integral. This term consists of the differences in concentration between a grid point and its two adjacent grid point and hence contains the concentration of the grid point itself twice.\n\nBoundary conditions The tissue is represented as an array, but the reaction_diffusion_step function only updates the “inner” grid points of the array with the reaction diffusion equation. The left-most, right-most, top and bottom sides of the array are updated differently and represent boundary conditions. What are those, and what do they ensure in terms of values or fluxes at the boundary?\n\nAnswer Top and bottom have a no flux boundary, making sure that no concentration is lost on the top and bottom of the tissue. The leftmost boundary is not updated at all, meaning that it does not change, so it keeps its initial value set at 100. The rightmost boundary makes sure that the ratio between that boundary and the previous column is the same as the ratio between the two previous columns. (If we keep it this way to ensure the theoretical exponential gradient)\n\nImportant concept Play with the morphogen diffusion rate and the morphogen decay rate and describe what happens. What happens in terms of dynamics and steady state if you change both, but the ratio stays the same? Hint: it might help to draw a horizontal line at a certain height to ease comparison.\n\nAnswer Diffusion length concept \\(=\\sqrt{D/d}\\). And faster rates lead to faster to steady state.\n\nBiology & mathematical thinking Next, we are going to introduce the genes \\(A\\), \\(B\\) and \\(C\\) in the model. We want these genes to be expressed dependent on \\(M\\), and in the head, trunk and tail respectively, so \\(A\\) on the left, \\(B\\) in the middle and \\(C\\) on the right. Think of what conditions in terms of M should lead to expression of \\(A\\)/ \\(B\\) /\\(C\\). What Hill functions (normal/inverse/any combination) corresponds to those conditions? Write down full equations for the genes, do we need any other terms than just Hill functions?\n\nAnswer \\[\\begin{align}\n\\frac{dA}{dt} = \\text{normal hill}(M)- \\text{decay term}\\],\\ = (M) (M) - ,\\ = (M) - . \\end{align}$$ Furthermore, \\(k_A=k_B_1&lt;k_B_2&lt;k_C\\) to ensure the switches happen at the right places.\n\nBiology & algorithmic/mathematical thinking From hereon we assume that the morphogen gradient reaches steady state very quickly, and no longer use the numerical implementation of the diffusion equation and instead work with the exponential morphogen profile defined by reaction_diffusion_gradient to save time.\n\nChange the simulation loop such that it computes the morphogen gradient once.\nNow create functions to update A, B and C according to your equations from previous question. You may use the hill and ihill functions defined. For simplicity, you may keep most of the parameters the same for each gene, but some have to be different to ensure the right location of the genes.\nAlso make sure that the levels of A, B and C are updated in the simulation loop, and that they are visualized in the bottom plot axis (copy and adapt the code for the visualization of M). You can add an extra third axis to the plot to visualize the (French) flag pattern, by getting which of the three genes is maximal at each location with np.argmax(np.array([A, B, C]),     axis=0) and turning that into an array of RGB colors of choice.\nDo you get the expected “French flag” pattern? If not, think of why not and improve your equations from previous question, parameters or your code.\nHint: using array properties to update A/B/C, like in the reaction_diffusion_step function, makes your code run a lot faster than using for loops.\n\n\nAnswer They will find gene \\(C\\) needs to be induced by low and repressed by high \\(M\\)\n\nBiology At some point in development, the morphogen gradient will disappear. Predict what will happen to the expression of \\(A\\), \\(B\\) and \\(C\\) (and hence the French flag pattern) if the morphogen gradient disappears over time.\n\nAnswer As \\(M\\) decays, \\(A\\) and \\(B\\) will no longer be activated and \\(C\\) no longer repressed, hence the takeover by \\(C\\). The French flag pattern disappears.\n\nAlgorithmic/mathematical thinking Now write the code in reaction_diffusion_gradient that updates the morphogen concentration, such that after the time point \\(A\\), \\(B\\) and \\(C\\) have gotten close to equilibrium, the morphogen gradient gradually disappears. Adapt the simulation loop where necessary and run your code: was your prediction on \\(A\\)/ \\(B\\)/ \\(C\\) from the previous question correct? Why/why not? Hint: you might need to increase the duration of your simulation, especially if it takes a long time for \\(A\\), \\(B\\) and \\(C\\) to reach equilibrium (or you can change the parameters to speed things up).\n\nAnswer It should always result in C taking over.\n\nBiological mathematical thinking \\(A\\), \\(B\\) and \\(C\\) cannot remain in a stable pattern if they are only influenced by \\(M\\). How can we stabilize the pattern in absence of \\(M\\)? Test your ideas by creating new update functions, or adapt the exisiting ones for A, B and C and let the new ‘rules’ kick in when M starts to decline. Again, you may find Hill functions useful and perhaps also the logical structure used in reaction_diffusion_gradient.\n\nAnswer As \\(M\\) decays, \\(A\\) and \\(B\\) will no longer be activated and \\(C\\) no longer repressed, hence the takeover by \\(C\\). They will find mutual repression with only your neighbor gene is not enough, you need it with both 2 other genes\n\nBiology & algorithmic/mathematical thinking A sudden switch from phase 1 (stable \\(M\\) gradient) to phase 2 (decaying \\(M\\) gradient) resulting in the genes following completely different differential equations is biologically implausible. Instead, come up with one integrated expression for each gene, incorporating simultaneous input from the morphogen gradient and the other genes. Create new update functions for A/B/C and test your ideas. Can you get a stable pattern before and after the decline in \\(M\\)? A couple of things you could consider:\n\nThink of how positively and negatively \\(M\\) regulated expression behave once the gradient starts declining: what is the best way to combine (AND/OR) that with the regulation by the genes?\nConsider splitting up the \\(M\\) regulated expression of middle gene \\(B\\) into a positive and negatively regulated morphogen part before integrating the other genes inputs.\nHow can you make regulation more, or less, tightly regulated by small differences in \\(M\\) or gene expression?\nIt is also possible to give certain genes a bit of a constant boost or break\n\n\nAnswer This is highly non-trivial. It requires that for genes (or part of their input) being positively dependent on M that there is an OR gate (sum) (so they stay on once \\(M\\) is absent as long as the mutual repressors are absent) while for genes (or part of their input) being negatively dependent on \\(M\\) that there is an AND gate (so they do not expand once \\(M\\) is absent but require both \\(M\\) absent and mutual repressors absent). Some system that might work:\n\nTODO: insert equations of systems with desired behavior.\nBiology & algorithmic/mathematical thinking Write code in the reaction_diffusion_gradient function to get noise in the morphogen gradient, both in its steady state and decaying phase. During which phase do the expression domains of \\(A\\), \\(B\\) and \\(C\\) suffer more from the noise. Explain why? Which boundary is more affected by the noise and why? How could we make the system more robust in a manner that is also likely occurring in nature?\n\n&gt; **Answer**\n&gt; - *The noise has more effect in the initial phase when mostly morphogen\n    is driving the expression domains, as gene expression becomes\n    established and morphogen levels decay the mutual repression ensures\n    stability against the noise*\n&gt; - *The noise has more effect on the $B$-$C$ than $A$-$B$ boundary, if we use\n    the same amplitude of noise percentage wise this is much more at the\n    lower end of the morphogen boundary, indeed difference between the\n    front and back boundary in vulnerability to noise disappears if\n    noise is made proportionate to max local amplitude*\n&gt; - *Diffusion of $A$, $B$ and $C$, in the lateral direction this evens out\n    differences*",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#extra-questions-if-youre-done-early",
    "href": "pattern_practical_1.html#extra-questions-if-youre-done-early",
    "title": "5  Practical 1",
    "section": "5.6 Extra questions if you’re done early",
    "text": "5.6 Extra questions if you’re done early\n\nBiological thinking: Play with the size of the domain to see what happens to the gene expression domains. What would this mean for an organism?\n\nAnswer They will find that if the domain expands the C domain expands and that if the domain shrinks the C domain disappears\n\nLinking to modern big data approaches Write code to store the expression of genes A, B and C over time and space. First plot this for all time and space points in a 3D plot. Next use a PCA to project the points to a 2D space. Make three different versions of this plot, where you color the points according to time, \\(x\\) and \\(y\\) coordinate respectively. Note how this is similar to applying UMAP dimensionality reduction that is often used on single cell gene expression dynamics (where of course the number of genes is much larger) and applying a pseudotime algorithm to determine in this plots the temporal order in which gene** expression patterns develop. What do you see happening?**\n\nAnswer If all goes well they should see the divergence into a A, B and C celltype\n\nTODO: insert image",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#further-open-questions",
    "href": "pattern_practical_1.html#further-open-questions",
    "title": "5  Practical 1",
    "section": "5.7 Further (open) questions:",
    "text": "5.7 Further (open) questions:\nFeel free to pick one of these questions if you still have time remaining to further explore the model of this tutorial.\n\nIn 2, we can also implement other boundary conditions, especially for the right boundary. What happens to the profile if we make a no-flux boundary? And what if we set it to a sink? &gt;Answer For a no-flux boundary, the level at the rightmost will increase, as it gets trapped there, and hence we get overall slightly higher levels. For a sink boundary, the level rightmost will always be zero, and hence overall levels will be lower.\nFrom 5 onwards, how do things change if we do not assume a quasi-steady-state for the morphogen gradient? How would you implement a disappearing gradient and how does it shape change the outcomes of the flag? &gt; Answer We could let the level at the left-most boundary decay, but this will cause a bit of a bump at low \\(x\\), as the decay needs to move through space. Or we could set it to 0 immediatly. Expected effects are some shifts in the locations of A/B/C, but not huge effects.\nImplement your solution to make the system more robust for noise from question 10. Did it work? &gt; I haven’t tried this.\nWhat type of mechanism could help in maintaining scaling, a similar relative size of the gene \\(A\\), \\(B\\) and \\(C\\) domains if the size of the overall domain is changing.\n\nAnswer * NOT SO TRIVIAL, NEED TO READ UP ON THIS, PERHAPS FUN TO HAVE DIFFERENT GROUPS OF PEOPLE TRY OUT DIFFERENT PROPOSED MECHANISMS*\n\n\nhttps://www.nature.com/articles/ncomms6077\nDagmar Iber group, scaling from non-steady state dynamics and uniform growth\nhttps://pmc.ncbi.nlm.nih.gov/articles/PMC3109599/\nhttps://www.nature.com/articles/ncomms7679\nBicoid gradient: larger eggs get more Bicoid mRNA so higher production rate, when it scales with volume this helps scale the gradient\nhttps://onlinelibrary.wiley.com/doi/10.1111/dgd.12337\nhttps://www.pnas.org/doi/abs/10.1073/pnas.0912734107\nExpansion repression model\nChordin, Bmp, Sizzled\nChordin represses Bmp which induces Sizzled (which has low decay rate), yet Sizzled reduces Chordin decay\nChordin is morphogen\nSizzled is expander (by reducing decay of morphogen)\n\n\n\n\nDriever, Wolfgang, and Christiane Nüsslein-Volhard. 1988. “The Bicoid Protein Determines Position in the Drosophila Embryo in a Concentration-Dependent Manner.” Cell 54 (1): 95–104.\n\n\nWolpert, Lewis. 1969. “Positional Information and the Spatial Pattern of Cellular Differentiation.” Journal of Theoretical Biology 25 (1): 1–47.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#questions",
    "href": "pattern_practical_1.html#questions",
    "title": "5  Practical 1",
    "section": "5.3 Questions",
    "text": "5.3 Questions\nQ1. (Algorithmic thinking) Have a look at the reaction-diffusion equation for the morphogen and the implementation of it in the file morphogengradient_to_segments.py in the reaction_diffusion_step function, as well as at the initialization of the array u. How is this different from the gradient formation modeling we discussed during the lecture? What is done at the terminal boundary in the length direction and why does this make sense? (hint: outcommented we provided code doing essentially the same but not using numpy arrays and hence written in a less compact matter to help you understand what is happening)\nQ2. (Important concept) Play with the morphogen diffusion rate and the morphogen decay rate and describe what happens. What happens in terms of dynamics and steady state if you change both, but the ratio stays the same? Hint: it might help to draw a horizontal line at a certain height to ease comparison.\nQ3 (Biology & mathematical thinking) Next, we are going to introduce the genes A, B and C in the model. We want these genes to be expressed dependent on M, and in the head, trunk and tail respectively, so A on the left, B in the middle and C on the right. Think of what conditions in terms of M should lead to expression of A/B/C. What Hill functions (normal/inverse/any combination) corresponds to those conditions? Write down (pen and paper, not in code) full equations for the genes, do we need any other terms than just Hill functions, would we need specific parameter conditions?\nQ4 (Biology & algorithmic/mathematical thinking) From hereon we assume that the morphogen gradient reaches steady state very quickly, and no longer use the numerical implementation of the diffusion equation and instead work with a superimposed morphogen profile defined by reaction_diffusion_gradient to save time. (Hint: to not call the function any more use # in front of where it is called) Change the simulation loop such that it computes the morphogen gradient once. What type of function is the superimposed morphogen profile and how does this relate to question 2.\nQ5 (Biology & algorithmic/mathematical thinking)\n\nNow create functions to update A, B and C according to your equations from the previous question. You may use the predefined hill and ihill functions that are provided in the code. For simplicity, you may keep most of the parameters the same across genes, but some have to be different to ensure the right location of the genes (see your reasoning to the previous question). (Hint: using array properties to update A/B/C, like in the reaction_diffusion_step function, makes your code run a lot faster than using for-loops)\nAlso make sure that the levels of A, B and C are updated in the simulation loop. (Hint: using array properties to update A/B/C, like in the reaction_diffusion_step function, makes your code run a lot faster than using for-loops)\nNext, ensure A, B and C are visualized in the bottom plot axis (copy and adapt the code for the visualization of M). You can add an extra third axis to the plot to visualize the (French) flag pattern, by getting which of the three genes is maximal at each location with np.argmax(np.array([A, B, C]), axis=0)and turning that into an array of RGB colors of choice.\nDo you get the expected “French flag” pattern? If not, think of why not and improve your equations from previous question, parameters or your code.\n\nQ6 (Biology) At some point in development, the morphogen gradient will disappear, for example in the case of the Drosophila Bicoid gradient because the maternal mRNA is degraded. Predict what will happen to the expression of A,B and C (and hence the French flag pattern) if the morphogen gradient disappears over time and assume A, B, and C are regulated by our equations (first try think about this without actually simulating this).\nQ7 (Algorithmic/mathematical thinking) Now write the code in reaction_diffusion_gradient that updates the morphogen concentration, such that after the time point A, B and C have gotten close to equilibrium, the morphogen gradient gradually disappears. Adapt the simulation loop where necessary and run your code: was your prediction on A/B/C from the previous question correct? Why/why not? Hint: you might need to increase the duration of your simulation, especially if it takes a long time for A, B and C to reach equilibrium (or you can change the parameters to speed things up by using same production/degradation rate ratio yet higher absolute values of the individual parameters).\nQ8 Biological & mathematical thinking A, B and C cannot remain in a stable pattern if they are only influenced by M. How can we stabilize the pattern in absence of M? Test your ideas by creating new update functions for A, B and C and let these new ‘rules’ kick in at the same time when M starts to decline. Again, you may find Hill functions useful and perhaps also the before/after switch time structure used in reaction_diffusion_gradient for M. (Hint: think about how the genes should affect each other, and assume that in this new phase, when genes have already been initialized in absence of repression the genes will be expressed). Can you maintain the expression domains of A, B and C and does their shape change?\nQ9 (Biology & algorithmic/mathematical thinking) A sudden switch from phase 1 (stable M gradient) to phase 2 (decaying M gradient) resulting in the genes following different differential equations is biologically implausible. In reality, genes have complex promotors and enhancers integrating different inputs that arise in different developmental stages. Try to come up with one integrated expression for each gene, incorporating simultaneous input from the morphogen gradient and the other genes. Create new update functions for A/B/C and test your ideas. Can you get a stable pattern before and after the decline in M? A couple of things you could consider: a. Think of how positively and negatively M regulated expression behave once the gradient starts declining: what is the best way to combine (AND/OR) that with the regulation by the genes? a. Consider splitting up the M regulated expression of middle gene B into a positive and negatively regulated morphogen part before integrating the other genes inputs. a. It is also possible to give certain genes a bit of a constant boost to prevent their takeover by other genes due to timing issues\nQ10. Biology & algorithmic/mathematical thinking Write code to get noise in the morphogen gradient, both in its steady state and decaying phase. During which phase do the expression domains of A, B and C suffer more from the noise. Explain why? How could we make the system more robust in a manner that is also likely occurring in nature?\n\nExtra questions for if you’re done early/ for master students. These questions need not be made in the order they are provided, you can choose what you would like to investigate.\nQ11 (Biological thinking) Play with the size of the domain to see what happens to the gene expression domains. What would this mean for an organism?\nQ12 (Biological & algorithmic thinking) Various mechanisms have been proposed to ensure that the domains of the morphogen controlled genes scale with the size of the domain. One proposed mechanism suggests the existence of an also diffusible “expander” molecule which expression is repressed by the morphogen but which itself either represses the degradation of the morphogen or enhances its diffusion (see e.g. https://www.pnas.org/doi/full/10.1073/pnas.0912734107 and https://onlinelibrary.wiley.com/doi/10.1111/dgd.12337).\nFor the expander we can write:\n\\[\n∂E/∂t=p K^h/(K^h+M^h )-dE+D_E ∆E\n\\]\nAssume E reduces degradation of M (easier to implement than enhancement of diffusion) and study the effect of scaling. (Hint, vary the size of the domain in the length direction but plot domains as a function of relative instead of absolute domain size to compare domain sizes).\nQ13 (Algorithmic thinking) In b, we can also implement other boundary conditions, especially for the right boundary. What happens to the profile if we make a no-flux boundary by copying the value at n-2 to n-1? And what if we set it to a sink (force concentration to zero)?\nQ14 From question 4 onwards, how do things change if we do not assume a quasi-steady-state for the morphogen gradient (i.e. keep the morphogen dynamics instead of replacing it by the superimposed exponential)? How would you implement a disappearing gradient and how does it shape change the outcomes of the flag?\nQ15 Implement your solution to make the system more robust for noise from question 10. Did it work?",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#answers-to-the-exercises",
    "href": "pattern_practical_1.html#answers-to-the-exercises",
    "title": "5  Practical 1",
    "section": "5.5 Answers to the exercises",
    "text": "5.5 Answers to the exercises\nAnswer Q1\nAn important difference relative to the lecture is that instead of implementing a production term at the x=0 position, we instead fixed the concentration of u at x=0 at 100 and have nowhere a production term. This implies that we assume that production is very high and different D and d values have negligible effects on the level at x=0. The advantage of this approach is that we can easily study what different D and d does, as it only affects the shape of the gradient but not the maximum.\nInstead of using if/else to check for boundary conditions, we only compute the Laplacian in the inner, non-boundary points. For the x=0 boundary we already set a constant value. For y=0 and y=n−1 we copy the values from y=1 and y=n−2 as the patterning is identical in that direction. For x=n−1 we use a special approach: if n−3=0 we assume it is zero; otherwise, we calculate the ratio of x at n−2 and n−3 to approximate the decay and multiply this with the value at x=n−2 to estimate x at n−1. Simply copying x at n−2 would add matter to the system and prevent the gradient from reaching a steady state.\nAnswer Q2\nThe imposed morphogen profile is an exponential gradient. The negative sign indicates a decline, the term i·dx converts the grid index to spatial distance, and the division by √(D/d) ensures that if i·dx = λ = √(D/d), we have e⁻¹ = 1/e, meaning an e-fold decay — as expected for a steady-state diffusion gradient.\nAnswer Q3\nThe relevant concept is the diffusion length, √(D/d). It is the ratio between these parameters that determines the characteristic length scale λ over which the morphogen concentration decays e-fold. Changing both D and d while keeping the ratio constant preserves the shape of the steady-state gradient, but faster rates lead to a quicker approach to steady state.\nAnswer Q4\ndA/dt = normal hill(M) − decay term\ndB/dt = normal hill(M) × inverse hill(M) − decay term\ndC/dt = inverse hill(M) − decay term\nFurthermore, kA = kB₁ &lt; kB₂ &lt; kC to ensure the switches happen at the correct positions.\nAnswer Q5\nGene C needs to be induced by low M and repressed by high M. Together with kA = kB₁ &lt; kB₂ &lt; kC, this generates the expected “French flag” pattern with distinct domains for A, B, and C.\nAnswer Q6\nAs M decays, A and B will no longer be activated and C will no longer be repressed, leading to a takeover by C. Consequently, the French flag pattern disappears.\nAnswer Q7\nWhen the morphogen gradient gradually disappears, C always takes over. This confirms the prediction that as M declines, C dominates due to loss of repression on its expression domain.\nAnswer Q8\nAs M decays, A and B lose activation and C loses repression, again leading to takeover by C. They will find that mutual repression with only one neighboring gene is insufficient — stability requires each gene to repress both others (A repressed by B and C, B by A and C, and C by A and B). This maintains A at the beginning, B in the middle, and C at the end, although expression domains become sharper.\nAnswer Q9\nAchieving a smooth transition between the stable and decaying phases of M requires integrated gene regulation.\n\nFor genes (or parts thereof) that are positively dependent on M, use an OR gate (sum): this keeps them on once M disappears, provided mutual repressors are absent.\nFor genes (or parts thereof) that are negatively dependent on M, use an AND gate (product): this prevents them from expanding when M vanishes, requiring both low M and absence of repression.\nSuch combined formulations better represent biological promoter logic and yield stability before and after the morphogen decline.\n\nAnswer Q10\nNoise has the strongest effect during the initial phase when morphogen levels dominate, since mutual repression has not yet stabilized the pattern. As gene expression becomes established and M decays, the system becomes more robust.\nDiffusion of A, B, and C in the lateral direction would further smooth out local variations and enhance robustness (not implemented in the current version).\nAnswer Q11 (Extra)\nIf the domain expands, the C domain enlarges; if the domain contracts, the C domain disappears. In biological terms, this would mean losing or gaining posterior body regions (“butt” part).\nAnswer Q12 (Extra)\nIntroducing a diffusible “expander” molecule E that is repressed by M but reduces M’s degradation can create scaling of gene domains with overall tissue size. For example:\n∂E/∂t = p·Kʰ/(Kʰ + Mʰ) − dE + D_E·ΔE\nVarying the domain length while plotting results against relative position (x/L) should show improved scaling of A/B/C domains.\nAnswer Q13 (Extra)\nCopying n−2 to n−1 introduces artificial accumulation at the boundary and prevents steady state. Setting it to zero (sink) has not been tested but is expected to lower concentrations and possibly speed up stabilization.\nAnswer Q14 (Extra)\nWithout assuming quasi–steady-state for M, one can simulate a dynamic morphogen gradient by allowing production at x=0 to decay over time or by letting the exponential decline parameter itself vary. This will likely lead to different transient shapes and small shifts in A/B/C domains compared to a static exponential.\nAnswer Q15 (Extra)\nImplementing diffusion of A, B, and C is expected to smooth out local noise effects and enhance robustness of the spatial pattern, consistent with what is observed in natural systems.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#further-reading",
    "href": "pattern_practical_1.html#further-reading",
    "title": "5  Practical 1",
    "section": "5.6 Further reading",
    "text": "5.6 Further reading\nhttps://www.nature.com/articles/ncomms6077\nDagmar Iber group, scaling from non-steady state dynamics and uniform growth\nhttps://pmc.ncbi.nlm.nih.gov/articles/PMC3109599/\nhttps://www.nature.com/articles/ncomms7679\nBicoid gradient: larger eggs get more Bicoid mRNA so higher production rate, when it scales with volume this helps scale the gradient\nhttps://onlinelibrary.wiley.com/doi/10.1111/dgd.12337\nhttps://www.pnas.org/doi/abs/10.1073/pnas.0912734107\nExpansion repression model\nChordin, Bmp, Sizzled\nChordin represses Bmp which induces Sizzled (which has low decay rate), yet Sizzled reduces Chordin decay\nChordin is morphogen\nSizzled is expander (by reducing decay of morphogen)\n\n\n\n\nDriever, Wolfgang, and Christiane Nüsslein-Volhard. 1988. “The Bicoid Protein Determines Position in the Drosophila Embryo in a Concentration-Dependent Manner.” Cell 54 (1): 95–104.\n\n\nWolpert, Lewis. 1969. “Positional Information and the Spatial Pattern of Cellular Differentiation.” Journal of Theoretical Biology 25 (1): 1–47.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#relevant-literature-further-reading",
    "href": "pattern_practical_1.html#relevant-literature-further-reading",
    "title": "5  Practical 1",
    "section": "5.6 Relevant literature / further reading",
    "text": "5.6 Relevant literature / further reading\nhttps://www.nature.com/articles/ncomms6077\nDagmar Iber group, scaling from non-steady state dynamics and uniform growth\nhttps://pmc.ncbi.nlm.nih.gov/articles/PMC3109599/\nhttps://www.nature.com/articles/ncomms7679\nBicoid gradient: larger eggs get more Bicoid mRNA so higher production rate, when it scales with volume this helps scale the gradient\nhttps://onlinelibrary.wiley.com/doi/10.1111/dgd.12337\nhttps://www.pnas.org/doi/abs/10.1073/pnas.0912734107\nExpansion repression model\nChordin, Bmp, Sizzled\nChordin represses Bmp which induces Sizzled (which has low decay rate), yet Sizzled reduces Chordin decay\nChordin is morphogen\nSizzled is expander (by reducing decay of morphogen)\n\n\n\n\nDriever, Wolfgang, and Christiane Nüsslein-Volhard. 1988. “The Bicoid Protein Determines Position in the Drosophila Embryo in a Concentration-Dependent Manner.” Cell 54 (1): 95–104.\n\n\nWolpert, Lewis. 1969. “Positional Information and the Spatial Pattern of Cellular Differentiation.” Journal of Theoretical Biology 25 (1): 1–47.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_answers.html",
    "href": "pattern_answers.html",
    "title": "8  Answers",
    "section": "",
    "text": "8.1 Answers partical 1\nAnswer Q1\nAn important difference relative to the lecture is that instead of implementing a production term at the x=0 position, we instead fixed the concentration of u at x=0 at 100 and have nowhere a production term. This implies that we assume that production is very high and different D and d values have negligible effects on the level at x=0. The advantage of this approach is that we can easily study what different D and d does, as it only affects the shape of the gradient but not the maximum.\nInstead of using if/else to check for boundary conditions, we only compute the Laplacian in the inner, non-boundary points. For the x=0 boundary we already set a constant value. For y=0 and y=n−1 we copy the values from y=1 and y=n−2 as the patterning is identical in that direction. For x=n−1 we use a special approach: if n−3=0 we assume it is zero; otherwise, we calculate the ratio of x at n−2 and n−3 to approximate the decay and multiply this with the value at x=n−2 to estimate x at n−1. Simply copying x at n−2 would add matter to the system and prevent the gradient from reaching a steady state.\nAnswer Q2\nThe imposed morphogen profile is an exponential gradient. The negative sign indicates a decline, the term i·dx converts the grid index to spatial distance, and the division by √(D/d) ensures that if i·dx = λ = √(D/d), we have e⁻¹ = 1/e, meaning an e-fold decay — as expected for a steady-state diffusion gradient.\nAnswer Q3\nThe relevant concept is the diffusion length, √(D/d). It is the ratio between these parameters that determines the characteristic length scale λ over which the morphogen concentration decays e-fold. Changing both D and d while keeping the ratio constant preserves the shape of the steady-state gradient, but faster rates lead to a quicker approach to steady state.\nAnswer Q4\ndA/dt = normal hill(M) − decay term\ndB/dt = normal hill(M) × inverse hill(M) − decay term\ndC/dt = inverse hill(M) − decay term\nFurthermore, kA = kB₁ &lt; kB₂ &lt; kC to ensure the switches happen at the correct positions.\nAnswer Q5\nGene C needs to be induced by low M and repressed by high M. Together with kA = kB₁ &lt; kB₂ &lt; kC, this generates the expected “French flag” pattern with distinct domains for A, B, and C.\nAnswer Q6\nAs M decays, A and B will no longer be activated and C will no longer be repressed, leading to a takeover by C. Consequently, the French flag pattern disappears.\nAnswer Q7\nWhen the morphogen gradient gradually disappears, C always takes over. This confirms the prediction that as M declines, C dominates due to loss of repression on its expression domain.\nAnswer Q8\nAs M decays, A and B lose activation and C loses repression, again leading to takeover by C. They will find that mutual repression with only one neighboring gene is insufficient — stability requires each gene to repress both others (A repressed by B and C, B by A and C, and C by A and B). This maintains A at the beginning, B in the middle, and C at the end, although expression domains become sharper.\nAnswer Q9\nAchieving a smooth transition between the stable and decaying phases of M requires integrated gene regulation.\nSuch combined formulations better represent biological promoter logic and yield stability before and after the morphogen decline.\nAnswer Q10\nNoise has the strongest effect during the initial phase when morphogen levels dominate, since mutual repression has not yet stabilized the pattern. As gene expression becomes established and M decays, the system becomes more robust.\nDiffusion of A, B, and C in the lateral direction would further smooth out local variations and enhance robustness (not implemented in the current version).\nAnswer Q11 (Extra)\nIf the domain expands, the C domain enlarges; if the domain contracts, the C domain disappears. In biological terms, this would mean losing or gaining posterior body regions (“butt” part).\nAnswer Q12 (Extra)\nIntroducing a diffusible “expander” molecule E that is repressed by M but reduces M’s degradation can create scaling of gene domains with overall tissue size. For example:\n∂E/∂t = p·Kʰ/(Kʰ + Mʰ) − dE + D_E·ΔE\nVarying the domain length while plotting results against relative position (x/L) should show improved scaling of A/B/C domains.\nAnswer Q13 (Extra)\nCopying n−2 to n−1 introduces artificial accumulation at the boundary and prevents steady state. Setting it to zero (sink) has not been tested but is expected to lower concentrations and possibly speed up stabilization.\nAnswer Q14 (Extra)\nWithout assuming quasi–steady-state for M, one can simulate a dynamic morphogen gradient by allowing production at x=0 to decay over time or by letting the exponential decline parameter itself vary. This will likely lead to different transient shapes and small shifts in A/B/C domains compared to a static exponential.\nAnswer Q15 (Extra)\nImplementing diffusion of A, B, and C is expected to smooth out local noise effects and enhance robustness of the spatial pattern, consistent with what is observed in natural systems.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Answers</span>"
    ]
  },
  {
    "objectID": "pattern_answers.html#answers-partical-1",
    "href": "pattern_answers.html#answers-partical-1",
    "title": "8  Answers",
    "section": "",
    "text": "For genes (or parts thereof) that are positively dependent on M, use an OR gate (sum): this keeps them on once M disappears, provided mutual repressors are absent.\nFor genes (or parts thereof) that are negatively dependent on M, use an AND gate (product): this prevents them from expanding when M vanishes, requiring both low M and absence of repression.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Answers</span>"
    ]
  },
  {
    "objectID": "pattern_intro_text.html",
    "href": "pattern_intro_text.html",
    "title": "4  Pattern formation",
    "section": "",
    "text": "TODO\n\nWrite a short intro on pattern formation part of the practicals.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pattern formation</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html",
    "href": "pattern_practical_2.html",
    "title": "6  Practical 2",
    "section": "",
    "text": "TODO",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#turing-patterns-repetitive-patterning",
    "href": "pattern_practical_2.html#turing-patterns-repetitive-patterning",
    "title": "6  Practical 2",
    "section": "6.1 Turing patterns, repetitive patterning",
    "text": "6.1 Turing patterns, repetitive patterning\nConceptual thinking: The model proposed by Raspopovic et al. for generating Turing patterns underlying limb bone modeling consists of 3 instead of 2 interacting variables. Simplify the given interaction scheme and diffusion constants to a 2D system to identify the relevant Turing constraints\nAlgorithmic thinking: Compare the code used here to implement diffusion (lines …) with the code used in the exercise on the French Flag. What do you think this code is doing? What kind of boundary conditions do you think are implemented\nBiology: First we are going to work with a code simulating the model in a 2D constant tissue, this can be considered as a petri dish in which the mesenchymal cells have been plated with the correct chemicals to undergo bone formation (Fig .. in the paper). Play with the reaction parameters and diffusion constants to study their effects on the wavelength of the patterns\nBiology: Now we are going to add tissue growth in the proximo-distal (body to limb) direction. Growth is controlled by a growth rate vi. Play with this rate and study what happens. Explain why this happens.\nIf the growth rate is large enough the induced anisotropy causes the orientation of Turing stripes along the growth axis. This can be understood from the directional expansion of the growth and hence diffusion domain, with the activator mostly spreading in this growth direction, leading to stripe formation.\nBiology: In reality the paddle shaped limb growth in both the proximo-distal and anterior-posterior direction, implemented with growth rates vi and vj. Play with the relative size of these growth rates and study what happens. Also study the order of appearance of digits and how this compares to the experimental data. Does the pattern fully resemble experimental observations?\nTo not loose the anisotropy vi&gt;&gt;vj. Middle digits appear first and as expansion occurs in the anterior-posterior plane more digits appear. No, digits do not come closer together at proximal end\nBiology: In reality digits are patterned further apart at the distal end then at the proximal end, where they need to converge on a hand and wrist. This implies that the wavelength of the Turing pattern should not be constant. If all is well you found that the k7 and k4 parameters impact the wavelength of the Turing pattern. The authors speculate that the FGF and Hox gene gradients observed in the limb bud excert an effect on the Sox9-BMP-Wnt patterning module through these parameters. Implement a gradient of increasing k7 and decreasing k4 from the proximal to the distal end of the growing limb and try if you can get closer to a realistic limb patterning.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#biology-polydactyly-evolution",
    "href": "pattern_practical_2.html#biology-polydactyly-evolution",
    "title": "6  Practical 2",
    "section": "6.2 Biology: polydactyly? Evolution?",
    "text": "6.2 Biology: polydactyly? Evolution?",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#python-code",
    "href": "pattern_practical_2.html#python-code",
    "title": "6  Practical 2",
    "section": "6.3 Python code",
    "text": "6.3 Python code\n\n\n\n\n\n\nStarting code for this practical\n\n\n\n\n\nThere are several sources for this practical.\n…\n\n\n\nIf two days: phyllotaxis model.\nGood to do after clock and wavefront a general overview:\nWhat happens if more growth/tissue in\n-gradient (rear extends if no scaling)\n-Turing (more stripes)\n-clock and wavefront (bigger stripes)",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html",
    "href": "pattern_practical_3.html",
    "title": "7  Practical 3",
    "section": "",
    "text": "7.1 Clock-and-wavefront patterning",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#clock-and-wavefront-patterning",
    "href": "pattern_practical_3.html#clock-and-wavefront-patterning",
    "title": "7  Practical 3",
    "section": "",
    "text": "TODO\n\nMove the answers to a separate page\nLinks to github for the code",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#goal-of-the-tutorial",
    "href": "pattern_practical_3.html#goal-of-the-tutorial",
    "title": "7  Practical 3",
    "section": "7.2 Goal of the tutorial:",
    "text": "7.2 Goal of the tutorial:\nIn this tutorial you will look at gradient formation and patterning using different mechanisms than you have seen previously. We will model the so called clock-and-wavefront pattern, which stems from oscillations in gene and gene products and results in a regularly striped pattern in a growing tissue.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#the-model-system",
    "href": "pattern_practical_3.html#the-model-system",
    "title": "7  Practical 3",
    "section": "7.3 The model system",
    "text": "7.3 The model system\nThe clock-and-wavefront model is an important model in describing somitogenesis. In this process early in embryo development, the somites, a precursor tissue for the vertebrae and other tissues later in development, are formed from the pre-somitic mesoderm. This mesodorm extends on the posterior end by growth, and the somites bud off periodically at the anterior end in the order of a couple of weeks (in humans).\nKey players in this model system are the protein FGF (fibroblast growth factor), and many genes and gene products that have an oscillatory pattern that will determine cell fate. However, for this tutorial, we simplify this to a single pair of gene mRNA and product, denoted with \\(m\\) and \\(p\\) for short.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#programming-with-classes",
    "href": "pattern_practical_3.html#programming-with-classes",
    "title": "7  Practical 3",
    "section": "7.4 Programming with classes",
    "text": "7.4 Programming with classes\nBecause we are going to make a more complex model with a tissue existing of multiple cells, and each cell having its own concentrations of FGF, \\(m\\) and \\(p\\), we are going to use Classes in our code. You have been using Classes already: the data types such as int, str and bool have their own class, and the str class has many methods (=functions working on that class) defined, such as \"hello world\".upper(), but it is also possible to create custom classes. With classes, you can easily make objects, which is part of the object-oriented programming paradigm.\nToday, we are going to use classes for the different levels of our model: 1) tissue, 2) cell, 3) \\(m\\) & \\(p\\) clock and 4) the plotting. By using classes, we can separate things that happen on a tissue/cellular/clock scale, and seperate the model from the visualization of it. You will first work with 1 & 2 & 4, then 3 on its own and then combine all four yourself into one model.\nImportant concepts when working with classes are\n\nClass versus instance\nDefining the __init__ method and other methods\nClass attributes and using the keyword self\n\nThis tutorial should be doable without an extensive knowledge of classes as there are plenty of examples to copy-paste from, but feel free to read up on these concepts here at this online tutorial",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#relevant-literature",
    "href": "pattern_practical_3.html#relevant-literature",
    "title": "7  Practical 3",
    "section": "7.5 Relevant literature",
    "text": "7.5 Relevant literature\nIf you want to know more about the model system and previous models, have a look at the following (after the tutorial):\nLewis (2003) _Autoinhibition with Transcriptional Delay A Simple Mechanism for the Zebrafish Somitogenesis Oscillator",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#exercises",
    "href": "pattern_practical_3.html#exercises",
    "title": "7  Practical 3",
    "section": "7.6 Exercises",
    "text": "7.6 Exercises\n\nIn practical 1 we saw how gradients can be created through local production, diffusion and decay. However, other mechanisms for gradient formation are possible, such as cell lineage transport. Here we work with a model for the FGF gradient (fgfgradientfromgrowth.py) where only the rightmost/posterior cell produces FGF and grows, and in which cells upon division inherit this FGF from their mother cell. Play with the model by varying the decay rate of FGF and the division rate of the cells. How does this affect the gradient?\n\n\nAnswer If growth rate goes up cell volumes increase faster, causing more dilution of FGF and hence a lower maximum of the gradient as due to the stable protein quite some time is needed to compensate for this decrease by more production, at the same time the gradient is less steep as cell division follow up faster and hence less time has passed and less day has taken place. If decay rate goes up, maximum goes down but gradient become steeper and shorter as for same time between divisions more decay takes place\n\n\nConceptual thinking When would this type of gradient formation be more applicable than the earlier studied production, diffusion, decay type of gradient formation? Compare how this model is built-up to a production/diffusion/decay gradient formation model.\n\nAnswer Diffusion slow, degradation slow. In other words, a mostly stable, immobile compound.\n\nMathematics Let us now move to the other half of the clock and wavefront model, the clock part (clock.py), in which we implemented one of the earliest models for the somitogenesis oscillator from Lewis (2003) which models a gene that codes for a mRNA (\\(m\\)) that encodes a protein (\\(p\\)) that acts as a repressive transcription factor of this same gene. In class we discussed how for oscillations negative feedbacks, delays and non-linearity are important. Examine the code to find the differential equations governing this model and determine the negative feedback, delay and non-linearities in them.\n\n\nAnswer Non-linearity is in saturation function with power n, negative feedback is because affects own expression negatively, delay is here modeled explicitly through a special delay type differential equation\n\n\nBiology Play with the parameters of the model. How does the delay (tau/ \\(\\tau\\)) affect oscillations? &gt; Answer longer period (lower frequency) and higher amplitude. Remember how in class we discussed how removing introns reduced delays and affected oscillator period.\nAlgorithmic thinking In the file rolling_clock.py, there is a different implementation of the clock. Compare the two files and find out how they differ. What benefits for studying the model does clock.py have over rolling_clock.py and vice versa? Ignore the added functions __copy__ and set_tau in this comparison. Some differences become clearer when you run the code too.\n\nAnswer The rolling clock only remembers a certain time window of the clock state, namely as long as needs to be remembered plus some buffer for when the clock’s tau changes. A drawback is that not all history is memorized, but it could still be stored to a file. A big win is clear when we run the code and see that it is much faster, especially at later time points.\n\nNext, we will combine the clock and FGF wavefront into a single model. For this, we offer two options of this exercise: A. reading and interpreting existing code from the file clockplusfgf.py, or B. write your own code to combine the two.\n\nRead and interpret existing code: Read the code of clockplusfgf.py and try to understand the assumptions from this model implementation by answering the following questions:\n\nEach cell has its own clock. What clock states is the tissue initialized with? And what clock states do newly divided cells get?\nThe FGF wavefront affects tau: what function is used for that? What are your expectations for the effect of the FGF wavefront on the cells’ clocks?\nDoes growth affect the clock state?\nWhat is your opinion on the assumptions from the three questions? &gt; Answer &gt; 1. The cells are initialized with the same state, namely the default with &gt; m=0 and p=0, and all clock parameters set to one defined in the file. &gt; Newly divided cells get the same clock as the original cell, so we get &gt; two exact copies. &gt; 2. The function is \\[\\tau_\\text{cell}=\\tau_\\text{model}(1+0.5\\frac{100-\\text{FGF}\\_\\text{cell}}{100}),\\] &gt; where \\(\\tau_\\text{cell}\\) is the cell’s new \\(tau\\) and \\(\\tau_\\text{model}\\) the general “model” one’s. &gt; So, we would expect tau to become larger, i.e., the clock to become slower as the FGF wavefront &gt; decays the further to the left we get. &gt; 3. No, there is currently no dilution from \\(m\\) or \\(p\\) from growth. &gt; 4. If we start with few cells that are likely also each other’s sister cells, &gt; the assumption of the same, or at least similar clock states is plausible. &gt; Same for cell division assuming the molecules get evenly distributed. &gt; The current function of FGF on \\(\\tau\\) is imposed, but the idea of slowing down is from &gt; experimental observations. &gt; We could argue about the effect of growth on the clock state, but only few cells are &gt; dividing, so including growth in there would have only a limited effect (but feel free &gt; to test this!).\n\nProgramming As to not spoil the beans to students not wanting to code the model extension, since the hints for programming may answer above questions, please see instructions for implementing it yourself at the end of this tutorial.\n\nBiology With the existing model, or your own model working, describe how this model behaves. Do we get stable somites?\n\nAnswer we get waves of oscillations moving from left to right with increasing amplitudes. Not yet conversion to a stable stripe pattern\n\nBiology & Programming What is still missing is a means to transform the temporal oscillations in the posterior of the tissue into a spatial pattern in the anterior. Now, let’s implement a model that allows for fixation of the somite states.\n\nWe will add an extra ‘memory’ molecule M inside the cell that will be produced depending on the values of FGF and the clock.. To do so add a new attribute to the cell Class that will contain the value of a memory molecule. Also, upon division, let cells inherit the memory value from the mother cell.\nChange the run_clocks function by creating two conditions:\n\nIf the fgf level is between some upper and some lower bound, the clock is updated and simulated after the memory value is updated according to this formula: \\[\\frac{dM}{dt}=c\\max\\left(\\frac{p^4}{h_p^4+p^4}, \\frac{M^4}{h_M^4+M^4}\\right)-\\delta M.\\] Add the new memory parameters as global parameters at the top of the file. For starters, you can give them the following values:\n\n\\(\\text{FGF upper bound}=10\\)\n\\(\\text{FGF lower bound}=9.75\\)\n\\(c=0.01\\)\n\\(h_p=8.5\\)\n\\(h_M=0.5\\)\n\\(\\delta=0.01\\)\n\nOtherwise, the clock is updated and simulated as normal, and nothing changes with the memory molecule of the cell\n\nTo visualize the memory, follow the same procedure as for visualizing the fgf and p values: put in a string referring to the new attribute you created for the molecule in step 1.\n\nBiology Do you get stable somite formation on the left/anterior of the tissue? Is it a regular pattern of somites? What happens if the requirement for updating \\(M\\) is only that FGF should be below a certain value? What happens if the equation for \\(\\frac{dM}{dt}\\) only depends on \\(p\\) and not \\(M\\) itself.\n\n\nAnswer They should get somite patterns that are stable, but not necessarily regular. If only one threshold all goes to high state, because eventually all go through all phases, you need to memorize who was within a limited time/space window in a particular state. If only P dependent M is activated but does not memorize so it will be just as unstable as P before.\n\n\nBiology Both zebrafish and mice are common model organisms, so we know a lot about the biological parameters of their somitogenesis. See the following list:\n\n\n\n\n\n\n\n\n\n\nParameter\nZebrafish\nReference\nMouse\nReference\n\n\n\n\nDuration of somitogenesis\n18 h\n(a)\n5 days\n(b)\n\n\nNumber of somites\n~30\n(a)\n65\n(c)\n\n\nSomite size\n50 micron / 30 micron\n(d) (a)\n120 micron\n(c)\n\n\nCells per somite\n~5 cell in diameter\n(a)\n5-11 (estimated from total cell size in 3D, ranging 1 order of magnitude)\n(c)\n\n\nClock period\n25 min /30 min\n(d) / (e) / (f)\n2-3 h\n(e)\n\n\n\nFrom these parameters, you can derive a number of desired model inputs/outcomes:\n\nThe total size of the tissue at the end of somitogenesis\nThe size of a cell\nSpeed of division\n\nUse the model and try to find suitable model parameters to recreate the development of both zebrafish and mice: is this model able to describe both of these processes? I.e., is this model able to deal with the scale differences between zebrafish and mice?\nA couple of notes:\n\nYou don’t have to exactly recreate the biological parameter with 100% precision, except for the number of segments/somites, although it can be a fun challenge to get a complete match.\nYou might want to adapt your plotting timestep to have sufficient but not too many plot updates in one simulation.\nYou can test the clock parameters separately with the clock.py/rolling_clock.py script. Don’t forget that FGF has an effect on tau!",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#further-open-questions",
    "href": "pattern_practical_3.html#further-open-questions",
    "title": "7  Practical 3",
    "section": "7.7 Further (open) questions",
    "text": "7.7 Further (open) questions\nThe model currently has a number of assumptions that we can question. Feel free to explore any of these further open questions and study how it effects the outcome of the model:\n\nWhat if the relationship between FGF and tau is shaped differently? For instance, if the clock runs faster on the left/anterior than on the right/posterior?\nWhat if the clock state of a daughter cell is started fresh rather than being a copy from the mother cell?\nWhat if the clock \\(m\\) and \\(p\\) are diluted by growth?\nWhat if tau is unaffected by FGF: can we still get somites fixed in place?",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#references-for-biological-parameters",
    "href": "pattern_practical_3.html#references-for-biological-parameters",
    "title": "7  Practical 3",
    "section": "7.8 References for biological parameters:",
    "text": "7.8 References for biological parameters:\n\nhttps://anatomypubs.onlinelibrary.wiley.com/doi/10.1002/1097-0177(2000)9999:9999%3C::AID-DVDY1065%3E3.0.CO;2-A\nhttps://doi.org/10.1016/j.gde.2012.05.004\nhttps://doi.org/10.1242/dev.65.Supplement.103\nhttps://doi.org/10.1242/dev.161257\nhttps://doi.org/10.3389/fcell.2022.944016\nhttps://www.sciencedirect.com/science/article/pii/S0079610718300178",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#combining-the-clock-and-fgf-wavefront-model---programming-instructions",
    "href": "pattern_practical_3.html#combining-the-clock-and-fgf-wavefront-model---programming-instructions",
    "title": "7  Practical 3",
    "section": "7.9 Combining the clock and FGF wavefront model - programming instructions",
    "text": "7.9 Combining the clock and FGF wavefront model - programming instructions\nLet us now combine the (rolling) clock and the wavefront, and assume that the FGF wavefront affects tau such that as FGF levels drop tau goes up and oscillations slow. Here are some tips and hints to help you along the way:\n\nTry implementing things in steps and run your code in between steps: this is easier to debug than changing everything in one go.\nUse the file rolling_clock.py to import the clock class from. Make sure that every cell gets initialized with a clock by adding a clock as a cell Class attribute.\nOf course, we must not forget that a cell inherits the clock from its mother. Use the __copy__ method from the clock Class to set the clock of the freshly divided daughter cell the same as the mother’s.\nThere are many ways that FGF could affect tau. For this tutorial, stick to the following relationship: \\[\\tau_\\text{cell}=\\tau_\\text{model}(1+0.5\\frac{100-\\text{FGF}\\_\\text{cell}}{100}),\\] where \\(\\tau_\\text{cell}\\) is the tau of a specific cell, and \\(\\tau_\\text{model}\\) is a global tau set as a model parameter. To implement this, create a method update_clock for the cell Class, that uses the clock Class’s set_tau method to update the clock of the cell.\nMake a method in the tissue class called run_clocks that simulates the clock of every cell in the tissue. Use the Clock’s simulate method. For simplicity, we assume that growth does not affect the concentrations of \\(m\\) and \\(p\\).\nMake sure that the tissue method run_clocks also updates the clock of the cell, and that the simulate_development function also lets the clocks run.\nVisualize the p values of every cell. You can reuse the existing visualisation methods initialize_axis_cell_data and update_plot_cell_data from graphics.py, but now let them display p values instead of fgf values. You can give the name of the attribute as a string to the initialize_axis_cell_data function, so something like clock.p_values[-1] instead of fgf might already work depending on your exact implementation of the clock.\nOnce you’re done, check if your model behaves as it should with the teacher/assistant or the file clockplusfgf.py directly.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  }
]