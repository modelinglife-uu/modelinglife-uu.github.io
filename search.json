[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Modeling Life",
    "section": "",
    "text": "Modeling life\nWelcome to the course Modeling Life.",
    "crumbs": [
      "Course information",
      "Modeling life"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Quarto examples",
    "section": "",
    "text": "1.1 Equations\nHere’s an equation:\n\\[\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = rN(1 - \\frac{N}{K})\n\\tag{1.1}\\]\nAnd Equation A.1 is a reference to the equation above.",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Quarto examples</span>"
    ]
  },
  {
    "objectID": "intro.html#references",
    "href": "intro.html#references",
    "title": "1  Quarto examples",
    "section": "1.2 References",
    "text": "1.2 References\nSee Knuth (1984) for additional discussion of literate programming.",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Quarto examples</span>"
    ]
  },
  {
    "objectID": "intro.html#syntax-highlighting",
    "href": "intro.html#syntax-highlighting",
    "title": "1  Quarto examples",
    "section": "1.3 Syntax highlighting",
    "text": "1.3 Syntax highlighting\nHere’s some python code:\nimport numpy as np\nnp.random.seed(42)\na = 1 + 2\nb = a + 3\nprint(\"Hello\")",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Quarto examples</span>"
    ]
  },
  {
    "objectID": "intro.html#visualising-data-r",
    "href": "intro.html#visualising-data-r",
    "title": "1  Quarto examples",
    "section": "1.4 Visualising data (R)",
    "text": "1.4 Visualising data (R)\nHere’s an interactive plot generated with R:",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Quarto examples</span>"
    ]
  },
  {
    "objectID": "intro.html#a-youtube-clip",
    "href": "intro.html#a-youtube-clip",
    "title": "1  Quarto examples",
    "section": "1.5 A youtube clip:",
    "text": "1.5 A youtube clip:",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Quarto examples</span>"
    ]
  },
  {
    "objectID": "intro.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "href": "intro.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "title": "1  Quarto examples",
    "section": "1.6 An ‘iframe’ to a different page (e.g. my simulations)",
    "text": "1.6 An ‘iframe’ to a different page (e.g. my simulations)\n\n\nMermaid\nDiagrams (Mermaid syntax):\n\n\n\n\n\n\nflowchart TB\nA(Models) --&gt; C(\"Analytical (mathematical)\")\nA --&gt; B(\"Numerical (computational)\")\nB --&gt; F(Individual-based model)\nB --&gt; G(Cellular automaton)\nC --&gt; E(Differential equation)\nC --&gt; D(MAPs)\n\n\n\n\nFigure 1.1: Types of models\n\n\n\n\n\nWhich can be referred to Figure A.1.\n\n\nCallouts\nCall-outs can organise information and highlight important points.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nTip 1.1: Cross-Referencing a Tip\n\n\n\nAdd an ID starting with #tip- to reference a tip.\n\n\nSee Tip A.1…\n\n\nHow to format questions/problem sets\n\nExercise 1.1 (Test 1) The equation of any straight line, called a linear equation, can be written as:\n\\[\ny = mx + b\n\\tag{1.2}\\]\nRefer to the equation like this Equation A.2 or like Customlabel A.2.\na. Blabla?\nb. Of blablabla?\n\n\n\nSharing data tables:\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Quarto examples</span>"
    ]
  },
  {
    "objectID": "general.html",
    "href": "general.html",
    "title": "2  General course info",
    "section": "",
    "text": "Our names, email addresses, an overview of the course content, learning goals, tips, grading, group formation, usage of Brightspace, materials they need, required attendencee, and feedback is welcome blabla.",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>General course info</span>"
    ]
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "3  Schedule",
    "section": "",
    "text": "The schedule of the course and important deadlines are outlined below. The course is divided into blabla modules, each with its own set of topics and blabla. The schedule is subject to change, and any updates will be communicated in advance. Blabla.\n(paste below is the schedule of Kwanti/BioMS as an example)",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Schedule</span>"
    ]
  },
  {
    "objectID": "pattern_intro_text.html",
    "href": "pattern_intro_text.html",
    "title": "4  Pattern formation",
    "section": "",
    "text": "4.1 Equations\nHere’s an equation:\n\\[\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = rN(1 - \\frac{N}{K})\n\\tag{4.1}\\]\nAnd Equation A.1 is a reference to the equation above.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pattern formation</span>"
    ]
  },
  {
    "objectID": "pattern_intro_text.html#references",
    "href": "pattern_intro_text.html#references",
    "title": "4  Pattern formation",
    "section": "4.2 References",
    "text": "4.2 References\nSee Knuth (1984) for additional discussion of literate programming.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pattern formation</span>"
    ]
  },
  {
    "objectID": "pattern_intro_text.html#syntax-highlighting",
    "href": "pattern_intro_text.html#syntax-highlighting",
    "title": "4  Pattern formation",
    "section": "4.3 Syntax highlighting",
    "text": "4.3 Syntax highlighting\nHere’s some python code:\nimport numpy as np\nnp.random.seed(42)\na = 1 + 2\nb = a + 3\nprint(\"Hello\")",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pattern formation</span>"
    ]
  },
  {
    "objectID": "pattern_intro_text.html#visualising-data-r",
    "href": "pattern_intro_text.html#visualising-data-r",
    "title": "4  Pattern formation",
    "section": "4.4 Visualising data (R)",
    "text": "4.4 Visualising data (R)\nHere’s an interactive plot generated with R:",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pattern formation</span>"
    ]
  },
  {
    "objectID": "pattern_intro_text.html#a-youtube-clip",
    "href": "pattern_intro_text.html#a-youtube-clip",
    "title": "4  Pattern formation",
    "section": "4.5 A youtube clip:",
    "text": "4.5 A youtube clip:",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pattern formation</span>"
    ]
  },
  {
    "objectID": "pattern_intro_text.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "href": "pattern_intro_text.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "title": "4  Pattern formation",
    "section": "4.6 An ‘iframe’ to a different page (e.g. my simulations)",
    "text": "4.6 An ‘iframe’ to a different page (e.g. my simulations)\n\n\nMermaid\nDiagrams (Mermaid syntax):\n\n\n\n\n\n\nflowchart TB\nA(Models) --&gt; C(\"Analytical (mathematical)\")\nA --&gt; B(\"Numerical (computational)\")\nB --&gt; F(Individual-based model)\nB --&gt; G(Cellular automaton)\nC --&gt; E(Differential equation)\nC --&gt; D(MAPs)\n\n\n\n\nFigure 4.1: Types of models\n\n\n\n\n\nWhich can be referred to Figure A.1.\n\n\nCallouts\nCall-outs can organise information and highlight important points.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nTip 4.1: Cross-Referencing a Tip\n\n\n\nAdd an ID starting with #tip- to reference a tip.\n\n\nSee Tip A.1…\n\n\nHow to format questions/problem sets\n\nExercise 4.1 (Test 1) The equation of any straight line, called a linear equation, can be written as:\n\\[\ny = mx + b\n\\tag{4.2}\\]\nRefer to the equation like this Equation A.2 or like Customlabel A.2.\na. Blabla?\nb. Of blablabla?\n\n\n\nSharing data tables:\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pattern formation</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html",
    "href": "pattern_practical_1.html",
    "title": "5  Practical 1",
    "section": "",
    "text": "5.1 Equations\nHere’s an equation:\n\\[\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = rN(1 - \\frac{N}{K})\n\\tag{5.1}\\]\nAnd Equation A.1 is a reference to the equation above.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#references",
    "href": "pattern_practical_1.html#references",
    "title": "5  Practical 1",
    "section": "5.2 References",
    "text": "5.2 References\nSee Knuth (1984) for additional discussion of literate programming.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#syntax-highlighting",
    "href": "pattern_practical_1.html#syntax-highlighting",
    "title": "5  Practical 1",
    "section": "5.3 Syntax highlighting",
    "text": "5.3 Syntax highlighting\nHere’s some python code:\nimport numpy as np\nnp.random.seed(42)\na = 1 + 2\nb = a + 3\nprint(\"Hello\")",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#visualising-data-r",
    "href": "pattern_practical_1.html#visualising-data-r",
    "title": "5  Practical 1",
    "section": "5.4 Visualising data (R)",
    "text": "5.4 Visualising data (R)\nHere’s an interactive plot generated with R:",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#a-youtube-clip",
    "href": "pattern_practical_1.html#a-youtube-clip",
    "title": "5  Practical 1",
    "section": "5.5 A youtube clip:",
    "text": "5.5 A youtube clip:",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "href": "pattern_practical_1.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "title": "5  Practical 1",
    "section": "5.6 An ‘iframe’ to a different page (e.g. my simulations)",
    "text": "5.6 An ‘iframe’ to a different page (e.g. my simulations)\n\n\nMermaid\nDiagrams (Mermaid syntax):\n\n\n\n\n\n\nflowchart TB\nA(Models) --&gt; C(\"Analytical (mathematical)\")\nA --&gt; B(\"Numerical (computational)\")\nB --&gt; F(Individual-based model)\nB --&gt; G(Cellular automaton)\nC --&gt; E(Differential equation)\nC --&gt; D(MAPs)\n\n\n\n\nFigure 5.1: Types of models\n\n\n\n\n\nWhich can be referred to Figure A.1.\n\n\nCallouts\nCall-outs can organise information and highlight important points.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nTip 5.1: Cross-Referencing a Tip\n\n\n\nAdd an ID starting with #tip- to reference a tip.\n\n\nSee Tip A.1…\n\n\nHow to format questions/problem sets\n\nExercise 5.1 (Test 1) The equation of any straight line, called a linear equation, can be written as:\n\\[\ny = mx + b\n\\tag{5.2}\\]\nRefer to the equation like this Equation A.2 or like Customlabel A.2.\na. Blabla?\nb. Of blablabla?\n\n\n\nSharing data tables:\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html",
    "href": "pattern_practical_2.html",
    "title": "6  Practical 2",
    "section": "",
    "text": "6.1 Equations\nHere’s an equation:\n\\[\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = rN(1 - \\frac{N}{K})\n\\tag{6.1}\\]\nAnd Equation A.1 is a reference to the equation above.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#references",
    "href": "pattern_practical_2.html#references",
    "title": "6  Practical 2",
    "section": "6.2 References",
    "text": "6.2 References\nSee Knuth (1984) for additional discussion of literate programming.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#syntax-highlighting",
    "href": "pattern_practical_2.html#syntax-highlighting",
    "title": "6  Practical 2",
    "section": "6.3 Syntax highlighting",
    "text": "6.3 Syntax highlighting\nHere’s some python code:\nimport numpy as np\nnp.random.seed(42)\na = 1 + 2\nb = a + 3\nprint(\"Hello\")",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#visualising-data-r",
    "href": "pattern_practical_2.html#visualising-data-r",
    "title": "6  Practical 2",
    "section": "6.4 Visualising data (R)",
    "text": "6.4 Visualising data (R)\nHere’s an interactive plot generated with R:",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#a-youtube-clip",
    "href": "pattern_practical_2.html#a-youtube-clip",
    "title": "6  Practical 2",
    "section": "6.5 A youtube clip:",
    "text": "6.5 A youtube clip:",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "href": "pattern_practical_2.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "title": "6  Practical 2",
    "section": "6.6 An ‘iframe’ to a different page (e.g. my simulations)",
    "text": "6.6 An ‘iframe’ to a different page (e.g. my simulations)\n\n\nMermaid\nDiagrams (Mermaid syntax):\n\n\n\n\n\n\nflowchart TB\nA(Models) --&gt; C(\"Analytical (mathematical)\")\nA --&gt; B(\"Numerical (computational)\")\nB --&gt; F(Individual-based model)\nB --&gt; G(Cellular automaton)\nC --&gt; E(Differential equation)\nC --&gt; D(MAPs)\n\n\n\n\nFigure 6.1: Types of models\n\n\n\n\n\nWhich can be referred to Figure A.1.\n\n\nCallouts\nCall-outs can organise information and highlight important points.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nTip 6.1: Cross-Referencing a Tip\n\n\n\nAdd an ID starting with #tip- to reference a tip.\n\n\nSee Tip A.1…\n\n\nHow to format questions/problem sets\n\nExercise 6.1 (Test 1) The equation of any straight line, called a linear equation, can be written as:\n\\[\ny = mx + b\n\\tag{6.2}\\]\nRefer to the equation like this Equation A.2 or like Customlabel A.2.\na. Blabla?\nb. Of blablabla?\n\n\n\nSharing data tables:\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html",
    "href": "pattern_practical_3.html",
    "title": "7  Practical 3",
    "section": "",
    "text": "7.1 Equations\nHere’s an equation:\n\\[\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = rN(1 - \\frac{N}{K})\n\\tag{7.1}\\]\nAnd Equation A.1 is a reference to the equation above.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#references",
    "href": "pattern_practical_3.html#references",
    "title": "7  Practical 3",
    "section": "7.2 References",
    "text": "7.2 References\nSee Knuth (1984) for additional discussion of literate programming.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#syntax-highlighting",
    "href": "pattern_practical_3.html#syntax-highlighting",
    "title": "7  Practical 3",
    "section": "7.3 Syntax highlighting",
    "text": "7.3 Syntax highlighting\nHere’s some python code:\nimport numpy as np\nnp.random.seed(42)\na = 1 + 2\nb = a + 3\nprint(\"Hello\")",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#visualising-data-r",
    "href": "pattern_practical_3.html#visualising-data-r",
    "title": "7  Practical 3",
    "section": "7.4 Visualising data (R)",
    "text": "7.4 Visualising data (R)\nHere’s an interactive plot generated with R:",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#a-youtube-clip",
    "href": "pattern_practical_3.html#a-youtube-clip",
    "title": "7  Practical 3",
    "section": "7.5 A youtube clip:",
    "text": "7.5 A youtube clip:",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "href": "pattern_practical_3.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "title": "7  Practical 3",
    "section": "7.6 An ‘iframe’ to a different page (e.g. my simulations)",
    "text": "7.6 An ‘iframe’ to a different page (e.g. my simulations)\n\n\nMermaid\nDiagrams (Mermaid syntax):\n\n\n\n\n\n\nflowchart TB\nA(Models) --&gt; C(\"Analytical (mathematical)\")\nA --&gt; B(\"Numerical (computational)\")\nB --&gt; F(Individual-based model)\nB --&gt; G(Cellular automaton)\nC --&gt; E(Differential equation)\nC --&gt; D(MAPs)\n\n\n\n\nFigure 7.1: Types of models\n\n\n\n\n\nWhich can be referred to Figure A.1.\n\n\nCallouts\nCall-outs can organise information and highlight important points.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nTip 7.1: Cross-Referencing a Tip\n\n\n\nAdd an ID starting with #tip- to reference a tip.\n\n\nSee Tip A.1…\n\n\nHow to format questions/problem sets\n\nExercise 7.1 (Test 1) The equation of any straight line, called a linear equation, can be written as:\n\\[\ny = mx + b\n\\tag{7.2}\\]\nRefer to the equation like this Equation A.2 or like Customlabel A.2.\na. Blabla?\nb. Of blablabla?\n\n\n\nSharing data tables:\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "morpho_intro_text.html",
    "href": "morpho_intro_text.html",
    "title": "8  What is morphogenesis?",
    "section": "",
    "text": "8.1 Equations\nHere’s an equation:\n\\[\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = rN(1 - \\frac{N}{K})\n\\tag{8.1}\\]\nAnd Equation A.1 is a reference to the equation above.",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>What is morphogenesis?</span>"
    ]
  },
  {
    "objectID": "morpho_intro_text.html#references",
    "href": "morpho_intro_text.html#references",
    "title": "8  What is morphogenesis?",
    "section": "8.2 References",
    "text": "8.2 References\nSee Knuth (1984) for additional discussion of literate programming.",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>What is morphogenesis?</span>"
    ]
  },
  {
    "objectID": "morpho_intro_text.html#syntax-highlighting",
    "href": "morpho_intro_text.html#syntax-highlighting",
    "title": "8  What is morphogenesis?",
    "section": "8.3 Syntax highlighting",
    "text": "8.3 Syntax highlighting\nHere’s some python code:\nimport numpy as np\nnp.random.seed(42)\na = 1 + 2\nb = a + 3\nprint(\"Hello\")",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>What is morphogenesis?</span>"
    ]
  },
  {
    "objectID": "morpho_intro_text.html#visualising-data-r",
    "href": "morpho_intro_text.html#visualising-data-r",
    "title": "8  What is morphogenesis?",
    "section": "8.4 Visualising data (R)",
    "text": "8.4 Visualising data (R)\nHere’s an interactive plot generated with R:",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>What is morphogenesis?</span>"
    ]
  },
  {
    "objectID": "morpho_intro_text.html#a-youtube-clip",
    "href": "morpho_intro_text.html#a-youtube-clip",
    "title": "8  What is morphogenesis?",
    "section": "8.5 A youtube clip:",
    "text": "8.5 A youtube clip:",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>What is morphogenesis?</span>"
    ]
  },
  {
    "objectID": "morpho_intro_text.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "href": "morpho_intro_text.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "title": "8  What is morphogenesis?",
    "section": "8.6 An ‘iframe’ to a different page (e.g. my simulations)",
    "text": "8.6 An ‘iframe’ to a different page (e.g. my simulations)\n\n\nMermaid\nDiagrams (Mermaid syntax):\n\n\n\n\n\n\nflowchart TB\nA(Models) --&gt; C(\"Analytical (mathematical)\")\nA --&gt; B(\"Numerical (computational)\")\nB --&gt; F(Individual-based model)\nB --&gt; G(Cellular automaton)\nC --&gt; E(Differential equation)\nC --&gt; D(MAPs)\n\n\n\n\nFigure 8.1: Types of models\n\n\n\n\n\nWhich can be referred to Figure A.1.\n\n\nCallouts\nCall-outs can organise information and highlight important points.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nTip 8.1: Cross-Referencing a Tip\n\n\n\nAdd an ID starting with #tip- to reference a tip.\n\n\nSee Tip A.1…\n\n\nHow to format questions/problem sets\n\nExercise 8.1 (Test 1) The equation of any straight line, called a linear equation, can be written as:\n\\[\ny = mx + b\n\\tag{8.2}\\]\nRefer to the equation like this Equation A.2 or like Customlabel A.2.\na. Blabla?\nb. Of blablabla?\n\n\n\nSharing data tables:\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>What is morphogenesis?</span>"
    ]
  },
  {
    "objectID": "morpho_practical_1.html",
    "href": "morpho_practical_1.html",
    "title": "9  Practical 1",
    "section": "",
    "text": "9.1 Equations\nHere’s an equation:\n\\[\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = rN(1 - \\frac{N}{K})\n\\tag{9.1}\\]\nAnd Equation A.1 is a reference to the equation above.",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "morpho_practical_1.html#references",
    "href": "morpho_practical_1.html#references",
    "title": "9  Practical 1",
    "section": "9.2 References",
    "text": "9.2 References\nSee Knuth (1984) for additional discussion of literate programming.",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "morpho_practical_1.html#syntax-highlighting",
    "href": "morpho_practical_1.html#syntax-highlighting",
    "title": "9  Practical 1",
    "section": "9.3 Syntax highlighting",
    "text": "9.3 Syntax highlighting\nHere’s some python code:\nimport numpy as np\nnp.random.seed(42)\na = 1 + 2\nb = a + 3\nprint(\"Hello\")",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "morpho_practical_1.html#visualising-data-r",
    "href": "morpho_practical_1.html#visualising-data-r",
    "title": "9  Practical 1",
    "section": "9.4 Visualising data (R)",
    "text": "9.4 Visualising data (R)\nHere’s an interactive plot generated with R:",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "morpho_practical_1.html#a-youtube-clip",
    "href": "morpho_practical_1.html#a-youtube-clip",
    "title": "9  Practical 1",
    "section": "9.5 A youtube clip:",
    "text": "9.5 A youtube clip:",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "morpho_practical_1.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "href": "morpho_practical_1.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "title": "9  Practical 1",
    "section": "9.6 An ‘iframe’ to a different page (e.g. my simulations)",
    "text": "9.6 An ‘iframe’ to a different page (e.g. my simulations)\n\n\nMermaid\nDiagrams (Mermaid syntax):\n\n\n\n\n\n\nflowchart TB\nA(Models) --&gt; C(\"Analytical (mathematical)\")\nA --&gt; B(\"Numerical (computational)\")\nB --&gt; F(Individual-based model)\nB --&gt; G(Cellular automaton)\nC --&gt; E(Differential equation)\nC --&gt; D(MAPs)\n\n\n\n\nFigure 9.1: Types of models\n\n\n\n\n\nWhich can be referred to Figure A.1.\n\n\nCallouts\nCall-outs can organise information and highlight important points.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nTip 9.1: Cross-Referencing a Tip\n\n\n\nAdd an ID starting with #tip- to reference a tip.\n\n\nSee Tip A.1…\n\n\nHow to format questions/problem sets\n\nExercise 9.1 (Test 1) The equation of any straight line, called a linear equation, can be written as:\n\\[\ny = mx + b\n\\tag{9.2}\\]\nRefer to the equation like this Equation A.2 or like Customlabel A.2.\na. Blabla?\nb. Of blablabla?\n\n\n\nSharing data tables:\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "morpho_practical_2.html",
    "href": "morpho_practical_2.html",
    "title": "10  Practical 2",
    "section": "",
    "text": "10.1 Equations\nHere’s an equation:\n\\[\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = rN(1 - \\frac{N}{K})\n\\tag{10.1}\\]\nAnd Equation A.1 is a reference to the equation above.",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "morpho_practical_2.html#references",
    "href": "morpho_practical_2.html#references",
    "title": "10  Practical 2",
    "section": "10.2 References",
    "text": "10.2 References\nSee Knuth (1984) for additional discussion of literate programming.",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "morpho_practical_2.html#syntax-highlighting",
    "href": "morpho_practical_2.html#syntax-highlighting",
    "title": "10  Practical 2",
    "section": "10.3 Syntax highlighting",
    "text": "10.3 Syntax highlighting\nHere’s some python code:\nimport numpy as np\nnp.random.seed(42)\na = 1 + 2\nb = a + 3\nprint(\"Hello\")",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "morpho_practical_2.html#visualising-data-r",
    "href": "morpho_practical_2.html#visualising-data-r",
    "title": "10  Practical 2",
    "section": "10.4 Visualising data (R)",
    "text": "10.4 Visualising data (R)\nHere’s an interactive plot generated with R:",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "morpho_practical_2.html#a-youtube-clip",
    "href": "morpho_practical_2.html#a-youtube-clip",
    "title": "10  Practical 2",
    "section": "10.5 A youtube clip:",
    "text": "10.5 A youtube clip:",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "morpho_practical_2.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "href": "morpho_practical_2.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "title": "10  Practical 2",
    "section": "10.6 An ‘iframe’ to a different page (e.g. my simulations)",
    "text": "10.6 An ‘iframe’ to a different page (e.g. my simulations)\n\n\nMermaid\nDiagrams (Mermaid syntax):\n\n\n\n\n\n\nflowchart TB\nA(Models) --&gt; C(\"Analytical (mathematical)\")\nA --&gt; B(\"Numerical (computational)\")\nB --&gt; F(Individual-based model)\nB --&gt; G(Cellular automaton)\nC --&gt; E(Differential equation)\nC --&gt; D(MAPs)\n\n\n\n\nFigure 10.1: Types of models\n\n\n\n\n\nWhich can be referred to Figure A.1.\n\n\nCallouts\nCall-outs can organise information and highlight important points.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nTip 10.1: Cross-Referencing a Tip\n\n\n\nAdd an ID starting with #tip- to reference a tip.\n\n\nSee Tip A.1…\n\n\nHow to format questions/problem sets\n\nExercise 10.1 (Test 1) The equation of any straight line, called a linear equation, can be written as:\n\\[\ny = mx + b\n\\tag{10.2}\\]\nRefer to the equation like this Equation A.2 or like Customlabel A.2.\na. Blabla?\nb. Of blablabla?\n\n\n\nSharing data tables:\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "II) Morphogenesis",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "differentiation_intro_text.html",
    "href": "differentiation_intro_text.html",
    "title": "11  Differentiation introduction",
    "section": "",
    "text": "11.1 Equations\nHere’s an equation:\n\\[\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = rN(1 - \\frac{N}{K})\n\\tag{11.1}\\]\nAnd Equation A.1 is a reference to the equation above.",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Differentiation introduction</span>"
    ]
  },
  {
    "objectID": "differentiation_intro_text.html#references",
    "href": "differentiation_intro_text.html#references",
    "title": "11  Differentiation introduction",
    "section": "11.2 References",
    "text": "11.2 References\nSee Knuth (1984) for additional discussion of literate programming.",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Differentiation introduction</span>"
    ]
  },
  {
    "objectID": "differentiation_intro_text.html#syntax-highlighting",
    "href": "differentiation_intro_text.html#syntax-highlighting",
    "title": "11  Differentiation introduction",
    "section": "11.3 Syntax highlighting",
    "text": "11.3 Syntax highlighting\nHere’s some python code:\nimport numpy as np\nnp.random.seed(42)\na = 1 + 2\nb = a + 3\nprint(\"Hello\")",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Differentiation introduction</span>"
    ]
  },
  {
    "objectID": "differentiation_intro_text.html#visualising-data-r",
    "href": "differentiation_intro_text.html#visualising-data-r",
    "title": "11  Differentiation introduction",
    "section": "11.4 Visualising data (R)",
    "text": "11.4 Visualising data (R)\nHere’s an interactive plot generated with R:",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Differentiation introduction</span>"
    ]
  },
  {
    "objectID": "differentiation_intro_text.html#a-youtube-clip",
    "href": "differentiation_intro_text.html#a-youtube-clip",
    "title": "11  Differentiation introduction",
    "section": "11.5 A youtube clip:",
    "text": "11.5 A youtube clip:",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Differentiation introduction</span>"
    ]
  },
  {
    "objectID": "differentiation_intro_text.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "href": "differentiation_intro_text.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "title": "11  Differentiation introduction",
    "section": "11.6 An ‘iframe’ to a different page (e.g. my simulations)",
    "text": "11.6 An ‘iframe’ to a different page (e.g. my simulations)\n\n\nMermaid\nDiagrams (Mermaid syntax):\n\n\n\n\n\n\nflowchart TB\nA(Models) --&gt; C(\"Analytical (mathematical)\")\nA --&gt; B(\"Numerical (computational)\")\nB --&gt; F(Individual-based model)\nB --&gt; G(Cellular automaton)\nC --&gt; E(Differential equation)\nC --&gt; D(MAPs)\n\n\n\n\nFigure 11.1: Types of models\n\n\n\n\n\nWhich can be referred to Figure A.1.\n\n\nCallouts\nCall-outs can organise information and highlight important points.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nTip 11.1: Cross-Referencing a Tip\n\n\n\nAdd an ID starting with #tip- to reference a tip.\n\n\nSee Tip A.1…\n\n\nHow to format questions/problem sets\n\nExercise 11.1 (Test 1) The equation of any straight line, called a linear equation, can be written as:\n\\[\ny = mx + b\n\\tag{11.2}\\]\nRefer to the equation like this Equation A.2 or like Customlabel A.2.\na. Blabla?\nb. Of blablabla?\n\n\n\nSharing data tables:\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Differentiation introduction</span>"
    ]
  },
  {
    "objectID": "differentiation_practical_1.html",
    "href": "differentiation_practical_1.html",
    "title": "12  Practical 1",
    "section": "",
    "text": "12.1 Equations\nHere’s an equation:\n\\[\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = rN(1 - \\frac{N}{K})\n\\tag{12.1}\\]\nAnd Equation A.1 is a reference to the equation above.",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "differentiation_practical_1.html#references",
    "href": "differentiation_practical_1.html#references",
    "title": "12  Practical 1",
    "section": "12.2 References",
    "text": "12.2 References\nSee Knuth (1984) for additional discussion of literate programming.",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "differentiation_practical_1.html#syntax-highlighting",
    "href": "differentiation_practical_1.html#syntax-highlighting",
    "title": "12  Practical 1",
    "section": "12.3 Syntax highlighting",
    "text": "12.3 Syntax highlighting\nHere’s some python code:\nimport numpy as np\nnp.random.seed(42)\na = 1 + 2\nb = a + 3\nprint(\"Hello\")",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "differentiation_practical_1.html#visualising-data-r",
    "href": "differentiation_practical_1.html#visualising-data-r",
    "title": "12  Practical 1",
    "section": "12.4 Visualising data (R)",
    "text": "12.4 Visualising data (R)\nHere’s an interactive plot generated with R:",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "differentiation_practical_1.html#a-youtube-clip",
    "href": "differentiation_practical_1.html#a-youtube-clip",
    "title": "12  Practical 1",
    "section": "12.5 A youtube clip:",
    "text": "12.5 A youtube clip:",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "differentiation_practical_1.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "href": "differentiation_practical_1.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "title": "12  Practical 1",
    "section": "12.6 An ‘iframe’ to a different page (e.g. my simulations)",
    "text": "12.6 An ‘iframe’ to a different page (e.g. my simulations)\n\n\nMermaid\nDiagrams (Mermaid syntax):\n\n\n\n\n\n\nflowchart TB\nA(Models) --&gt; C(\"Analytical (mathematical)\")\nA --&gt; B(\"Numerical (computational)\")\nB --&gt; F(Individual-based model)\nB --&gt; G(Cellular automaton)\nC --&gt; E(Differential equation)\nC --&gt; D(MAPs)\n\n\n\n\nFigure 12.1: Types of models\n\n\n\n\n\nWhich can be referred to Figure A.1.\n\n\nCallouts\nCall-outs can organise information and highlight important points.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nTip 12.1: Cross-Referencing a Tip\n\n\n\nAdd an ID starting with #tip- to reference a tip.\n\n\nSee Tip A.1…\n\n\nHow to format questions/problem sets\n\nExercise 12.1 (Test 1) The equation of any straight line, called a linear equation, can be written as:\n\\[\ny = mx + b\n\\tag{12.2}\\]\nRefer to the equation like this Equation A.2 or like Customlabel A.2.\na. Blabla?\nb. Of blablabla?\n\n\n\nSharing data tables:\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "differentiation_practical_2.html",
    "href": "differentiation_practical_2.html",
    "title": "13  Practical 2",
    "section": "",
    "text": "13.1 Equations\nHere’s an equation:\n\\[\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = rN(1 - \\frac{N}{K})\n\\tag{13.1}\\]\nAnd Equation A.1 is a reference to the equation above.",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "differentiation_practical_2.html#references",
    "href": "differentiation_practical_2.html#references",
    "title": "13  Practical 2",
    "section": "13.2 References",
    "text": "13.2 References\nSee Knuth (1984) for additional discussion of literate programming.",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "differentiation_practical_2.html#syntax-highlighting",
    "href": "differentiation_practical_2.html#syntax-highlighting",
    "title": "13  Practical 2",
    "section": "13.3 Syntax highlighting",
    "text": "13.3 Syntax highlighting\nHere’s some python code:\nimport numpy as np\nnp.random.seed(42)\na = 1 + 2\nb = a + 3\nprint(\"Hello\")",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "differentiation_practical_2.html#visualising-data-r",
    "href": "differentiation_practical_2.html#visualising-data-r",
    "title": "13  Practical 2",
    "section": "13.4 Visualising data (R)",
    "text": "13.4 Visualising data (R)\nHere’s an interactive plot generated with R:",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "differentiation_practical_2.html#a-youtube-clip",
    "href": "differentiation_practical_2.html#a-youtube-clip",
    "title": "13  Practical 2",
    "section": "13.5 A youtube clip:",
    "text": "13.5 A youtube clip:",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "differentiation_practical_2.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "href": "differentiation_practical_2.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "title": "13  Practical 2",
    "section": "13.6 An ‘iframe’ to a different page (e.g. my simulations)",
    "text": "13.6 An ‘iframe’ to a different page (e.g. my simulations)\n\n\nMermaid\nDiagrams (Mermaid syntax):\n\n\n\n\n\n\nflowchart TB\nA(Models) --&gt; C(\"Analytical (mathematical)\")\nA --&gt; B(\"Numerical (computational)\")\nB --&gt; F(Individual-based model)\nB --&gt; G(Cellular automaton)\nC --&gt; E(Differential equation)\nC --&gt; D(MAPs)\n\n\n\n\nFigure 13.1: Types of models\n\n\n\n\n\nWhich can be referred to Figure A.1.\n\n\nCallouts\nCall-outs can organise information and highlight important points.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nTip 13.1: Cross-Referencing a Tip\n\n\n\nAdd an ID starting with #tip- to reference a tip.\n\n\nSee Tip A.1…\n\n\nHow to format questions/problem sets\n\nExercise 13.1 (Test 1) The equation of any straight line, called a linear equation, can be written as:\n\\[\ny = mx + b\n\\tag{13.2}\\]\nRefer to the equation like this Equation A.2 or like Customlabel A.2.\na. Blabla?\nb. Of blablabla?\n\n\n\nSharing data tables:\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "III) Cell differentiation",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "evo_intro_text.html",
    "href": "evo_intro_text.html",
    "title": "14  Introduction to evolution",
    "section": "",
    "text": "14.1 Evolution: Life’s most clever algorithm\nEvolution is the process by which populations change over generations through variation, inheritance, and differential survival. This idea, famously championed by Darwin and Wallace, explains the diversity of life on Earth. It describes how species adapt to their environments, how new species arise, and how complex traits evolve. Today, the concept of evolution has expanded beyond biology, it’s recognised as a powerful algorithm that drives adaptation in systems ranging from bacteria (genes) to ideas (memes), from DNA (nucleotides) to computer code (bits).\nIn this part of the course, we’ll bring these ingredients to life by writing our own simulations and watching evolution unfold on the screen. And while our digital creatures aren’t made of flesh and blood, the evolutionary battles they fight, the strategies they discover, and the adaptations they evolve are as real, and often as surprising, as anything found in nature itself.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introduction to evolution</span>"
    ]
  },
  {
    "objectID": "evo_intro_text.html#three-ingredients",
    "href": "evo_intro_text.html#three-ingredients",
    "title": "14  Introduction to evolution",
    "section": "14.2 Three ingredients",
    "text": "14.2 Three ingredients\nAs briefly mentioned above, we just need three ingredients to have evolution by means of natural selection:\n\nvariation (differences between individuals),\ninheritance (the passing on of traits),\nselection (some variants performing better than others).\n\nThe last ingredient is self-evident. Evolution by means of natural selection requires selection. It is especially the first two that are a little more tricky to really understand, as they are not always as obvious as they seem.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introduction to evolution</span>"
    ]
  },
  {
    "objectID": "evo_intro_text.html#balancing-change-and-stability",
    "href": "evo_intro_text.html#balancing-change-and-stability",
    "title": "14  Introduction to evolution",
    "section": "14.3 Balancing change and stability",
    "text": "14.3 Balancing change and stability\nTo evolve, a system needs enough variation – if everyone is the same, there’s nothing for selection to act on. But this variation can’t just be noise; it needs to be passed on. That means inheritance can’t be perfect – there must be room for change, such as through mutations – but it also can’t be too sloppy. If traits aren’t reliably transmitted to the next generation, then even the best adaptations will vanish before they can take hold. Evolution lives in the sweet spot: not too rigid, not too chaotic, just enough memory and just enough change. To make this a little more tangible, let us make our very first simulation.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introduction to evolution</span>"
    ]
  },
  {
    "objectID": "evo_intro_text.html#a-simple-evolutionary-algorithm",
    "href": "evo_intro_text.html#a-simple-evolutionary-algorithm",
    "title": "14  Introduction to evolution",
    "section": "14.4 A simple evolutionary algorithm",
    "text": "14.4 A simple evolutionary algorithm\nOne simple way to simulate evolution is with a Moran process, a classic model from population genetics. Imagine a population of 100 individuals, each with a single gene that determines its fitness. This gene can have all values from 0 to 1 (let’s call this value \\(\\phi\\)). At each time step, one individual is chosen to reproduce with a probability proportional to \\(\\phi\\), producing 1 offspring. This offspring inherits their parents gene (so the same \\(\\phi\\)), but with a probability \\(\\mu\\), the value changes by a small amount (a mutation). The population size will now be 101, which could be interesting if we want to study population growth. However, in a Moran process we keep it simple: one random individual is removed by the new offspring, so the population size is constant while still allowing fitter individuals to spread over time.\nHere’s a minimal Python example:\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(5)\n\nN = 100 # Population size \nfitnesses = np.full(N, 0.05)\nmu = 0.01\n# Updated parameters\nsteps = 50000\navg_fitness = []\n\n# Moran process with mutation (logging every 10 steps)\nfor step in range(steps):\n    probs = fitnesses / fitnesses.sum()\n    parent = np.random.choice(N, p=probs)\n    dead = np.random.choice(N)\n\n    # Copy with mutation\n    new_fit = fitnesses[parent]\n    if np.random.rand() &lt; mu:\n        new_fit = np.clip(new_fit + np.random.normal(0, 0.05), 0, 1)\n            \n    fitnesses[dead] = new_fit\n\n    # Save average fitness every 10 steps\n    if step % 10 == 0:\n        avg_fitness.append(fitnesses.mean())\n\n# Plotting\nplt.plot(np.arange(0, steps, 10), avg_fitness)\nplt.xlabel(\"Step\")\nplt.ylabel(\"Average fitness\")\nplt.title(\"Evolution of Fitness in a Moran Process\")\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\nExercise 14.1 (Moran process simulation) \nStudy the Python code for the evolutionary algorithm given above. Answer the following questions:\n\nHow “well adapted” is the initial population?\nHow are mutations implemented in the code? Can you think of other ways?\nCan the parent be replaced by its own offspring? Why/why not?\nInvestigate which value of \\(\\mu\\) works best if you want to achieve maximum fitness in the shortest amount of steps.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introduction to evolution</span>"
    ]
  },
  {
    "objectID": "evo_intro_text.html#what-this-part-of-the-course-is-about",
    "href": "evo_intro_text.html#what-this-part-of-the-course-is-about",
    "title": "14  Introduction to evolution",
    "section": "14.5 What this part of the course is about",
    "text": "14.5 What this part of the course is about\nThe above simulation is fun, but not really… biologically relevant. While some simplifications are necessary to make models feasible, we will investigate a few evolutionary models that are somewhat more interesting. We will discuss how to model spatial structure and local competition, how genotypes (where mutations happen) get translated into phenotypes (where selection happens), and how the environment can change over time and lead to niche construction and interactions.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Introduction to evolution</span>"
    ]
  },
  {
    "objectID": "evo_practical_1.html",
    "href": "evo_practical_1.html",
    "title": "15  Practical 1",
    "section": "",
    "text": "15.1 Sticking together\nIn this practical, you will practice building your own model of collective behaviour, based on the one you saw at the end of the lecture:\nThe example above is a implemented in Javascript, a programming language that is widely used for web development. It is easy to share with others, interactive, and surprisingly fast. But, it’s not the most “professional” programming language. Plus, at this stage of the course there is no point in learning yet another programming language, as you are here to learn about modelling biology. So we will stick to Python.\nFirst, let’s discuss how we can let individuals walk around in space.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "evo_practical_1.html#steering",
    "href": "evo_practical_1.html#steering",
    "title": "15  Practical 1",
    "section": "15.2 Steering",
    "text": "15.2 Steering\nWe can represent a moving individual in space as a point with a position and a velocity. The position is represented by two coordinates, \\(x\\) and \\(y\\), and the velocity is represented by two components, \\(v_x\\) and \\(v_y\\). All movement that this individual can do, will be a matter of repeatedly updating its position based on their velocity:\n\n\n\n  \n  \n  Vector Visualisation\n  \n\n\n  \n\n  \n    ← \n    → \n    ↑ \n    ↓ \n    ⟲ \n    ⟳ \n  \n\n  \n\n\n\n\n To model such a vector in python, we can simply define a base point with an x- and y-coordinate, and a velocity vector with an x- and y-component. The position of the individual can then be updated by adding the velocity to the position. Combining that with a function that draws an arrow in Python, we get the following code:\n\n\n\n\n\n\nCODE FOR “moving vector in Python”\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Enable interactive mode for matplotlib\nplt.ion()\n\n# Setup figure and axis for plotting the arrow\nfig, ax = plt.subplots(figsize=(8, 4))\nax.set_xlim(0, 600)  # x-axis limits\nax.set_ylim(0, 250)  # y-axis limits\nax.set_aspect('equal')  # Keep aspect ratio square\nax.set_facecolor('#f0f0f0')  # Background color\nax.set_title(\"A moving vector with an arrowhead\")  # Title\n\n# Initial position and velocity\nx, y = 250.0, 180.0      # Position coordinates\nvx, vy = 5.0, 10.5        # Velocity components\n\n\ndef draw_arrow(x, y, vx, vy):\n    \"\"\"\n    Draws an arrow at position (x, y) with velocity (vx, vy).\n    \"\"\"\n    ax.clear()\n    ax.set_xlim(0, 600)\n    ax.set_ylim(0, 250)\n    ax.set_aspect('equal')\n    ax.set_facecolor('#f0f0f0')\n    ax.set_title(\"A moving vector with an arrowhead\")\n\n    # Normalize velocity for drawing the arrow\n    \n    dx = vx*5\n    dy = vy*5\n\n    # Arrow shaft\n    end_x = x + dx\n    end_y = y + dy\n\n    # Arrowhead calculation\n    angle = np.arctan2(dy, dx)\n    angle_offset = np.pi / 7\n    hx1_x = end_x - np.cos(angle - angle_offset)\n    hx1_y = end_y - np.sin(angle - angle_offset)\n    hx2_x = end_x - np.cos(angle + angle_offset)\n    hx2_y = end_y - np.sin(angle + angle_offset)\n\n    # Draw shaft\n    ax.quiver(x, y, dx, dy, angles='xy', scale_units='xy', scale=1, color='#007acc', width=0.005)\n    # Draw base point\n    ax.plot(x, y, 'o', color='#333')\n\n    # Labels\n    ax.text(x+10, y+10, f\"x = {x:.2f}\")\n    ax.text(x+10, y-5, f\"y = {y:.2f}\")\n    ax.text(end_x + 10, end_y - 20, f\"vₓ = {vx:.2f}\")\n    ax.text(end_x + 10, end_y, f\"vᵧ = {vy:.2f}\")\n\n    plt.draw()\n    plt.pause(0.03)\n\n# Animation loop: update position by velocity\nfor i in range(500):\n    x += vx*0.1  # Update x position\n    y += vy*0.1  # Update y position\n\n    # Wrap around edges\n    x %= 600\n    y %= 250\n    \n    draw_arrow(x, y, vx, vy)\n\nplt.ioff()\n\n\n\n\nExercise 15.1 (Playing with steering arrows) \nCopy-paste the code above, study it for a few minutes, and run it.\n\nWhat can you do to make the arrow accelerate?\n\nTo rotate a vector, we can use the following trigonometrical equations, where \\(\\theta\\) is the angle of rotation:\n\\[\n\\begin{aligned}\nx_{new} = x \\cdot cos(\\theta) - y \\cdot sin(\\theta) \\newline\ny_{new} = x \\cdot sin(\\theta) + y \\cdot cos(\\theta)\n\\end{aligned}\n\\]\n\nUse the equation above to rotate the velocity vector in the code by a small angle every timestep. What happens?\nModelling 1 individual is not very exciting. Think about what the code above would look like if you had more than 1 individual. Discuss this with other students and/or Bram.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "evo_practical_1.html#moving-cells",
    "href": "evo_practical_1.html#moving-cells",
    "title": "15  Practical 1",
    "section": "15.3 Moving “cells”",
    "text": "15.3 Moving “cells”\nIn this practical, you will practice with modelling individuals in space by modifying a Python code based on the foraging cells shown at the beginning. To accommodate for many cells, we will define a new Cell class, embedded in a Simulation class.1\nFirst, read the code yourself (you can ignore the Visualisation class), and see if you can get it running on your own laptop.\n\n\n\n\n\n\nSTARTING CODE FOR “moving cells”\n\n\n\n\n\n###\n# PRACTICAL 1 | \"Every cell for themselves?\"\n# This is the starting code. Follow the instructions in the practical to complete the code. \n# If you get stuck, you can look at the final code in `foraging_for_resources_final.py`, or ask\n# Bram. \n#\n# The structure of this code is as follows:\n# 1. Imports and parameters\n# 2. Simulation class\n# 3. Cell class\n# 4. Visualisation class (you do not need to change this)\n#\n###\n\n# 1. IMPORTS AND PARAMETERS\n# Libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.widgets import Slider\n\n# Parameters for simulation\nWORLD_SIZE = 200    # Width / height of the world (size of grid and possible coordinates for cells)\nMAX_VELOCITY = 0.3  # Maximum velocity magnitude\nMAX_FORCE = 0.3     # Maximum force magnitude\nRANDOM_MOVEMENT  = 0.01 # Random movement factor to add some noise to the cell's movement\n\n# Parameters for display\nDRAW_ARROW = True  # Draw the arrows showing the velocity direction of the cells\nINIT_CELLS = 20 # Initial number of cells in the simulation\nDISPLAY_INTERVAL = 1 # Frequency with which the plot is updated (e.g., every 10 timesteps can speed things up)\n\n# 1. MAIN LOOP (using functions and classes defined below)\ndef main():\n    \"\"\"Main function to set up and run the simulation.\"\"\"\n    # NOTE: The `Visualisation` class is responsible for managing the visualization \n    # of the simulation, including creating plots, updating them, and handling \n    # user interactions like the slider. As this has nothing to do with modeling\n    # per se, understanding this code is not necessary, but it can be fun to look\n    # at if you are interested. \n    \n    num_cells = INIT_CELLS\n    sim = Simulation(num_cells) \n\n    plt.ion()\n    vis = Visualisation(sim)\n\n    def update_cells(val):\n        sim.initialise_cells(int(vis.slider.val))\n        vis.redraw_plot(sim)\n        \n    # Connect the slider to the update function\n    vis.slider.on_changed(update_cells)\n\n    # Run simulation\n    for t in range(1, 10000):\n        \n        sim.simulate_step()\n        \n        if(t % DISPLAY_INTERVAL == 0):\n            # As long as only cells move, update only positions and timestamp\n            vis.update_plot(sim) \n            vis.ax.set_title(f\"Timestep: {t}\")\n            vis.fig.canvas.draw_idle()\n            plt.pause(10e-20)        \n        if(sim.redraw):\n            # When more has changes (e.g. number of cells or target position), redraw the plot\n            vis.redraw_plot(sim) \n            sim.redraw = False # Make sure it doesn't keep redrawing if not necessary\n        \n\n    # Keep the final plot open\n    plt.ioff()\n    # plt.show()\n\n\n\n# 2. SIMULATION CLASS\nclass Simulation:\n    \"\"\"Manages the grid, cells, target, and simulation logic.\"\"\"\n    def __init__(self, num_cells):\n        # Initialise a grid for the simulation\n        self.grid = np.zeros((WORLD_SIZE, WORLD_SIZE))  # Initialise an empty grid\n        self.fill_grid(self.grid, 0, 0, 0, 0)           # Fill grid with values (currently just 1s)\n        # Initialise a population of cells\n        self.cells = []\n        self.initialise_cells(num_cells)\n        # Place a 'target' in the middle\n        self.target_position = [WORLD_SIZE/2, WORLD_SIZE/2] \n        # A flag to only rebuild the plot when necessary (e.g. when the number of cells changes)\n        self.redraw = False\n\n    def simulate_step(self):\n        \"\"\"Simulate one timestep of the simulation.\"\"\"\n        for cell in self.cells:\n            # Actions taken by each cell. Most of them are still undefined, so you can implement them yourself.\n            self.move_towards_dot(cell)  \n            if self.check_target_reached(cell):\n                print(f\"Target reached!\")\n                self.reproduce_cell(cell)\n                self.redraw = True\n            \n            #self.avoid_collision(cell)\n            #self.stick_to_close(cell)\n            #self.find_peak(cell)\n\n            # Apply forces and update position\n            cell.apply_forces()\n            cell.update_position()\n\n            # Limit velocity to the maximum allowed\n            cell.vx = np.clip(cell.vx, -MAX_VELOCITY, MAX_VELOCITY)\n            cell.vy = np.clip(cell.vy, -MAX_VELOCITY, MAX_VELOCITY)\n\n    def initialise_cells(self, num_cells):\n        \"\"\"Initialise the cells with random positions and velocities.\"\"\"\n        self.cells = []\n        for _ in range(num_cells):\n            x = np.random.uniform(0, WORLD_SIZE)\n            y = np.random.uniform(0, WORLD_SIZE)\n            vx = np.random.uniform(-1, 1)\n            vy = np.random.uniform(-1, 1)\n            self.cells.append(Cell(x, y, vx, vy))\n\n    def fill_grid(self, grid, mean_x, mean_y, std_dev, noise=0):\n        \"\"\"\n        Write a function that takes the 2D grid and fills it with values representing \n        a Gaussian (normal) distribution centered at (mean_x, mean_y). See\n        if you can use the 'noise' argument to randomise the gaussian distribution a bit.\n        \n        Hint: e^{-x^2} yields a bell curve centered around 0. \n        \n        \"\"\"\n        for i in range(WORLD_SIZE):\n            for j in range(WORLD_SIZE):\n                x = i / (WORLD_SIZE - 1)\n                y = j / (WORLD_SIZE - 1)\n                grid[i, j] = 1 # This is 1 in the example, but should be a Gaussian distribution\n\n        # Normalize the grid to keep the total resource concentration the same\n        self.grid = grid\n    \n    def find_peak(self, cell):\n        \"\"\"Make the cell move towards the peak of the resource gradient with a random walk.\"\"\"\n        # Convert cell position to grid indices, as well as the previous position\n        grid_x = int(cell.x) % WORLD_SIZE\n        grid_y = int(cell.y) % WORLD_SIZE\n        next_x = (int(cell.x + 30*cell.vx) + WORLD_SIZE) % WORLD_SIZE \n        next_y = (int(cell.y + 30*cell.vy) + WORLD_SIZE) % WORLD_SIZE \n         \n    \n    def avoid_collision(self, cell):\n        \"\"\"Implement a simple collision avoidance mechanism. You can do so by\n        checking if this individual overlaps with another individual, and if so,\n        applying a repulsion force to the individual apposing the overlapping\n        direction.\"\"\"\n        for other_cell in self.cells:\n            if other_cell is not cell:\n                # Calculate the distance between the two cells\n                dx = cell.x - other_cell.x\n                dy = cell.y - other_cell.y\n                distance = np.sqrt(dx**2 + dy**2)\n                \n                    \n    def stick_to_close(self, cell):\n        \"\"\"Implement an attraction to cells that are nearby (but not overlapping)\"\"\"\n        for other_cell in self.cells:\n            if other_cell is not cell:\n                # Calculate the distance between the two cells\n                dx = cell.x - other_cell.x\n                dy = cell.y - other_cell.y\n                distance = np.sqrt(dx**2 + dy**2)\n\n    \n    def move_towards_dot(self, cell):\n        \"\"\"\n        Write your own function that applies forces in the direction of the dot.\n        Try to think of a way to apply the same force to every cell irrespective\n        of the distance to the dot, such that the cells move towards the dot at \n        the same speed. \n        \n        To get you started, the function already calculates dx and dy, which are\n        the distances to the target position in the x and y direction, respectively.\n        \"\"\"\n        # Calculate dx and dy\n        dx = self.target_position[0] - cell.x\n        dy = self.target_position[1] - cell.y\n        \n    \n    def check_target_reached(self, cell):\n        \"\"\"\n        Write your own function that checks if this cell has reached the target position.\n        You can do this by calculating the distance between the cell and the target.\n        If the distance is smaller than a certain threshold (e.g., 3 units), return True.\n        Otherwise, return False.\n        \"\"\"\n        \n        return(False)  # Dummy 'return' value. \n    \n    def reproduce_cell(self, cell):\n        \"\"\"\n        Write your own function that reproduces this cell. Think\n        about what it should inherit, and what it should *not* inherit. \n        \n        To keep the number of cell constant, you can first throw away a random cell.\n        \"\"\"\n        # Reproduce: Create a new cell with the same properties as the current cell\n        return(False) # Dummy 'return' value.\n\n        \n        \n# 3. CELL CLASS\nclass Cell:\n    \"\"\"Represents an individual cell in the simulation.\"\"\"\n    def __init__(self, x, y, vx, vy):\n        self.x = x\n        self.y = y\n        self.vx = vx\n        self.vy = vy\n        self.ax = 0\n        self.ay = 0\n        self.stickiness = 0.01 # Initial stickiness, can be adjusted later\n        \n    def update_position(self):\n        \"\"\"Update the cell's position based on its velocity.\"\"\"\n        self.x = (self.x + self.vx ) % WORLD_SIZE  # Wrap around the world\n        self.y = (self.y + self.vy ) % WORLD_SIZE  # Wrap around the world\n\n    def apply_forces(self):\n        \"\"\"Apply a force to the cell, updating its velocity.\"\"\"\n        self.ax = np.clip(self.ax, -MAX_FORCE, MAX_FORCE)\n        self.ay = np.clip(self.ay, -MAX_FORCE, MAX_FORCE)\n        self.vx += self.ax + RANDOM_MOVEMENT * np.random.uniform(-1, 1)\n        self.vy += self.ay + RANDOM_MOVEMENT * np.random.uniform(-1, 1)\n        # Apply drag to slow down the cell naturally\n        self.ax = 0\n        self.ay = 0\n        \n\n\n# Visualisation class for showing the individuals and the grid. For the practical, you do not need to change this. \nclass Visualisation:    \n    def __init__(self, sim):\n        fig, ax = plt.subplots(figsize=(6, 6))\n        self.cell_x = [cell.x for cell in sim.cells]\n        self.cell_y = [cell.y for cell in sim.cells]\n        self.cell_vx = np.array([cell.vx for cell in sim.cells])\n        self.cell_vy = np.array([cell.vy for cell in sim.cells])\n        self.cell_stickiness = np.array([cell.stickiness for cell in sim.cells])\n        # Colour cells by stickiness using inferno colormap\n        self.cell_scatter = ax.scatter(self.cell_x, self.cell_y, c=self.cell_stickiness, cmap='inferno', s=50, edgecolor='white', vmin=0, vmax=1)\n        if(DRAW_ARROW): self.cell_quiver = ax.quiver(self.cell_x, self.cell_y, self.cell_vx * 0.5, self.cell_vy * 0.5, angles='xy', scale_units='xy', scale=0.02, color='white')\n        plt.subplots_adjust(bottom=0.2)\n\n        ax.set_xlim(0, WORLD_SIZE)\n        ax.set_ylim(0, WORLD_SIZE)\n        ax.set_aspect('equal', adjustable='box')\n        ax.set_title(f\"Timestep: 0\")\n        ax.set_xlabel(\"X\")\n        ax.set_ylabel(\"Y\")\n\n        target_point=ax.scatter(sim.target_position[0], sim.target_position[1], c='purple', s=100, edgecolor='red')\n        grid_im=ax.imshow(sim.grid.T, extent=(0, WORLD_SIZE, 0, WORLD_SIZE), origin='lower', cmap='viridis', alpha=1.0)\n\n        self.fig = fig\n        self.ax = ax\n        self.target_point = target_point\n        self.grid_im = grid_im\n\n        # Add a slider for selecting the number of cells\n        ax_slider = plt.axes([0.2, 0.05, 0.6, 0.03])\n        self.slider = Slider(ax_slider, 'Cells', 1, 1000, valinit=len(sim.cells), valstep=1)\n\n    def update_cell_positions(self, sim):\n        \"\"\"Update the positions of the cells in the visualisation.\"\"\"\n        self.cell_x = [cell.x for cell in sim.cells]\n        self.cell_y = [cell.y for cell in sim.cells]\n        self.cell_vx = np.array([cell.vx for cell in sim.cells])\n        self.cell_vy = np.array([cell.vy for cell in sim.cells])\n        self.cell_stickiness = np.array([cell.stickiness for cell in sim.cells])\n    \n    def update_plot(self, sim):\n        self.update_cell_positions(sim)\n        self.cell_scatter.set_offsets(np.c_[self.cell_x,self.cell_y])\n        self.cell_scatter.set_array(self.cell_stickiness)\n        if(DRAW_ARROW): \n            self.cell_quiver.set_offsets(np.c_[self.cell_x, self.cell_y])\n            self.cell_quiver.set_UVC(self.cell_vx * 0.5, self.cell_vy * 0.5)        \n\n    def redraw_plot(self, sim):\n        self.update_cell_positions(sim)\n        cell_scatter_new = self.ax.scatter(self.cell_x, self.cell_y, c=self.cell_stickiness, cmap='inferno', s=50, edgecolor='white', vmin=0, vmax=1)\n        if(DRAW_ARROW): \n            cell_quiver_new = self.ax.quiver(self.cell_x, self.cell_y, self.cell_vx * 0.15, self.cell_vy * 0.15, angles='xy', scale_units='xy', scale=0.02, color='white')\n            self.cell_quiver.remove()\n            self.cell_quiver = cell_quiver_new\n        self.cell_scatter.remove()\n        self.fig.canvas.draw_idle()\n        self.cell_scatter = cell_scatter_new\n        self.grid_im.remove()\n        self.grid_im = self.ax.imshow(sim.grid.T, extent=(0, WORLD_SIZE, 0, WORLD_SIZE), origin='lower', cmap='viridis', alpha=1.0)\n        self.target_point.remove()\n        self.target_point=self.ax.scatter(sim.target_position[0], sim.target_position[1], c='purple', s=100, edgecolor='red')\n        plt.pause(10e-20)\n            \n            \n# 4. Execute the main loop\nif __name__ == \"__main__\":\n    # with cProfile.Profile() as pr:\n        main()\n        # pr.print_stats()\n\n\n\n\n\nMake sure you inspect the code. What features does the Simulation class have? What features does a Cell have?\nAs you can see if you inspected the code properly, many functions are left empty (or at least do not do anything yet). You will start filling these with your own code.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "evo_practical_1.html#sec-movingtarget",
    "href": "evo_practical_1.html#sec-movingtarget",
    "title": "15  Practical 1",
    "section": "15.4 Moving the target",
    "text": "15.4 Moving the target\nIf you run the code, you will see a purple dot (with a red outline). This may represent a “target”. It could represent a resource patch for bacteria, but it could also be a piece of fruit for a monkey (at this point, the model is still very abstract, so both could be true). Let’s make the target change position around after an individual touches it.\nTo help you on your way, first answer the following questions for yourself:\n\nHow can you calculate the distance between an individual and the orange dot?\nWhen is an individual close enough to the orange dot?\nHow can we assign a random position to the dot?\n\nFirst try it yourself. If you get stuck, ask Bram for help.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "evo_practical_1.html#sec-reproduction",
    "href": "evo_practical_1.html#sec-reproduction",
    "title": "15  Practical 1",
    "section": "15.5 Reproduction",
    "text": "15.5 Reproduction\nLet’s reward the individual that found the target. To do this, we can call the ‘Cell’ constructor to make a new cell, and add it to the list of cells:\nnew_cell = Cell(new_x, new_y, new_vx, new_vy, new_speed)\nself.cells.append(new_cell)\nConsider which properties of the parent cell get inherited to the child:\n\nShould the exact position be inherited to offspring? (yes/no)\nShould the offspring be placed nearby its parent? (yes/no)\nDoes the velocity get inherited?\n\nNote that depending on the scenario, the above questions may change. When a planktonic algea reproduces the daughter cells may inherit the velocity of the mother cell, but if a monkey gives birth, it does not make a lot of sense to talk about the ‘velocity’ of the mother. If we consider plants, we should not even consider velocity of the individuals at any stage of their life.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "evo_practical_1.html#sec-collision",
    "href": "evo_practical_1.html#sec-collision",
    "title": "15  Practical 1",
    "section": "15.6 Collision detection",
    "text": "15.6 Collision detection\nAs the cells move towards the dot, you may notice that cells start overlapping quite a bit. Let’s implement a simple form of collision detection, where overlap is resolved by pushing cells away from each other. Answer the following questions to get on your way:\n\nHow can you calculate the distance between two cells?\nWhen are two points overlapping?\nWhat can we do when two points overlap?\n\nNow that we have implemented both target-finding, reproduction, and collision, we can study these individual mechanisms by commenting one or the other out. This is an important process in understanding a model. Try it for yourself!",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "evo_practical_1.html#sec-resourcepeak",
    "href": "evo_practical_1.html#sec-resourcepeak",
    "title": "15  Practical 1",
    "section": "15.7 Implementing a resource peak",
    "text": "15.7 Implementing a resource peak\nAs you may have noticed when reading the code, it also includes a grid. However, you don’t see this grid yet, as the function fill_grid currently sets every point to 1.\nWe can loop over the grid coordinates by using a double for-loop:\nfor i in range(WORLD_SIZE):\n  for j in range(WORLD_SIZE):\n    grid[i,j] = 1\nThe above function loops over all the grid points, and set the value of each grid point to 1. Let’s use the function np.exp to calculate a Gaussian that we will place in the center of the grid. The fill_grid already takes as arguments the grid, a relative x-coordinate (0-1), a relative y-coordinate (0-1), and a standard deviation (0-1).\nGet started by answering the following questions:\n\nThe function \\(e^{-x^2}\\) gives a bell-curve centered around zero. How can you make it centered around a different value?\nCombined with the numpy function np.exp, how can we use the equation in question a to create a Gaussian that is at the center of the grid?",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "evo_practical_1.html#sec-runandtumble",
    "href": "evo_practical_1.html#sec-runandtumble",
    "title": "15  Practical 1",
    "section": "15.8 Run and tumble",
    "text": "15.8 Run and tumble\n\n\n\n“Test”\n\n\nBacterial cells are so small, that they cannot detect a gradient directly (in other words, they don’t know in which direction resources are higher!). Instead, bacteria often use a “run and tumble” strategy. When they are currently not detecting an increase in the concentration (over time), they tumble. If they do detect an increase, they keep moving in the same direction. This is a very simple strategy, but it can be very effective mechanism for chemotaxis.\nIn our earlier code of a single, moving vector, we rotated the arrow by changing the ‘angle’ variable. However, these cells do not have an angle parameters, but only a velocity vector with components \\(v_x\\) and \\(v_y\\). If we want to rotate the velocity vector, we can use the following equation (rooted in basic trigonometry):\n\\[\nv_x' = v_x \\cdot cos(\\theta) - v_y \\cdot sin(\\theta) \\\\\nv_y' = v_x \\cdot sin(\\theta) + v_y \\cdot cos(\\theta)\n\\]\nWhere \\(\\theta\\) is the angle we want the vector to rotate (in radians, not degrees!), and \\(v_x\\) and \\(v_y\\) are the components of the vector. With this in mind, let’s try and model chemotaxis. Do it in the following way:\n\nDetermine the concentration of the position of the cell, AND the predicted position of the cell after a small timestep (hint: use \\(v_x\\) and \\(v_y\\) to predict the future position! ask Bram if you get stuck)\nMake sure the future position is not outside of the grid! (hint: use Google, ChatGPT, or Copilot and figure out how the “modulo” operator works)\nIf the future position has a higher concentration than the current position, keep moving in more or less the same direction, with a very small change.\nIf the future position is a lower concentration, rotate the velocity vector a lot.\n\nStudy if your individuals can find the resource peak. Notice that depending on your implementation, cells may or may not work. Make sure to carefully investigate why it does or does not work.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "evo_practical_1.html#sec-sticking",
    "href": "evo_practical_1.html#sec-sticking",
    "title": "15  Practical 1",
    "section": "15.9 Sticking together",
    "text": "15.9 Sticking together\nCells sticking together can be implemented in multiple ways. Cells could be connected by a Newtonian spring, or we could simple make sure that cells that are close to each other are attracted to one another. In this case, we will use the latter method. Note that this is not very different from collision avoidance, but it is the other way around. In fact, we now have two opposing forces: cells are attracted to one another but do not want to overlap. This can be a bit finicky to get right, so feel free to explore. Ask for help if you get stuck.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "evo_practical_1.html#cells",
    "href": "evo_practical_1.html#cells",
    "title": "15  Practical 1",
    "section": "15.10 500 cells?",
    "text": "15.10 500 cells?\nTry to run the model with 500 cells. Also go back to the starting code again (without all the additions), and run this code with 500 cells too.\n\nWhat happens? Can you explain this?\n\nThis is far as this introduction to IBMs in python goes. Simple IBMs can be efficiently implemented in basic Python, but for more complex models, it is better to i) use numpy operations to speed up your Python code, or ii) use a faster programming language like C, Rust, or Javascript. For the last part of this pratical, we will study the Javascript version of this model. But before that, here is the final code that I ended up with:",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "evo_practical_1.html#final-python-code-for-interested-students",
    "href": "evo_practical_1.html#final-python-code-for-interested-students",
    "title": "15  Practical 1",
    "section": "15.11 Final Python code (for interested students)",
    "text": "15.11 Final Python code (for interested students)\nThis combination of individuals moving in continuous space, combined with a grid (e.g. with resources, or other environmental states) is a very useful way to make a spatially structured model.\n\n\n\n\n\n\nFinal code\n\n\n\n\n\n\n###\n# PRACTICAL 1 | \"Every cell for themselves?\"\n# Things in this model that you have tried to implement yourself:\n# 1. Implement collision avoidance\n# 2. Implement reproduction\n# 3. Implement a Gaussian grid\n# 4. Implement \"run and tumble\"\n# 5. Add noise to Gaussian, what happens?\n# 5. Modify collision into STICKING (a little finicky)\n# 6. Try it out with 500 cells... \n###\n\n###\n# PRACTICAL 1 | PLENARY DISCUSSION\n# What else was discussed in the plenary?\n# 1. Why are grids so popular in modelling?\n# 2. Tessellation of space\n# 3. Automatic tessellation of space: quad tree\n# 4. In the full model (javascript/Cacatoo), a quad tree is present, impacting performance\n###\n\n# 1. IMPORTS AND PARAMETERS\n# Libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.widgets import Slider\n\n# Parameters for simulation\nWORLD_SIZE = 200  # Width / height of the world (size of grid and possible coordinates for cells)\nMAX_VELOCITY = 0.3  # Maximum velocity magnitude\nMAX_FORCE = 0.3  # Maximum force magnitude\nDRAG_COEFFICIENT = 0.01  # Friction to slow down the cell naturally\nRANDOM_MOVEMENT  = 0.01 # Random movement factor to add some noise to the cell's movement\nCELL_STICKINESS_LOW = 0.0 # Minimal stickiness of cells in population\nCELL_STICKINESS_HIGH = 0.10 # Maximal stickiness of cells in population\n# Parameters for display\nDRAW_ARROW = False  # Draw the arrows showing the velocity direction of the cells\nNOISE = 2 # Noise factor for the Gaussian grid (noise amount is raised to the power of this value)\nINIT_CELLS = 64 # Initial number of cells in the simulation\nSEASON_DURATION = 1000 # Duration of a season, after which the Gaussian grid is regenerated\nDISPLAY_INTERVAL = 5\n\n# 1. MAIN LOOP (using functions and classes defined below)\ndef main():\n    \"\"\"Main function to set up and run the simulation.\"\"\"\n    # Initialise simulation and its # The `visualis` variable in the code snippet provided is actually\n    # a misspelling of the correct variable name `vis`, which stands\n    # for the `Visualisation` class instance. The `Visualisation`\n    # class is responsible for managing the visualization of the\n    # simulation, including creating plots, updating them, and\n    # handling user interactions like the slider.\n    \n    num_cells = INIT_CELLS\n    sim = Simulation(num_cells) \n\n    plt.ion()\n    vis = Visualisation(sim)\n\n\n    def update_cells(val):\n        sim.initialise_cells(int(vis.slider.val))\n        vis.redraw_plot(sim)\n        \n    # Connect the slider to the update function\n    vis.slider.on_changed(update_cells)\n\n    # Run simulation\n    for t in range(1, 10000):\n        sim.simulate_step()\n        if(t % DISPLAY_INTERVAL == 0):\n            vis.update_plot(sim)\n            vis.ax.set_title(f\"Timestep: {t}\")\n            vis.fig.canvas.draw_idle()\n            plt.pause(10e-20)\n        if(t % SEASON_DURATION==0):\n            sim.fill_grid(sim.grid, 0.2+np.random.uniform(0,0.6), 0.2+np.random.uniform(0,0.6), 0.1, NOISE)\n            vis.redraw_plot(sim)# Create Gaussian grid\n        # Update title and redraw the plot\n\n    # Keep the final plot open\n    plt.ioff()\n    # plt.show()\n\n\n\n# 2. SIMULATION CLASS\nclass Simulation:\n    \"\"\"Manages the grid, cells, target, and simulation logic.\"\"\"\n    def __init__(self, num_cells):\n        self.grid = np.zeros((WORLD_SIZE, WORLD_SIZE))  # Initialise an empty grid\n        self.cells = []\n        self.target_position = [WORLD_SIZE/3, WORLD_SIZE/3]  # Initial target position at the center\n        self.target_position = [-1,-1]\n        self.fill_grid(self.grid, 0.5, 0.5, 0.1, NOISE)  # Create Gaussian grid\n        self.initialise_cells(num_cells)\n\n    def simulate_step(self):\n        \"\"\"Simulate one timestep of the simulation.\"\"\"\n        for cell in self.cells:\n            # Actions taken by each cell. Most of them are still undefined, so you can implement them yourself.\n            #self.move_towards_dot(cell)  \n            #if self.check_target_reached(cell):\n            #    print(f\"Target reached! New target position: {self.target_position}\")\n            #    self.reproduce_cell(cell) \n            \n            self.avoid_collision(cell)\n            self.stick_to_close(cell)\n            self.find_peak(cell)\n            \n            # Apply drag force to acceleration\n            cell.ax += -DRAG_COEFFICIENT * cell.vx\n            cell.ay += -DRAG_COEFFICIENT * cell.vy\n\n            # Apply forces and update position\n            \n            cell.apply_forces()\n            cell.update_position()\n\n            # Limit velocity to the maximum allowed\n            cell.vx = np.clip(cell.vx, -MAX_VELOCITY, MAX_VELOCITY)\n            cell.vy = np.clip(cell.vy, -MAX_VELOCITY, MAX_VELOCITY)\n\n    def initialise_cells(self, num_cells):\n        \"\"\"Initialise the cells with random positions and velocities.\"\"\"\n        self.cells = []\n        for _ in range(num_cells):\n            x = np.random.uniform(0, WORLD_SIZE)\n            y = np.random.uniform(0, WORLD_SIZE)\n            vx = np.random.uniform(-1, 1)\n            vy = np.random.uniform(-1, 1)\n            self.cells.append(Cell(x, y, vx, vy))\n\n    def fill_grid(self, grid, mean_x, mean_y, std_dev, noise=0):\n        \"\"\"Creates a Gaussian distribution with noise on the grid.\"\"\"\n        for i in range(WORLD_SIZE):\n            for j in range(WORLD_SIZE):\n                x = i / (WORLD_SIZE - 1)\n                y = j / (WORLD_SIZE - 1)\n                distance_squared = (x - mean_x)**2 + (y - mean_y)**2\n                grid[i, j] = np.exp(-distance_squared / (2 * std_dev**2)) * np.random.uniform(0.0, 1.0)**noise\n\n        # Normalize the grid to keep the total resource concentration the same\n        grid /= np.sum(grid)\n        self.grid = grid\n    \n    def find_peak(self, cell):\n        \"\"\"Make the cell move towards the peak of the resource gradient with a random walk.\"\"\"\n        # Convert cell position to grid indices, as well as the previous position\n        grid_x = int(cell.x) % WORLD_SIZE\n        grid_y = int(cell.y) % WORLD_SIZE\n        next_x = (int(cell.x + 10*cell.vx) + WORLD_SIZE) % WORLD_SIZE \n        next_y = (int(cell.y + 10*cell.vy) + WORLD_SIZE) % WORLD_SIZE \n        # Get the resource value at the cell's position, as well as the previous position\n        resource_value = self.grid[grid_x, grid_y]\n        resource_next = self.grid[next_x, next_y]\n        \n        # Check if the cell is moving in the right direction\n        if resource_next &gt; resource_value:\n            # Moving in the right direction: small random adjustment\n            angle = np.random.uniform(-0.1, 0.1)  # Small angle change\n        else:\n            # Moving in the wrong direction: large random adjustment\n            angle = np.random.uniform(-np.pi*1.0, np.pi*1.0)  # Large angle change\n        \n        # Rotate the velocity vector by the random angle according to trigonometric rotation formulas\n        new_vx = cell.vx * np.cos(angle) - cell.vy * np.sin(angle)\n        new_vy = cell.vx * np.sin(angle) + cell.vy * np.cos(angle)\n\n        # Update the acceleration with the new velocity vector, such that the cell moves towards the peak\n        cell.vx = new_vx\n        cell.vy = new_vy\n        cell.ax += cell.vx\n        cell.ay += cell.vy\n         \n    \n    def avoid_collision(self, cell):\n        \"\"\"Avoidance forces to prevent cells from colliding.\"\"\"\n        for other_cell in self.cells:\n            if other_cell is not cell:\n                # Calculate the distance between the two cells\n                dx = cell.x - other_cell.x\n                dy = cell.y - other_cell.y\n                distance = np.sqrt(dx**2 + dy**2)\n\n                # If the cells are too close, apply a repulsion force\n                if distance &lt; 5.0 and distance &gt; 0:  # Threshold for \"too close\"\n                    # Calculate the repulsion force proportional to the inverse of the distance\n                    force_magnitude = (5.0 - distance) / distance\n                    cell.ax += force_magnitude * dx  * 100\n                    cell.ay += force_magnitude * dy * 100\n                    \n    def stick_to_close(self, cell):\n        \"\"\"Stick to closeby cells.\"\"\"\n        for other_cell in self.cells:\n            if other_cell is not cell:\n                # Calculate the distance between the two cells\n                dx = cell.x - other_cell.x\n                dy = cell.y - other_cell.y\n                distance = np.sqrt(dx**2 + dy**2)\n\n                # If the cells are too close, apply a repulsion force\n                if distance &lt; 12 and distance &gt; 5:  # Threshold for \"close\"\n                    # Calculate the repulsion force proportional to the inverse of the distance\n                    cell.ax -= cell.stickiness * dx *10\n                    cell.ay -= cell.stickiness * dy *10\n    \n    def move_towards_dot(self, cell):\n        \"\"\"Apply forces in the direction of the dot.\"\"\"\n        # Calculate dx and dy\n        dx = self.target_position[0] - cell.x\n        dy = self.target_position[1] - cell.y\n        # Calculate the distance to the target (pythagorean theorem)\n        distance = np.sqrt(dx**2 + dy**2)\n        \n        # Normalize dx and dy \n        dx /= distance\n        dy /= distance\n        # Apply a small force towards the target\n        cell.ax += dx * 0.01\n        cell.ay += dy * 0.01\n    \n    def check_target_reached(self, cell):\n        distance_to_target = np.sqrt((cell.x - self.target_position[0])**2 +\n                                         (cell.y - self.target_position[1])**2)\n        if distance_to_target &lt; 3:\n            # Set a new target position\n            self.target_position = [np.random.uniform(0, WORLD_SIZE), np.random.uniform(0, WORLD_SIZE)]\n            return(True)\n        return(False)\n    \n    def reproduce_cell(self, cell):\n        # Reproduce: Create a new cell with the same properties as the current cell\n        angle = np.random.uniform(0, 2 * np.pi)\n        radius = np.random.uniform(0.05, 1.5)\n        new_x = cell.x + radius * np.cos(angle)\n        new_y = cell.y + radius * np.sin(angle)\n        new_cell = Cell(new_x, new_y, cell.vx, cell.vy)\n        random_cell = np.random.choice(self.cells)   \n        self.cells.remove(random_cell)\n        self.cells.append(new_cell)\n\n\n        \n        \n        \n# 3. CELL CLASS\nclass Cell:\n    \"\"\"Represents an individual cell in the simulation.\"\"\"\n    def __init__(self, x, y, vx, vy):\n        self.x = x\n        self.y = y\n        self.vx = vx\n        self.vy = vy\n        self.ax = 0\n        self.ay = 0\n        if(np.random.uniform(0,1) &lt; 0.5): \n            self.stickiness = CELL_STICKINESS_LOW\n        else:\n            self.stickiness = CELL_STICKINESS_HIGH\n        \n    def update_position(self):\n        \"\"\"Update the cell's position based on its velocity.\"\"\"\n        self.x = (self.x + self.vx ) % WORLD_SIZE  # Wrap around the world\n        self.y = (self.y + self.vy ) % WORLD_SIZE  # Wrap around the world\n\n    def apply_forces(self):\n        \"\"\"Apply a force to the cell, updating its velocity.\"\"\"\n        self.ax = np.clip(self.ax, -MAX_FORCE, MAX_FORCE)\n        self.ay = np.clip(self.ay, -MAX_FORCE, MAX_FORCE)\n        self.vx += self.ax + RANDOM_MOVEMENT * np.random.uniform(-1, 1)\n        self.vy += self.ay + RANDOM_MOVEMENT * np.random.uniform(-1, 1)\n        self.ax = 0\n        self.ay = 0\n        \n\n\n# Visualisation class for showing the individuals and the grid. For the practical, you do not need to change this. \nclass Visualisation:    \n    def __init__(self, sim):\n        fig, ax = plt.subplots(figsize=(6, 6))\n        self.cell_x = [cell.x for cell in sim.cells]\n        self.cell_y = [cell.y for cell in sim.cells]\n        self.cell_vx = np.array([cell.vx for cell in sim.cells])\n        self.cell_vy = np.array([cell.vy for cell in sim.cells])\n        self.cell_stickiness = np.array([cell.stickiness for cell in sim.cells])\n        # Colour cells by stickiness using inferno colormap\n        self.cell_scatter = ax.scatter(self.cell_x, self.cell_y, c=self.cell_stickiness, cmap='inferno', s=50, edgecolor='white', vmin=0, vmax=CELL_STICKINESS_HIGH*1.2)\n        if(DRAW_ARROW): self.cell_quiver = ax.quiver(self.cell_x, self.cell_y, self.cell_vx * 0.15, self.cell_vy * 0.15, angles='xy', scale_units='xy', scale=0.02, color='darkblue')\n        plt.subplots_adjust(bottom=0.2)\n\n        ax.set_xlim(0, WORLD_SIZE)\n        ax.set_ylim(0, WORLD_SIZE)\n        ax.set_aspect('equal', adjustable='box')\n        ax.set_title(f\"Timestep: 0\")\n        ax.set_xlabel(\"X\")\n        ax.set_ylabel(\"Y\")\n\n        target_point=ax.scatter(sim.target_position[0], sim.target_position[1], c='orange', s=50, edgecolor='white')\n        grid_im=ax.imshow(sim.grid.T, extent=(0, WORLD_SIZE, 0, WORLD_SIZE), origin='lower', cmap='viridis', alpha=1.0)\n\n        self.fig = fig\n        self.ax = ax\n        self.target_point = target_point\n        self.grid_im = grid_im\n        # Add a slider for selecting the number of cells\n        ax_slider = plt.axes([0.2, 0.05, 0.6, 0.03])\n        self.slider = Slider(ax_slider, 'Cells', 1, 1000, valinit=len(sim.cells), valstep=1)\n\n    def update_cell_positions(self, sim):\n        \"\"\"Update the positions of the cells in the visualisation.\"\"\"\n        self.cell_x = [cell.x for cell in sim.cells]\n        self.cell_y = [cell.y for cell in sim.cells]\n        self.cell_vx = np.array([cell.vx for cell in sim.cells])\n        self.cell_vy = np.array([cell.vy for cell in sim.cells])\n        self.cell_stickiness = np.array([cell.stickiness for cell in sim.cells])\n    \n    def update_plot(self, sim):\n        self.update_cell_positions(sim)\n        self.cell_scatter.set_offsets(np.c_[self.cell_x,self.cell_y])\n        self.cell_scatter.set_array(self.cell_stickiness)\n        if(DRAW_ARROW): \n            self.cell_quiver.set_offsets(np.c_[self.cell_x, self.cell_y])\n            self.cell_quiver.set_UVC(self.cell_vx * 0.15, self.cell_vy * 0.15)        \n\n    def redraw_plot(self, sim):\n        self.update_cell_positions(sim)\n        cell_scatter_new = self.ax.scatter(self.cell_x, self.cell_y, c=self.cell_stickiness, cmap='inferno', s=50, edgecolor='white', vmin=0, vmax=CELL_STICKINESS_HIGH*1.2)\n        if(DRAW_ARROW): \n            cell_quiver_new = self.ax.quiver(self.cell_x, self.cell_y, self.cell_vx * 0.15, self.cell_vy * 0.15, angles='xy', scale_units='xy', scale=0.02, color='darkblue')\n            self.cell_quiver.remove()\n            self.cell_quiver = cell_quiver_new\n        self.cell_scatter.remove()\n        self.fig.canvas.draw_idle()\n        self.cell_scatter = cell_scatter_new\n        self.grid_im.remove()\n        self.grid_im = self.ax.imshow(sim.grid.T, extent=(0, WORLD_SIZE, 0, WORLD_SIZE), origin='lower', cmap='viridis', alpha=1.0)\n        \n        plt.pause(0.01)\n            \n            \n# 4. Execute the main loop\nif __name__ == \"__main__\":\n    # with cProfile.Profile() as pr:\n        main()\n        # pr.print_stats()",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "evo_practical_1.html#exploring-the-full-javascript-model-with-evolution",
    "href": "evo_practical_1.html#exploring-the-full-javascript-model-with-evolution",
    "title": "15  Practical 1",
    "section": "15.12 Exploring the full Javascript model with evolution",
    "text": "15.12 Exploring the full Javascript model with evolution\nThe full model is implemented in Javascript, and can be found here.\nIn this full model, cells also reproduce every once in a while (when a “season” ends). Their reproductive success is shaped by the amount of resources at that position. Every time a cell reproduces there it inherits the parents stickiness, but it can also change this value a bit. This way, stickiness is an “evolvable” property on which natural selection will act. How much each cell is attracted to nearby cells depends on an internal “stickiness” parameter. Let the simulation run for some time.\n\nExercise 15.2 (The evolution of stickiness) \n\nWhat happens to the evolution of stickiness?\nIdentify multiple advantages and disadvantages of stickiness.\nGiven your answer in b., can you name an important parameter that may determine the balance bewteen the advantages and disadvantages of stickiness? See if you can test it using the options provided.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "evo_practical_1.html#footnotes",
    "href": "evo_practical_1.html#footnotes",
    "title": "15  Practical 1",
    "section": "",
    "text": "The code also contains a Visualisation class that uses the matplotlib library to draw the cells and their movement, which we have tuned to speed things up a bit. You do not need to understand this part of the code, but if you are interested feel free to check it out.↩︎",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Practical 1</span>"
    ]
  },
  {
    "objectID": "evo_practical_2.html",
    "href": "evo_practical_2.html",
    "title": "16  Practical 2",
    "section": "",
    "text": "16.1 Genotypes, phenotypes, and evolutionary algorithms\nNear the end of the lecture, we discussed the differences between the genotype (that which mutates) and the phenotype (that which is selected). Although you have likely already heard about these concepts, how can we study them in evolutionary models? During this practical, you will write your own evolutionary algorithms of increasing complexity, in order to learn about these topics. By the end of this practical, you should understand why the translation from genotype to phenotype (often referred to as the genotype-phenotype map) is such an important concept in evolutionary biology.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "evo_practical_2.html#simple-model-where-fitness-as-a-number",
    "href": "evo_practical_2.html#simple-model-where-fitness-as-a-number",
    "title": "16  Practical 2",
    "section": "16.2 Simple model where fitness as a number",
    "text": "16.2 Simple model where fitness as a number\nIn the introduction of this course part on evolution, we have already looked at as simple “Moran process”:\n\nStart with a population of individuals, each with a fitness value.\nSelect individuals based on their fitness to reproduce.\nReplace a random individual with this newly generate offspring.\nWith a small probability, modify the ‘fitness’ value of the newborn.\n\nAnd so on.\nWith a Moran process, competition between individuals is modelled in a very indirect (“implicit”) way. By always selecting fit individuals, and removing a random other, any individual in the populations could be replaced by another individual, which statistically is a fitter individual. One could thus say that “everyone is competing with everyone”. A different method is often applied in spatially structured models, as in this case only nearby individuals are competing. Then, we could sample who wins from an imaginary roulette wheel:\n\nAs can be seen, not all individual have the same size on the roulette wheel. That depicts differences in their growth rates, biomass, or other approximations of “fitness”. Also, the roulette wheel contains an area (shown in black) that shapes the chance that nobody reproduces. We will try and implement this rule to let individuals reproduce based on their fitness, but with only 10 competitors at a time. Let’s start with a code where individuals have a “fitness” value, but it not yet used for selection (see below). Read/test this code thoroughly before you move on to the next section.\n\n\n\n\n\n\nCODE FOR “fitness without fitness”\n\n\n\n\n\nimport random\nimport math\nimport matplotlib.pyplot as plt\n\n# Set the random number seed for reproducibility\nrandom.seed(0)\n\nplt.ion()  # Enable interactive plotting\n\n# --- PARAMETERS ---\ninitial_fitness = 0.1            # Starting fitness for all individuals\npopulation_size = 500             # Number of individuals (should be a square number for grid mode)\ngenerations = 20000               # Number of generations to simulate\nmutation_rate = 0.005            # Probability of mutation per reproduction event\nsample_interval = 5               # How often to sample and plot data\n\n# --- INITIALIZATION ---\n# Create initial population: all individuals start with the same fitness\npopulation = [initial_fitness for _ in range(population_size)]\n\n# Lists to track average fitness and diversity over time\navg_fitness = []\ndiversity_over_time = []\n\n# --- CORE FUNCTIONS ---\n\ndef mutate(fitness, rate=mutation_rate):\n    \"\"\"Mutate the fitness value with a given probability.\"\"\"\n    if random.random() &lt; rate:\n        # Fitness changes by a random value in [-0.1, 0.1], clipped to [0, 1]\n        return min(1.0, max(0.0, fitness + random.uniform(-0.1, 0.1)))\n    return fitness\n\ndef calculate_diversity(population):\n    \"\"\"NOT YET IMPLEMENTED! Calculate diversity as the standard deviation of fitness values.\"\"\"\n    return 0 \n\n# --- PLOTTING SETUP ---\nfig, ax1 = plt.subplots(figsize=(12, 8))\nax1.set_xlabel(\"Generation\")\nax1.set_ylabel(\"Average Fitness\", color='tab:blue')\nax1.set_ylim(0, 1)\nline1, = ax1.plot([], [], color='tab:blue', linewidth=2, label='Fitness')\nax1.tick_params(axis='y', labelcolor='tab:blue')\n\n# Second y-axis for diversity\nax2 = ax1.twinx()\nax2.set_ylabel(\"Diversity\", color='tab:green')\nline2, = ax2.plot([], [], color='tab:green', linestyle=':', linewidth=2, label='Diversity')\nax2.tick_params(axis='y', labelcolor='tab:green')\n\nfig.suptitle(\"Evolution Toward Fitness 1\")\nfig.tight_layout()\nfig.legend(loc='upper right')\nplt.grid(True)\nplt.draw()\n\n# --- EVOLUTION LOOP ---\nbest_fitness = -1\nfound = False\n\nfor gen in range(generations):\n    total_fit = sum(population)\n    best = max(population)\n    # Print when a perfect solution is found\n    if best == 1 and not found:\n        found = True\n        print(\"Found perfect solution at generation\", gen)\n        \n    # Sample and plot data at intervals\n    if gen % sample_interval == 0:\n        avg_fitness.append(total_fit / population_size)\n        diversity_over_time.append(calculate_diversity(population))\n        x_vals = [i * sample_interval for i in range(len(avg_fitness))]\n        line1.set_data(x_vals, avg_fitness)\n        line2.set_data(x_vals, diversity_over_time)\n        ax1.relim(); ax1.autoscale_view()\n        ax2.relim(); ax2.autoscale_view()\n        fig.suptitle(f\"Best Fitness: {best:.2f}\", fontsize=14)\n        plt.pause(0.01)\n        \n\n    # --- MORAN PROCESS ---\n    # For each individual, perform a reproduction event\n    for _ in range(100):  # 100 competition events per generation\n        # Select 1 random individual for replication\n        probs = [1 for fit in population] # All probability weights are equal (1.0)\n        parent_idx = random.choices(range(len(population)), weights=probs)[0] # Grab one random individual based on an unweighted list...\n        # Select individual to be replaced (uniform random)\n        dead_idx = random.randrange(len(population))\n        # Copy population for next generation\n        new_pop = population.copy()\n        # Offspring replaces the dead individual (with possible mutation)\n        new_pop[dead_idx] = mutate(population[parent_idx])\n        population = new_pop\n\ninput(\"\\nSimulation complete. Press Enter to exit plot window...\")",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "evo_practical_2.html#making-a-roulette-wheel-with-everyone-in-it",
    "href": "evo_practical_2.html#making-a-roulette-wheel-with-everyone-in-it",
    "title": "16  Practical 2",
    "section": "16.3 Making a roulette wheel with everyone in it",
    "text": "16.3 Making a roulette wheel with everyone in it\nIf you have read the code, you will see that we can pass a list of weights to the function random.choices, to determine who is most likely to be sampled. Currently, all the weights are set to 1:\nprobs = [1 for fit in population] # All probability weights are equal (1.0)\n\nRun the code with the current (all equal) weights. What happens?\nModify this line of code to take the fitness values as the weight, rather than 1. (hint: this is a VERY small change in the code).",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "evo_practical_2.html#a-roulette-wheel-of-a-subset-of-individuals",
    "href": "evo_practical_2.html#a-roulette-wheel-of-a-subset-of-individuals",
    "title": "16  Practical 2",
    "section": "16.4 A roulette wheel of a subset of individuals",
    "text": "16.4 A roulette wheel of a subset of individuals\nInstead of letting everyone reproduce, let us modify the code to only sample from a smaller list of ‘competitors’, and spin a virtual roulette wheel to determine who wins. There are many ways to implement this, but here’s how we will do it. We will sample N individuals from the population, and implement the following algorithm:\n\nSelect a random subset of N individuals from the population.\nTake/compute the fitness of each selected individual.\nAdd a reproduction-skip option with a fixed weight.\nChoose one individual or the skip option using weighted random selection.\nIf an individual was chosen, mutate it and replace a random individual in the population.\n\nBelow, there’s a small snippet of code doing what is explained above1. The variable no_reproduction_chance is the fixed weight that nobody gets to reproduce:\n\n\n\n\n\n\nRoulette wheel algorithm\n\n\n\n\n\n  tournament_size = 10  \n  no_reproduction_chance = 1\n  \n  competitors = random.sample(population, tournament_size)\n  # Make a list of their fitness values\n  fitness_values = [fit for fit in competitors]\n  total = sum(fitness_values)\n  # Add a \"no reproduction\" dummy competitor with fitness = 0\n  competitors_with_dummy = competitors + [None]\n  probs = [f / total for f in fitness_values] + [no_reproduction_chance]\n  winner = random.choices(competitors_with_dummy, weights=probs, k=1)[0]\n  if winner is not None:\n      # Mutate winner to produce offspring\n      offspring = mutate(winner)\n      remove_idx = random.randrange(len(population))\n      population[remove_idx] = offspring  \n        \n\n\n\nAfter you understand the roulette wheel algorithm, do the following exercise:\n\nExercise 16.1 (Questions about the roulette wheel) \n\nLet’s imagine a moment where the roulette wheel contains only 10 highly unfit individuals (e.g. all fitness values are 0.01). What is the chance that someone will reproduce? (you don’t have to calculate it, but give your reasoning)\nAnswer the same question as in a., but now imagine that all 10 individuals have a fitness value of 1.\nAnswer question b. and c. again, but now assume that no_reproduction_chance is equal to 0.\nDescribe what the no_reproduction_chance parameter does in biological terms.\nSpatially structured populations are often placed on a grid. Describe how you could implement a roulette wheel to resolve local competition, e.g. when an empty grid point is competed for by the neighbours.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "evo_practical_2.html#diversity-patterns",
    "href": "evo_practical_2.html#diversity-patterns",
    "title": "16  Practical 2",
    "section": "16.5 Diversity patterns",
    "text": "16.5 Diversity patterns\nModify the function calculate_diversity to calculate the diversity of the population as the standard deviation of the fitness values.\n\nExercise 16.2 (Questions about the roulette wheel) \n\nUse a low mutation rate and study the dynamics of diversity. Describe the pattern verbally.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "evo_practical_2.html#evolving-a-dna-sequence",
    "href": "evo_practical_2.html#evolving-a-dna-sequence",
    "title": "16  Practical 2",
    "section": "16.6 Evolving a DNA sequence",
    "text": "16.6 Evolving a DNA sequence\nA big problem with the previous model is there is no true distinction between genotype (that which mutates) and phenotype (that which is selected). Let us try and adapt the model to be more biologically meaningful, by making each individual represented by a DNA sequence. Copy the following code:\n\n\n\n\n\n\nStarting code for “evolving a DNA sequence”\n\n\n\n\n\nimport random\nimport math\nimport matplotlib.pyplot as plt\nfrom collections import Counter\n\n# set the random number seed\nrandom.seed(0)\n\nplt.ion()  # Enable interactive mode\n\n# Parameters\nalphabet = \"ATCG\"\ntarget_sequence = \"GATGCGCGCTGGATTAAC\"  # Example target sequence\ndna_length = len(target_sequence)\ntarget_length = len(target_sequence)\n\n# Simulation settings\npopulation_size = 500  # must be a square number for grid mode\ngenerations = 20000\nmutation_rate = 0.001\nsample_interval = 5\nsample_size = population_size\nno_reproduction_chance = 0.1\n\n# Core functions\ndef fitness(dna):\n    return 1 - sum(a != b for a, b in zip(dna, target_sequence)) / target_length\n\ndef mutate(dna, rate=mutation_rate):\n    return ''.join(\n        random.choice([b for b in alphabet if b != base]) if random.random() &lt; rate else base\n        for base in dna\n    )\n\ndef count_beneficial_mutations(dna):\n    f0 = fitness(dna)\n    count = 0\n    for i in range(len(dna)):\n        for b in alphabet:\n            if b != dna[i]:\n                mutant = dna[:i] + b + dna[i+1:]\n                if fitness(mutant) &gt; f0:\n                    count += 1\n    return count\n\ndef diversity(pop):\n    counts = {}\n    for ind in pop:\n        counts[ind] = counts.get(ind, 0) + 1\n    total = len(pop)\n    return -sum((c/total) * math.log(c/total + 1e-9) for c in counts.values()) if total &gt; 0 else 0\n\n# Initialize population\ninitial_sequence = \"GATAGCGAAGTTTAGCCG\" # far from target (only first 3 are correct)\npopulation = [initial_sequence for _ in range(population_size)]\n\navg_fitness = []\navg_beneficial = []\ndiversity_over_time = []\nbest_individuals = []\n\ndef get_neighbors(i, j):\n    return [(x % side, y % side)\n            for x in range(i-1, i+2)\n            for y in range(j-1, j+2)]\n\n# Initialize interactive plot\nfig, ax1 = plt.subplots(figsize=(12, 8))\nax1.set_xlabel(\"Generation\")\nax1.set_ylabel(\"Average Fitness\", color='tab:blue')\nax1.set_ylim(0, 1)\nline1, = ax1.plot([], [], color='tab:blue', linewidth=2, label='Fitness')\nax1.tick_params(axis='y', labelcolor='tab:blue')\n\nax2 = ax1.twinx()\nax2.set_ylabel(\"Beneficial Mutations / Diversity\", color='tab:purple')\nline2, = ax2.plot([], [], color='tab:purple', linestyle='--', linewidth=2, label='Beneficial Mutations')\nline3, = ax2.plot([], [], color='tab:green', linestyle=':', linewidth=2, label='Diversity')\nax2.tick_params(axis='y', labelcolor='tab:purple')\nfig.suptitle(\"Evolution Toward Target Sequence\")\nfig.tight_layout()\nax2.set_ylim(0, 20)\nfig.legend(loc='upper right')\nplt.grid(True)\nplt.draw()\n\nbest_seq = \"\"\nbest_score = -1\nfound = False\n\n# Evolution loop\nfor gen in range(generations):\n    fitnesses = [fitness(ind) for ind in population]\n    total_fit = sum(fitnesses)\n    best = max(fitnesses)\n    if(best == 1 and not found):\n        found = True\n        print(\"Found perfect solution at generation\", gen)\n        \n    if gen % sample_interval == 0:\n        sample = random.sample(population, sample_size)\n        avg_beneficial.append(sum(count_beneficial_mutations(ind) for ind in sample) / sample_size)\n        diversity_over_time.append(diversity(population))\n\n        # Update plot data\n        line1.set_data(range(len(avg_fitness)+1), avg_fitness + [sum(fitnesses)/population_size])\n        line2.set_data(range(len(avg_beneficial)), avg_beneficial)\n        line3.set_data(range(len(diversity_over_time)), diversity_over_time)\n        ax1.relim(); ax1.autoscale_view()\n        ax2.relim(); ax2.autoscale_view()\n        best = max(population, key=fitness)\n        fig.suptitle(f\"Best: {best} (target: {target_sequence})\", fontsize=14)\n        plt.pause(0.01)\n\n    else:\n        avg_beneficial.append(avg_beneficial[-1])\n        diversity_over_time.append(diversity_over_time[-1])\n\n    # Tournament selection (as in evolving_fitness_final.py)\n    new_pop = []\n    tournament_size = 10  # can be adjusted\n\n    for _ in range(population_size):\n        # Select tournament_size individuals randomly\n        competitors = random.sample(population, tournament_size)\n        # Pick the one with highest fitness\n        fitness_values = [fitness(ind) for ind in competitors]\n        total = sum(fitness_values)\n        \n        probs = [f / total for f in fitness_values]\n        winner = random.choices(competitors, weights=probs, k=1)[0]\n        # Mutate winner to produce offspring\n        offspring = mutate(winner)\n        new_pop.append(offspring)\n\n    population = new_pop\n\n    avg_fitness.append(sum(fitness(ind) for ind in population) / population_size)\n    if gen % 250 == 0:\n        best = max(population, key=fitness)\n        best_individuals.append((gen, best))\n\ninput(\"\\nSimulation complete. Press Enter to exit plot window...\")\n\n\n\nAnswer the following questions using the options available in the model:\n\nExercise 16.3 (Evolving DNA)  \n\nRun the code. What does the new (dashed blue) line represent? Do you understand how is changes over time?\n\nThe program reports after how many generations it manages to find the target sequence. With default settings this can take a long time… (default: 4633 generations)\n\nModify the mutation rate to see how it affects the time to find the target sequence. Try different mutation rates between 0.0001 and 0.1. Keep track of both how long (number of generations) it takes to find the target, and how fit the population is once the target is found. What do you observe?\nDiversity is no longer calculated as the standard deviation in fitness, but as the Shannon diversity of all present sequences (although it is not super complex, you do not need to fully understand this function). Because of this, the exact number (quantities) cannot be compared to our ealrier model. Do you see a qualitative differences?\nStudy how fitness is calculated in this model. Is there a distinction between genotype en phenotype? Why/why not?",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "evo_practical_2.html#evolving-a-protein-sequence",
    "href": "evo_practical_2.html#evolving-a-protein-sequence",
    "title": "16  Practical 2",
    "section": "16.7 Evolving a protein sequence",
    "text": "16.7 Evolving a protein sequence\nNext we will extend the simulation a little more. The individual genotypes will still be represented as a DNA sequence, but before evaluating fitness this will be translated into a protein sequence. To do so, the code first defines the codon table (which we of course all know by heart =)), and then translates the DNA sequence into a protein sequence. The protein sequence is then used to calculate the fitness of the individual, which is based on how well the protein sequence matches a target protein sequence. The code is as follows:\n\n\n\n\n\n\nStarting code for evolving a protein sequence\n\n\n\n\n\nimport random\nimport math\nimport matplotlib.pyplot as plt\nfrom collections import Counter\n\n# set the random number seed\nrandom.seed(0)\n\nplt.ion()  # Enable interactive mode\n\n# Codon table\ncodon_table = {\n    'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L', 'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n    'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n    'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n    'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S', 'AGT': 'S', 'AGC': 'S',\n    'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n    'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n    'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n    'TAT': 'Y', 'TAC': 'Y', 'CAT': 'H', 'CAC': 'H',\n    'CAA': 'Q', 'CAG': 'Q', 'AAT': 'N', 'AAC': 'N',\n    'AAA': 'K', 'AAG': 'K', 'GAT': 'D', 'GAC': 'D',\n    'GAA': 'E', 'GAG': 'E', 'TGT': 'C', 'TGC': 'C',\n    'TGG': 'W', 'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R', 'AGA': 'R', 'AGG': 'R',\n    'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n    'TAA': '*', 'TAG': '*', 'TGA': '*'\n}\n\n# Parameters\nalphabet = \"ATCG\"\ntarget_protein = \"DARWIN\"\ndna_length = len(target_protein)*3\ntarget_length = len(target_protein)\n\n# Simulation settings\npopulation_size = 625  # must be a square number for grid mode\ngenerations = 20000\nmutation_rate = 0.0005   \nsample_interval = 5\nsample_size = population_size\nno_reproduction_chance = 0.01\n\n# Core functions\ndef translate(dna):\n    return ''.join(codon_table.get(dna[i:i+3], '?') for i in range(0, len(dna), 3))\n\ndef fitness(dna):\n    protein = translate(dna)\n    return 1 - sum(a != b for a, b in zip(protein, target_protein)) / target_length\n\ndef mutate(dna, rate=mutation_rate):\n    return ''.join(\n        random.choice([b for b in alphabet if b != base]) if random.random() &lt; rate else base\n        for base in dna\n    )\n\ndef count_beneficial_mutations(dna):\n    f0 = fitness(dna)\n    count = 0\n    for i in range(len(dna)):\n        for b in alphabet:\n            if b != dna[i]:\n                mutant = dna[:i] + b + dna[i+1:]\n                if fitness(mutant) &gt; f0:\n                    count += 1\n    return count\n\ndef diversity(pop):\n    counts = Counter(pop)\n    total = len(pop)\n    return -sum((c/total) * math.log(c/total + 1e-9) for c in counts.values()) if total &gt; 0 else 0\n\n# Initialize population\ninitial_sequence = ''.join(random.choice(alphabet) for _ in range(dna_length))\npopulation = [initial_sequence for _ in range(population_size)]\n\navg_fitness = []\navg_beneficial = []\ndiversity_over_time = []\nbest_individuals = []\n\n# Grid setup\nside = int(math.sqrt(population_size))\nassert side * side == population_size, \"Population size must be a square number for grid mode\"\n\ndef get_neighbors(i, j):\n    return [(x % side, y % side)\n            for x in range(i-1, i+2)\n            for y in range(j-1, j+2)]\n\n# Initialize interactive plot\nfig, ax1 = plt.subplots(figsize=(12, 8))\nax1.set_xlabel(\"Generation\")\nax1.set_ylabel(\"Average Fitness\", color='tab:blue')\nax1.set_ylim(0, 1)\nline0, = ax1.plot([], [], color='black', linewidth=1, label='Max fitness')\nline1, = ax1.plot([], [], color='tab:blue', linewidth=2, label='Fitness')\nax1.tick_params(axis='y', labelcolor='tab:blue')\n\nax2 = ax1.twinx()\nax2.set_ylabel(\"Beneficial Mutations / Diversity\", color='tab:purple')\nline2, = ax2.plot([], [], color='tab:purple', linestyle='--', linewidth=2, label='Beneficial Mutations')\nline3, = ax2.plot([], [], color='tab:green', linestyle=':', linewidth=2, label='Diversity')\nax2.tick_params(axis='y', labelcolor='tab:purple')\nfig.suptitle(\"Evolution Toward \" + str(target_protein))\nfig.tight_layout()\nax2.set_ylim(0, 5)\nfig.legend(loc='upper right')\nplt.grid(True)\nplt.draw()\n\nbest_seq = \"\"\nbest_score = -1\nbest_fitnesses = []\nfound = False\n\n# Evolution loop\nfor gen in range(generations):\n    fitnesses = [fitness(ind) for ind in population]\n    total_fit = sum(fitnesses)\n    best = max(fitnesses)\n    best_fitnesses.append(best)\n    if(best == 1 and not found):\n        found = True\n        print(\"Found perfect solution at generation\", gen)\n        \n    if gen % sample_interval == 0:\n        sample = random.sample(population, sample_size)\n        avg_beneficial.append(sum(count_beneficial_mutations(ind) for ind in sample) / sample_size)\n        diversity_over_time.append(diversity(population))\n\n        # Update plot data\n        line0.set_data(range(len(avg_fitness)+1), best_fitnesses)\n        line1.set_data(range(len(avg_fitness)+1), avg_fitness + [sum(fitnesses)/population_size])\n        line2.set_data(range(len(avg_beneficial)), avg_beneficial)\n        line3.set_data(range(len(diversity_over_time)), diversity_over_time)\n        ax1.relim(); ax1.autoscale_view()\n        ax2.relim(); ax2.autoscale_view()\n        best = max(population, key=fitness)\n        fig.suptitle(f\"Best: {translate(best)} (target: {target_protein})\", fontsize=14)\n        plt.pause(0.01)\n\n    else:\n        avg_beneficial.append(avg_beneficial[-1])\n        diversity_over_time.append(diversity_over_time[-1])\n\n    new_pop = []\n    tournament_size = 10  # can be adjusted\n    \n    for _ in range(population_size):\n        # Select tournament_size individuals randomly\n        competitors = random.sample(population, tournament_size)\n        # Pick the one with highest fitness\n        fitness_values = [fitness(ind) for ind in competitors]\n        total = sum(fitness_values)\n        \n        probs = [f / total for f in fitness_values]\n        winner = random.choices(competitors, weights=probs, k=1)[0]\n        # Mutate winner to produce offspring\n        offspring = mutate(winner)\n        new_pop.append(offspring)\n\n    population = new_pop\n\n\n    avg_fitness.append(sum(fitness(ind) for ind in population) / population_size)\n    if gen % 250 == 0:\n        best = max(population, key=fitness)\n        best_individuals.append((gen, translate(best)))\n\ninput(\"\\nSimulation complete. Press Enter to exit plot window...\")\n\n\n\nAnswer the following question about the model:\n\nExercise 16.4 (Evolving protein sequences)  \n\nAnother line was added to the model. What new information can you obtain from analysing this line?\nStudy carefully how the other lines (also present in previous models) change over time. What do you observe? Try and capture what you see into words.\nIn biology, multiple genotypes can translate to the same phenotype (this is called a many-to-one genotype-phenotype map), or alternatively, one genotype can produce multiple phenotype (this is called phenotypic plasticity, or a one-to-many genotype-phenotype map). Which genotype-phenotype (GP) mapping applies to this model? Why?\nBonus question for motivated students modify the code to include a second target protein sequence, and alternate between the two targets. If you see something interesting, please share it with the class!",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "evo_practical_2.html#footnotes",
    "href": "evo_practical_2.html#footnotes",
    "title": "16  Practical 2",
    "section": "",
    "text": "Note that this is from the full code, so this code does not work stand-alone↩︎",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Practical 2</span>"
    ]
  },
  {
    "objectID": "evo_practical_3.html",
    "href": "evo_practical_3.html",
    "title": "17  Practical 3",
    "section": "",
    "text": "17.1 Building a model from scratch\nOver the last weeks you have been given many model of biology, and you have modified or extended upon them. For this practical, I will give you a only a description. Your challenge will be to see how far you get in trying to get this model working yourself. I advice you use AI-assisted programming only to solve small steps, otherwise you have no clue what you are doing. But if you try and do everything yourself, it may take a little long.\nAt the end of the pratical, we will compare different implementations by students, as well as my implementation. Hopefully, we will see some generic patterns, because the model description should be good enough to give “similar models”. The description should be “vague enough” to lead to some differences, but “precise enough” to yield similar results. This is an experiment in and of itself. So let’s see :’)\nNote that I also do not yet know exactly what will happen in this simulation (although I have tried it out), so I’m hoping we will learn some cool stuff together!",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "evo_practical_3.html#simulating-a-simple-microbial-ecosystem-with-public-goods",
    "href": "evo_practical_3.html#simulating-a-simple-microbial-ecosystem-with-public-goods",
    "title": "17  Practical 3",
    "section": "17.2 Simulating a simple microbial ecosystem with “public goods”",
    "text": "17.2 Simulating a simple microbial ecosystem with “public goods”\n\nModel description\nMicrobes often produce public goods, from which surrounding microbes can benefit. This can lead to interesting dynamics, such as cooperation and competition. Most models however consider on 1 public good at a time, which leads to limited diversity (a producer, and a non-producer may or may not coexist). Here, we will an ecosystem with many public goods, and simulate them on a grid.\nAn individual microbe will carry a “genome” that is represented by a binary string (101010010011). Each position in the string represents a public good, and whether the individual can produce it (1) or not (0). The individual can rely on other individuals to produce public goods.\nWe will simulate individuals (microbial cells) reproducing and dying on a grid. A grid point either contains an individual, or it is empty. Every empty point, will be competed for by individuals that are in that neighbourhood. The neighbourhood is defined as the 8 surrounding grid points (this is called the “Moore” neighbourhood). The cells can only replicate if they have all the public goods they need, which means that they can rely on other individuals in their neighbourhood to produce them. If they do not have all public goods available, they cannot replicate. The “winner” from these (max) 8 viable competitors will be determined by a roulette wheel selection, where the relative probability is determined by their fitness:\n\\[\nF_i = 1 - c \\cdot \\sum({bitstring})\n\\]\nIn other words, fitness goes down as the number of public goods produced increases, and there is a cost \\(c\\) associated with producing each public good. Make sure this roulette wheel contains a probability that nobody wins, such that highly unfit individuals are less likely to replicate than highly fit individuals (also see earlier practicals).\nThe individual that replicates, can undergo mutations in the bitstring (gene loss and gene gain). Assume gene loss is more likely than gene gain (initial parameters to explore are summarised below)\nFinally, implement a function that allows you to mix the grid (all individuals are placed in a random position).\n\n\nModel output\nThe model will have the following output: a grid that is coloured by the number of public goods produced (for consistency, let’s all use a ‘viridis’ scale), and a line graph that plots the total population sizes, as well as the population sizes of species producing 0 public goods, 1 public good, 2 public goods, etc.\n\n\nParameters to start out with\n\nGrid size: 50 x 50\nInitial population: produces all public goods (1111…1)\nDeath rate: 0.1\nCost (c): 0.05\nBitstring 1 to 0 mutation (losing a gene): 0.01\nBitstring 0 to 1 mutation (gaining a gene): 0.001\nNumber of public goods (i.e. bitstring length): 10\n“No-event” size of roulette wheel: 1\n\n\n\nProposed experiments\nTry investigating how the model behaves with different values of \\(c\\) (the cost of producing public goods). Can you explain what happens at \\(c=0.0\\)?\nTry studying the effect of mixing the whole grid every timestep, such that neighbourhoods are constantly “randomised”. Look at the population size, as well as the distribution of different types. Can you explain the observations in biological terms?\nTry studying what happens at different mutation rates.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Practical 3</span>"
    ]
  },
  {
    "objectID": "evo_answers.html",
    "href": "evo_answers.html",
    "title": "18  Answers exercises",
    "section": "",
    "text": "18.1 Answers to Evolution Practical 1",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Answers exercises</span>"
    ]
  },
  {
    "objectID": "evo_answers.html#answers-to-evolution-practical-1",
    "href": "evo_answers.html#answers-to-evolution-practical-1",
    "title": "18  Answers exercises",
    "section": "",
    "text": "Questions Exercise 15.1\n\nFor this, you can simply multiply the velocity components every timestep by a value &gt; 1. For example:\n# Accellerate the velocity\nvx *= 1.01\nvy *= 1.01\nNote that this gets out of hand quite quickly.\nTo do this, we need to store the new values in a temporary variable, and then assign them to the original variables. This is necessary because while we first modify vx, we still want to use the ‘old’ value of vx to calculate the new vy. The following code rotates the velocity vector by 0.05 radians:\n# Rotate the velocity vector by a small angle \nvxnew = vx * np.cos(0.05) - vy * np.sin(0.05)\nvynew = vx * np.sin(0.05) + vy * np.cos(0.05)\nvx, vy = vxnew, vynew\nIf you run this code, you will see that the dot will go in circles.\nWhile the code above stores x, y, vx, and vy as a ‘global variables’, this is not good if we have many individuals. Instead, we can store the state of each individual in a list, dictionary, or a class. For example, we make a class ‘cell’ and store 100 of these ‘cells’ in a large list:\nclass Cell:\n    def __init__(self, x, y, vx, vy):\n        self.x = x\n        self.y = y\n        self.vx = vx\n        self.vy = vy\n\n# Create 100 cells with random positions and 0 velocity\ncells = [Cell(np.random.rand(), np.random.rand(), 0.0, 0.0) for _ in range(100)]\n\n\n\nMoving the target (Section 15.4)\nA working code to steer the individuals towards the target is shown below. Note that the acceleration that is applied is only small, otherwise the individuals will move in a straight line towards the target very rapidly.\ndef move_towards_dot(self, cell):\n   \"\"\"Apply forces in the direction of the dot.\"\"\"\n   # Calculate dx and dy\n   dx = self.target_position[0] - cell.x\n   dy = self.target_position[1] - cell.y\n   # Calculate the distance to the target (pythagorean theorem)\n   distance = np.sqrt(dx**2 + dy**2)\n   \n   # Normalize dx and dy \n   dx /= distance\n   dy /= distance\n   # Apply a small force towards the target\n   cell.ax += dx * 0.01\n   cell.ay += dy * 0.01\n\n\nReproduction (Section 15.5)\nA working code to reproduce a cell is shown below. Note that I decided to first throw an individual away, and then add the newborn individual (instead of the other way around). This ensures the newborn cannot be immediately thrown away, which would be a rather pointless event.\ndef reproduce_cell(self, cell):\n        # Reproduce: Create a new cell with the same properties as the current cell\n        angle = np.random.uniform(0, 2 * np.pi)\n        radius = np.random.uniform(0.05, 1.5)\n        new_x = cell.x + radius * np.cos(angle)\n        new_y = cell.y + radius * np.sin(angle)\n        new_cell = Cell(new_x, new_y, cell.vx, cell.vy)\n        random_cell = np.random.choice(self.cells)   \n        self.cells.remove(random_cell)\n        self.cells.append(new_cell)\n\n\nCollision (Section 15.6)\nA working code for cell-cell collision is shown below. Note that we apply a large force as we want this force to be able to overpower other forces that make the cells overlap.\n def avoid_collision(self, cell):\n        \"\"\"Avoidance forces to prevent cells from colliding.\"\"\"\n        for other_cell in self.cells:\n            if other_cell is not cell:\n                # Calculate the distance between the two cells\n                dx = cell.x - other_cell.x\n                dy = cell.y - other_cell.y\n                distance = np.sqrt(dx**2 + dy**2)\n\n                # If the cells are too close, apply a repulsion force\n                if distance &lt; 5.0 and distance &gt; 0:  # Threshold for \"too close\"\n                    # repulsion force proportional to the inverse of the distance\n                    force_magnitude = (5.0 - distance) / distance\n                    cell.ax += force_magnitude * dx  * 100\n                    cell.ay += force_magnitude * dy * 100\n\n\nA resource peak (Section 15.7)\nA working code to implement a resource peak (with optional noise set to 0 by default) is shown below:\ndef fill_grid(self, grid, mean_x, mean_y, std_dev, noise=0):\n        \"\"\"Creates a Gaussian distribution with noise on the grid.\"\"\"\n        for i in range(WORLD_SIZE):\n            for j in range(WORLD_SIZE):\n                x = i / (WORLD_SIZE - 1)\n                y = j / (WORLD_SIZE - 1)\n                distance_squared = (x - mean_x)**2 + (y - mean_y)**2\n                grid[i, j] = np.exp(-distance_squared / (2 * std_dev**2)) * np.random.uniform(0.0, 1.0)**noise\n\n        # Normalize the grid to keep the total resource concentration the same\n        grid /= np.sum(grid)\n        self.grid = grid\n\n\nRun and tumble (Section 15.8)\nA working code to implement a run-and-tumble mechanism shown below:\ndef find_peak(self, cell):\n        # Convert cell position to grid indices, as well as the previous position\n        grid_x = int(cell.x) % WORLD_SIZE\n        grid_y = int(cell.y) % WORLD_SIZE\n        next_x = (int(cell.x + 10*cell.vx) + WORLD_SIZE) % WORLD_SIZE \n        next_y = (int(cell.y + 10*cell.vy) + WORLD_SIZE) % WORLD_SIZE \n        # Get the resource value at cell's position, as well as the next position\n        resource_value = self.grid[grid_x, grid_y]\n        resource_next = self.grid[next_x, next_y]\n        \n        # Check if the cell is moving in the right direction\n        if resource_next &gt; resource_value:\n            # Moving in the right direction: small random adjustment\n            angle = np.random.uniform(-0.1, 0.1)  # Small angle change\n        else:\n            # Moving in the wrong direction: large random adjustment\n            angle = np.random.uniform(-np.pi*1.0, np.pi*1.0)  # Large angle change\n        \n        # Rotate the velocity vector by the angle calculated\n        new_vx = cell.vx * np.cos(angle) - cell.vy * np.sin(angle)\n        new_vy = cell.vx * np.sin(angle) + cell.vy * np.cos(angle)\n    \n        # Update the acceleration with the new velocity vector\n        cell.vx = new_vx\n        cell.vy = new_vy\n        cell.ax += cell.vx\n        cell.ay += cell.vy\n\n\nStickiness (Section 15.9)\nA working code for stickiness is shown below. The force applied here is smaller than the collision force (as said, we want to try and avoid collision even as cells want to move closer to eachother).\ndef stick_to_close(self, cell):\n        \"\"\"Stick to closeby cells.\"\"\"\n        for other_cell in self.cells:\n            if other_cell is not cell:\n                # Calculate the distance between the two cells\n                dx = cell.x - other_cell.x\n                dy = cell.y - other_cell.y\n                distance = np.sqrt(dx**2 + dy**2)\n\n                # If the cells are too close, apply a repulsion force\n                if distance &lt; 12 and distance &gt; 5:  # Threshold for \"close\"\n                    # Calculate the repulsion force proportional to the inverse of the distance\n                    cell.ax -= cell.stickiness * dx *10\n                    cell.ay -= cell.stickiness * dy *10\n\n\nThe evolution of stickiness (Exercise 15.2)\n\nIn the full model, stickiness naturally evolves to be higher. Natural selection therefore favours stickiness. However, it does not keep increasing and it stabilises around 0.25.\nThe advantages of stickiness are that larger groups of cells are better at steering towards the resources. Even if a single cell tries to go in the wrong direction, it will be pulled back. Together, they are less sensitive to the noise. Another distinct advantage is that the stickiest cells are sorted to be in the center of the group (as you have already seen earlier in this course!). That means that even after the peak was found, the stickiest cells have an advantage over the other cells as they can occupy the peak of the resource distribution. The disadvantages of stickiness are that larger groups move more slowly, and that the sticky clusters tend to stay together even if there are many resource peaks (and therewith miss out on resources).\nThe duration of the seasonal cycle is very important. If it is very long, it does not matter that the large clusters move slowly, as they will be better at finding and staying on the peak by being sticky. If the cycle is however very short, it may be more important to be able to move quickly and change direction rapidly. In that case, being too sticky may be a problem. As you modify this parameter in the online model, you will indeed see that shorter seasons mostly cause stickiness to drift close to 0.0, while longer seasons cause stickiness to evolve towards 0.25 or even higher.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Answers exercises</span>"
    ]
  },
  {
    "objectID": "evo_answers.html#answers-to-evolution-practical-2",
    "href": "evo_answers.html#answers-to-evolution-practical-2",
    "title": "18  Answers exercises",
    "section": "18.2 Answers to Evolution Practical 2",
    "text": "18.2 Answers to Evolution Practical 2\n\nQuestions Exercise 16.1\n\nIf we sample 10 unfit individuals, the weight of the no_reproduction_event is proportionally high (the black slice of the roulette wheel is big). Hence, there is only a small chance that anyone will reproduce.\nIf we sample 10 fit individuals (fitness 1), the chances are much higher that someone will reproduce.\nIf the dummy value is 0, the chances that someone will reproduce are the same in both scenarios, as even with very unfit individuals there is no chance that nobody reproduces.\nIn nature, if no individual is sufficiently fit, reproduction may not occur at all. For example, if the competing individuals are bacteria with very low glucose uptake rates, they may not yet be physiologically ready to reproduce. In such cases, population size should remain stable or even decline if death is also occurring. The no_reproduction_event captures this by ensuring that fitness is not judged solely in relative terms against other individuals, but also in absolute terms against environmental demands.\nIf a grid point is empty (contains no individual), make a list of (up to) 8 individuals around that grid point. Apply the roulette wheel for those individuals, and place the ‘winner’ inside the empty grid point.\n\n\n\nQuestions Exercise 16.2\nA snippet to calculate the standard deviation of a population is shown below. Note that this value is already being plotted, so if you modify this function you ought to be able to see what happens immediately.\ndef calculate_diversity(population):\n    \"\"\"Calculate diversity as the standard deviation of fitness values.\"\"\"\n    mean = sum(population) / len(population)\n    variance = sum((x - mean) ** 2 for x in population) / (len(population) - 1)\n    return math.sqrt(variance)\n\nThe green dotted line is the standard deviation of the values in the population (‘diversity’). From this we can see that the population is only breifly diverse whenever a new, fit individual appears. In between these phases, diversity is 0. This makes intuitive (biological) sense, as with a low mutation rate the only moments where there is more than 1 species is during the invasion of a new mutant. During all other phases, there is just a single (fittest) species.\n\n\n\n\nQuestions Exercise 16.3\n\nThe new blue dotted line represents how many mutations are beneficial (towards the target). As the population gets closer to the target, the number of beneficial mutations decreases. As such, this line is a mirror image of the fitness in the population. We will look a bit deeper into this line in the next model.\nGenerally speaking, a higher mutation rate helps to find the target faster. However, with high mutation rates (0.01 or higher), the fitness after the target is found starts to decrease, as individual produce many (unfit) mutants. In fact, if mutation rate is too high (approximately 0.04 or higher), the population fails to find the target at all, as reproduction is too inaccurate! This concept is known as the ‘error threshold’ or the ‘error catastrophe’ in evolutionary biology.\nQualitatively, there is no clear difference to what we saw before: diversity only peaks at moments when there is a new mutant coming in, but otherwise diversity is 0.\nThere is no distinction between genotype and phenotype. Fitness is directly calculated from the DNA sequence, so there is no ‘genotype-to-phenotype mapping’.\n\n\n\nQuestions Exercise 16.4\n\nThe new black line is the maximum fitness in the population. Thanks to this line we can see that, sometimes, an individual is present that is fitter but it does not manage to take over the population. We are dealing with a stochastic process, so this is very natural.\nThe fitness line once again goes in distinct steps. The diversity line (green dotted) has a distinct behaviour compared to earlier models. Instead of only going up during the discovery of a new mutant, it constantly creeps up during periods where fitness does not change. This is because the codon-table is partially redundant: many different DNA sequences can code for the same amino acid sequence, so diveristy increases. However, when a new “fitter” individual comes in, diversity goes down as that individual clonally takes over the population. Then, diversity slowly increases again. A similar pattern is reflected in the line that represents the “beneficial mutations” (blue dotted line). TLDR; even when fitness is not changing there is still a lot going on in this population!\nThis model represents a many-to-one mapping between genotype and phenotype. The DNA sequence (genotype) is translated into an amino acid sequence (phenotype), which is then used to calculate fitness. This means that many different genotypes can lead to the same phenotype, and thus the same fitness. Earlier in this course you have learned about development, and those processes often lead to effects where the same genotype can produce many different shapes (phenotypes).\nBONUS: I have not personally done this, and I do not know the answer to this question yet. However, it is sometimes observed that with many-to-one mapping, populations can because better and better at switching between two alternating targets. This is because the alternating selection pressures make populations move towards genotypes that are “close” to both targets, and because there is some neutrality coding this can be acchieved without losing fitness in either environment. For cool paper on this principle, see Crombach and Hogeweg (2008). I suspect however that our current model will not be able to do the same.\n\n\n\n\n\nCrombach, Anton, and Paulien Hogeweg. 2008. “Evolution of Evolvability in Gene Regulatory Networks.” PLoS Computational Biology 4 (7): e1000112.",
    "crumbs": [
      "IV) Evolution",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Answers exercises</span>"
    ]
  },
  {
    "objectID": "project_1.html",
    "href": "project_1.html",
    "title": "19  Differentiation introduction",
    "section": "",
    "text": "19.1 Equations\nHere’s an equation:\n\\[\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = rN(1 - \\frac{N}{K})\n\\tag{19.1}\\]\nAnd Equation A.1 is a reference to the equation above.",
    "crumbs": [
      "Mini-projects",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Differentiation introduction</span>"
    ]
  },
  {
    "objectID": "project_1.html#references",
    "href": "project_1.html#references",
    "title": "19  Differentiation introduction",
    "section": "19.2 References",
    "text": "19.2 References\nSee Knuth (1984) for additional discussion of literate programming.",
    "crumbs": [
      "Mini-projects",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Differentiation introduction</span>"
    ]
  },
  {
    "objectID": "project_1.html#syntax-highlighting",
    "href": "project_1.html#syntax-highlighting",
    "title": "19  Differentiation introduction",
    "section": "19.3 Syntax highlighting",
    "text": "19.3 Syntax highlighting\nHere’s some python code:\nimport numpy as np\nnp.random.seed(42)\na = 1 + 2\nb = a + 3\nprint(\"Hello\")",
    "crumbs": [
      "Mini-projects",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Differentiation introduction</span>"
    ]
  },
  {
    "objectID": "project_1.html#visualising-data-r",
    "href": "project_1.html#visualising-data-r",
    "title": "19  Differentiation introduction",
    "section": "19.4 Visualising data (R)",
    "text": "19.4 Visualising data (R)\nHere’s an interactive plot generated with R:",
    "crumbs": [
      "Mini-projects",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Differentiation introduction</span>"
    ]
  },
  {
    "objectID": "project_1.html#a-youtube-clip",
    "href": "project_1.html#a-youtube-clip",
    "title": "19  Differentiation introduction",
    "section": "19.5 A youtube clip:",
    "text": "19.5 A youtube clip:",
    "crumbs": [
      "Mini-projects",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Differentiation introduction</span>"
    ]
  },
  {
    "objectID": "project_1.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "href": "project_1.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "title": "19  Differentiation introduction",
    "section": "19.6 An ‘iframe’ to a different page (e.g. my simulations)",
    "text": "19.6 An ‘iframe’ to a different page (e.g. my simulations)\n\n\nMermaid\nDiagrams (Mermaid syntax):\n\n\n\n\n\n\nflowchart TB\nA(Models) --&gt; C(\"Analytical (mathematical)\")\nA --&gt; B(\"Numerical (computational)\")\nB --&gt; F(Individual-based model)\nB --&gt; G(Cellular automaton)\nC --&gt; E(Differential equation)\nC --&gt; D(MAPs)\n\n\n\n\nFigure 19.1: Types of models\n\n\n\n\n\nWhich can be referred to Figure A.1.\n\n\nCallouts\nCall-outs can organise information and highlight important points.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nTip 19.1: Cross-Referencing a Tip\n\n\n\nAdd an ID starting with #tip- to reference a tip.\n\n\nSee Tip A.1…\n\n\nHow to format questions/problem sets\n\nExercise 19.1 (Test 1) The equation of any straight line, called a linear equation, can be written as:\n\\[\ny = mx + b\n\\tag{19.2}\\]\nRefer to the equation like this Equation A.2 or like Customlabel A.2.\na. Blabla?\nb. Of blablabla?\n\n\n\nSharing data tables:\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "Mini-projects",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Differentiation introduction</span>"
    ]
  },
  {
    "objectID": "project_2.html",
    "href": "project_2.html",
    "title": "20  Miniproject: maintaining a healthy microbiome",
    "section": "",
    "text": "20.1 Mini description\nMicrobes often form intricate relationships, not only amongst each other, but also with larger organisms from all kingdoms: plants, animals, and fungi. While they often provide useful services, microbes typically evolve much faster than these hosts. What stops a microbe from taking advantage of its host, taking more resources than it provides, or even damaging the host tissue to gain access to even more resources? The latter scenario, we would call a pathogen, and the likelyhood of this transition from occuring could be called the disease pressure.\nUnderstanding the fundamental principles behind disease pressure can help mitigating disease outbreaks. For example, if we understand the conditions under which a microbe is likely to become a pathogen, we can take steps to prevent this from happening.\nTo phrase the above story a little differently: the microbes in our gut or in the soil of our favourite crops, are constantly evolving on a parasitism-mutualism continuum (see Figure 20.1). In this mini project, you will investigate the dynamics of microbiomes evolving on such a continuum. We will particularly focus on how the properties of the host (plant, animals, etc.) shape the likelihood of disease outbreaks. To that end, here are a few key questions to get you started, but you don’t need to focus on each and every one of them at the same time. Plus, more (better!) questions will likely emerge as you work on the project. That’s science.",
    "crumbs": [
      "Mini-projects",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Miniproject: maintaining a healthy microbiome</span>"
    ]
  },
  {
    "objectID": "project_2.html#mini-description",
    "href": "project_2.html#mini-description",
    "title": "20  Miniproject: maintaining a healthy microbiome",
    "section": "",
    "text": "Figure 20.1: Parasitism-mutualism continuum of host-associated microbes. Note that this is a cartoon, and that nature is in almost all cases more complicated than this.",
    "crumbs": [
      "Mini-projects",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Miniproject: maintaining a healthy microbiome</span>"
    ]
  },
  {
    "objectID": "project_2.html#key-references",
    "href": "project_2.html#key-references",
    "title": "20  Miniproject: maintaining a healthy microbiome",
    "section": "20.2 Key references",
    "text": "20.2 Key references\n\nVan Vliet and Doebeli (2019): a model of self-sacrificing microbes in hosts with different transmission modes.\nKoskella and Bergelson (2020): an opinion piece on host-microbe (co)evolution and levels of selection",
    "crumbs": [
      "Mini-projects",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Miniproject: maintaining a healthy microbiome</span>"
    ]
  },
  {
    "objectID": "project_2.html#guiding-questions",
    "href": "project_2.html#guiding-questions",
    "title": "20  Miniproject: maintaining a healthy microbiome",
    "section": "20.3 Guiding questions:",
    "text": "20.3 Guiding questions:\n\nDo motile hosts (e.g. animals) experience different disease pressures than non-motile hosts (e.g. plants)?\nAre mutualistic microbes easier to maintain in short- or long-lived hosts?\nDoes non-local reproduction (e.g. seed/spore dispersal) change these patterns?\nHow does an adaptive immune system (animals) affect the evolution of microbiomes, compared to plants, who don’t have an adaptive immune system?",
    "crumbs": [
      "Mini-projects",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Miniproject: maintaining a healthy microbiome</span>"
    ]
  },
  {
    "objectID": "project_2.html#getting-started",
    "href": "project_2.html#getting-started",
    "title": "20  Miniproject: maintaining a healthy microbiome",
    "section": "20.4 Getting started",
    "text": "20.4 Getting started\nMaintaining self-sacrificial microbiomes isn’t easy, as shown by the work of Van Vliet and Doebeli (2019). They show that the evolution of self-sacrificing microbes (which they call “helpers”) is highly sensitive to the host’s longevity and transmission of microbes in between hosts (horizontal transmission). To understand why, start by reading their paper. If you have read it, unfold the text below to see my summary of their methods.\n\n\n\n\n\n\nMy summary of the model by van Vliet et al.\n\n\n\n\n\nThis model studies the maintanance of self-sacrificial “helper” microbes. Here, I will refer to helpers as “allies” (A), as to clearly differentiate it from “hosts” (H). Microbes that are not allies are referred to as neutral (N).\nAllies provide a benefit to their host, while neutral microbes do not. The microbes are modelled with simple ordinary differential equations (ODEs):\n\\[\n\\begin{aligned}\n\\color{#555}{\n\\frac{dN}{dt} =\n\\underbrace{rN}_{\\textrm{Growth N}} -\n\\underbrace{\\delta N(A+N)}_{\\textrm{Density-dependent death}}\n}\\\\\n\\color{green}{\n  \\frac{dA}{dt} =\n  \\underbrace{rA(1-\\gamma)}_{\\textrm{Growth A}} -\n  \\underbrace{\\delta A(A+N)}_{\\textrm{Density-dependent death}}\n}\\\\\n\\end{aligned}\n\\tag{1}\n\\] As you can see, allies grow slower than neutral microbes and are therefore at a competitive disadvantage, and will eventually be outcompeted. To counter-act the loss of allies, van Vliet’s model considers selection at the level of the host. To achieve this, the birth rate of hosts (\\(B_i\\)) depends on the frequency of allies A in the microbiome:\n\\[\nB_i = \\frac{r}{G_H}(1+s_b\\cdot \\frac{A}{A+N})\n\\]\nHere, \\(G_H\\) is a parameter that scales the host generation time w.r.t. the growth rate of microbes (\\(r\\)), with \\(G_H \\gg r\\) ensuring hosts are long-lived compared to microbes. The term \\(s_b\\) is the maximum benefit that hosts get from carrying the ally strain.\nThe death rate of hosts (\\(D_i\\)) increases linearly with the density of hosts at any given time (\\(H(t)\\)), and is given by:\n\\[\nD_i = \\frac{r}{G_H} \\frac{H(t)}{K_H}\n\\]\nWhere \\(H(t)\\) gives the number of hosts at a given time, and \\(K_H\\) denotes the basal carrying capacity in the absence of allies. Note that the true carrying capacity can be higher, as helpers increase the birth rate of hosts.\nWhenever a host reproduces, the microbiome is transmitted vertically to their offspring. The frequency of allies in the offspring is sampled from a normal distribution with mean \\(f_A\\):\n\\[\nf_{offspring}  = \\mathcal{N} (f_{A},\\sigma^2),\n\\\\\\text{with } f_A = \\frac{A}{A+N}\n\\]\nTo avoid negative ally frequencies, this number is truncated such that \\(0&lt;A_{offspring}&lt;1\\). The total density in the newborn is set by another parameter \\(n_0\\). The model by van Vliet also considers “horizontal” transmission of microbiomes, where \\(f_A\\) is not the ally frequency in the parent, but the frequency of allies in the microbiome of a random individual.\nSo far so good with all the math. Now the simulation…\n\nThe simulation loop\n\nThe birth and death rates of all hosts is calculated\nCalculate the probability of a host-level event (birth/death) occurring\nIf an event occurs, draw a random event proportional to its probability.\nExecute the event sampled in step 3\nUpdate all the microbiome ODEs.\n\n\n\n\n\nTo start the project, we will first replicate van Vliet’s results in Python. As a guideline, use my model summary above. I am ready to help where needed, but at this point in the course your experience should go a long way! If the simulation works, see if you can reproduce the following two figures:\n\n\n\n\n\n\n\n\n\n\n\n(a) Allies are maintained within a population of hosts (black line shows the average), despite each individual host (green thinner lines) constantly decreasing in ally types. This can be explained by selection at the level of the host.\n\n\n\n\n\n\n\n\n\n\n\n(b) Allies are not maintained within a population of hosts (black line shows the average) when transmission of microbiomes is horizontal (in between random individuals).\n\n\n\n\n\n\n\nFigure 20.2: Helper maintenance in hosts with different transmission modes",
    "crumbs": [
      "Mini-projects",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Miniproject: maintaining a healthy microbiome</span>"
    ]
  },
  {
    "objectID": "project_2.html#extending-the-model",
    "href": "project_2.html#extending-the-model",
    "title": "20  Miniproject: maintaining a healthy microbiome",
    "section": "20.5 Extending the model",
    "text": "20.5 Extending the model\nNow that you have a working base-line model, let’s extend it to address the questions we phrased earlier: how does mobility of the host affect the evolution of microbiomes, and what about non-locally reproducing fungi? How do these host-level traits affect the likelyhood of “disease” outbreaks? Note that so far, we have only discussed “helpers” and “neutral” microbes, but the same principles apply to pathogens but perhaps a little more extreme. For example, the microbes may evolve such high levels of nastiness, that hosts do not only replicate slower, but die. Think about ways to extend the model that allows you to tune these distinctions.\n\n\n\n\nKoskella, Britt, and Joy Bergelson. 2020. “The Study of Host–Microbiome (Co) Evolution Across Levels of Selection.” Philosophical Transactions of the Royal Society B 375 (1808): 20190604.\n\n\nVan Vliet, Simon, and Michael Doebeli. 2019. “The Role of Multilevel Selection in Host Microbiome Evolution.” Proceedings of the National Academy of Sciences 116 (41): 20591–97.",
    "crumbs": [
      "Mini-projects",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Miniproject: maintaining a healthy microbiome</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "21  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n1 + 1 = 2",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Crombach, Anton, and Paulien Hogeweg. 2008. “Evolution of\nEvolvability in Gene Regulatory Networks.” PLoS Computational\nBiology 4 (7): e1000112.\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.\n\n\nKoskella, Britt, and Joy Bergelson. 2020. “The Study of\nHost–Microbiome (Co) Evolution Across Levels of Selection.”\nPhilosophical Transactions of the Royal Society B 375 (1808):\n20190604.\n\n\nVan Vliet, Simon, and Michael Doebeli. 2019. “The Role of\nMultilevel Selection in Host Microbiome Evolution.”\nProceedings of the National Academy of Sciences 116 (41):\n20591–97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "answers.html",
    "href": "answers.html",
    "title": "Appendix A — Quarto examples",
    "section": "",
    "text": "A.1 Equations\nHere’s an equation:\n\\[\n\\frac{\\mathrm{d}N}{\\mathrm{d}t} = rN(1 - \\frac{N}{K})\n\\tag{A.1}\\]\nAnd Equation A.1 is a reference to the equation above.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Quarto examples</span>"
    ]
  },
  {
    "objectID": "answers.html#references",
    "href": "answers.html#references",
    "title": "Appendix A — Quarto examples",
    "section": "A.2 References",
    "text": "A.2 References\nSee Knuth (1984) for additional discussion of literate programming.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Quarto examples</span>"
    ]
  },
  {
    "objectID": "answers.html#syntax-highlighting",
    "href": "answers.html#syntax-highlighting",
    "title": "Appendix A — Quarto examples",
    "section": "A.3 Syntax highlighting",
    "text": "A.3 Syntax highlighting\nHere’s some python code:\nimport numpy as np\nnp.random.seed(42)\na = 1 + 2\nb = a + 3\nprint(\"Hello\")",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Quarto examples</span>"
    ]
  },
  {
    "objectID": "answers.html#visualising-data-r",
    "href": "answers.html#visualising-data-r",
    "title": "Appendix A — Quarto examples",
    "section": "A.4 Visualising data (R)",
    "text": "A.4 Visualising data (R)\nHere’s an interactive plot generated with R:",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Quarto examples</span>"
    ]
  },
  {
    "objectID": "answers.html#a-youtube-clip",
    "href": "answers.html#a-youtube-clip",
    "title": "Appendix A — Quarto examples",
    "section": "A.5 A youtube clip:",
    "text": "A.5 A youtube clip:",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Quarto examples</span>"
    ]
  },
  {
    "objectID": "answers.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "href": "answers.html#an-iframe-to-a-different-page-e.g.-my-simulations",
    "title": "Appendix A — Quarto examples",
    "section": "A.6 An ‘iframe’ to a different page (e.g. my simulations)",
    "text": "A.6 An ‘iframe’ to a different page (e.g. my simulations)\n\n\nMermaid\nDiagrams (Mermaid syntax):\n\n\n\n\n\n\nflowchart TB\nA(Models) --&gt; C(\"Analytical (mathematical)\")\nA --&gt; B(\"Numerical (computational)\")\nB --&gt; F(Individual-based model)\nB --&gt; G(Cellular automaton)\nC --&gt; E(Differential equation)\nC --&gt; D(MAPs)\n\n\n\n\nFigure A.1: Types of models\n\n\n\n\n\nWhich can be referred to Figure A.1.\n\n\nCallouts\nCall-outs can organise information and highlight important points.\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip with Title\n\n\n\nThis is an example of a callout with a title.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default.\n\n\n\n\n\n\n\n\n\nTip A.1: Cross-Referencing a Tip\n\n\n\nAdd an ID starting with #tip- to reference a tip.\n\n\nSee Tip A.1…\n\n\nHow to format questions/problem sets\n\nExercise A.1 (Test 1) The equation of any straight line, called a linear equation, can be written as:\n\\[\ny = mx + b\n\\tag{A.2}\\]\nRefer to the equation like this Equation A.2 or like Customlabel A.2.\na. Blabla?\nb. Of blablabla?\n\n\n\nSharing data tables:\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Quarto examples</span>"
    ]
  }
]