---
params:
  show_answers: false
---

# Gene regulation in time 

## Introduction

In this practical you will get hands on experience into making gene regulatory networks 
models. First you will practice how to encode regulatory interactions into ordinary 
differential equations and logical rules. Next you will study how many interactions produce
self-sustained activity configurations (attractors) in a Boolean network model. Lastly, you 
will learn how to predict the genes that cause cell fate transitions (attractor changes). 

Today we will use the following python file: `circuitsfunctions.py`.  In it you will find 
the code of the functions we use throughout the practical, have a quick look at it. 

## Regulatory interactions

Open Boolean_practical.py and familiarize yourself with the functions `ODEgeneRegulation()` 
and `logicalRule()`. Look at the name of the functions, inputs and outputs. 

Both functions model an `AND` gate where nodeA and nodeB positively regulate nodeC. This 
could represent that A and B are transcription factors that form a protein complex, and 
that it is via this complex that they can regulate the expression of C. 

While `ODEgeneRegulation()` encodes this regulation with an ordinary differential equation that 
requires several parameters, `logicalRule()` only needs the logical operator relating the input genes. 

**ODE implementation**

$\frac{dC}{dt}=p\frac{A^n}{K^n+A^n}\frac{B^n}{K^n+B^n}-dC$

Where $p$ is the production rate, $K$ is the half saturation constant (represents the affinity of a TF 
to the promoter), $n$ is the cooperativity of transcription factor binding, and is the same for $A$ and 
$B$, $d$ is the decay rate. 

**Logical rule implementation**

$C_{t+1}=A_t$ & $B_t$


**Python code for ODE and logical rule**
```python
def ODEgeneRegulation(a,t,parameters): 
    prod=parameters['prod']
    decay=parameters['decay']
    Ksat=parameters['Ksat']
    nodeA=parameters['nodeA']
    nodeB=parameters['nodeB']
    n=parameters['n']
    outputC=a[0]
    doutputC=prod*nodeA**n/(Ksat**n+nodeA**n)*nodeB**n/(Ksat**n+nodeB**n)-decay*outputC #Tip: Change this in exercise 8.3
    return(doutputC)

def logicalRule(nodeA,nodeB):
    return(nodeA and nodeB)
```

:::{#exr-non}
## Mathematical thinking

What is the minimum information you need to encode a regulatory interaction with either function? In what cases would you prefer to use an ODE or a logical rule for a model?
:::

::: {.content-visible when-meta="params.show_answers"}

  > **Answer** To model a regulatory interaction with a logical function we  need the information of who is
  > regulating who (direction of interactions), and how (effect of interaction); no parameters needed. To 
  > model the same with an ODE we also need several parameters: production rate, decay rate, K, n. 

:::

Let's run the model to simulate what happens if `A` and `B` are both active/expressed. Do this using the
`ODEgeneRegulation()` and `logicalRule()` functions. Create a new python file, import 
`circuitfunctions.py` and copy the following lines of code inside the main().

```python
# ODErun has three arguments: model, geneA, geneB
A=10
B=10
ODErun(ODEgeneRegulation,A,B) 

# Boolean model
# look at the text in the terminal for the result:
A=1
B=1
print("the boolean operation of nodeA ",A," AND nodeB",B," is:", logicalRule(A,B))
```

Both implementations of this regulatory interaction produce the same effect, i.e. `C` is active when both
`A` and `B` are active. Yet, the ODE version recovers quantitative differences in `C` activity with values
higher than 1.

Now, let’s explore the output of each function using different values of `A` and `B` We are going to 
use the code below to plot the output of the ODE and the Boolean model in a 2D heatmap. Notice that the exploration values for the ODE model is 11 values (0,1,2,3,4,5,6,7,8,9,10), while for a Boolean model is 2 (0 or 1). 

ODE model simulation - AND gate:
```python
explorationvalue = 11 # an ODE model allows us to explore more values than a Boolean model
ode_output = np.zeros((explorationvalue, explorationvalue))
for nodeA in range(0, explorationvalue):
    for nodeB in range(0, explorationvalue):
        parameters = {'prod': 0.01, 'decay': 0.001,'Ksat': 4, 'n': 2,'nodeA':nodeA,'nodeB':nodeB} # prod, decay, Ksat, n, and initial values for A and B
        cells = odeint(ODEgeneRegulation, 0, np.arange(0, 1000.1 , 0.1), args=(parameters,)) 
        ode_output[nodeA, nodeB] = cells[-1, 0]
```

Boolean network simulation - AND gate:
```python
explorationvalue=2 # a Boolean model assumes there is only 2 possible states: 0 or 1
bool_output = np.zeros((explorationvalue, explorationvalue))
for nodeA in range(0, explorationvalue):
    for nodeB in range(0, explorationvalue):
        bool_output[nodeA, nodeB] = nodeA and nodeB #AND #Tip: Change this in exercise 8.3
```

After running each, this function plots the ODE and Boolean results side by side:
```python
ODEBooleanPlot(ode_output, bool_output)
```

:::{#exr-non}
## Biology

 What similarties and differences in the activity of $C$ do you see using each approach? Why is the 
 activity of $C$ higher in the ODE output than the Boolean one?
:::

::: {.content-visible when-meta="params.show_answers"}
  > **Answer** In both cases $C$ has maximum activity when both $A$ and $B$ are active/expressed. 
  > Whereas in a Boolean model the activity of the variables can be either 0 or 1, in an ODE the
  > variables can have   > continuous values with the maximum level determined by the production and 
  > the decay rate parameters ($p/d$). This is the reason $C$ has values close to 5 in the ODE output.
  > ![ODE and Boolean output for the logical gate A AND B, for C regulation.](images/odetegenboolean.png){#vegmini1}
:::

:::{#exr-non}

## Altorithmic thinking:

Now let's compare how ODE and Boolean models represent different regulatory interactions. You can use the same code in the previous box. Remember to modify the logical operator in the Boolean section, and to modify the $doutputC$ equation in the `ODEgeneRegulation` function: 


1. Either `A` or `B` can activate `C`. 
2. `A` represses `C`.
3. `A` and `B` together repress `C`. 
4. `A` represses `C` and `B` activates it.
5. `A` or `B` can activate `C`, but not when both are active at the same time. 
6. any other biological scenario yon can think of! 

* See if you can modify the code to include an extra input node, and make a 3-node logical gate. 

:::

::: {.content-visible when-meta="params.show_answers"}
  > **Answer** See `Boolean_answered-8.3.py` to see an implementation of the regulatory interactions listed
  > above. 
  > 
  > 1. $OR$ gate: **A** $OR$ **B**
  > ![](images/0-or.png){#vegmini1}  
  >
  > 2. $NOT$ gate: $NOT$ **A**
  > ![](images/0-not.png){#vegmini1}  
  > 
  > 3. combination of $NOT$ and $AND$ gate: $NOT$ **A** $AND$ $NOT$ **B**
  > ![](images/0-notAND.png){#vegmini1}  
  > 
  > looks quite different if it is an $OR$ gate:  $NOT$ **A** $OR$ $NOT$ **B**
  > 
  > ![](images/0-notOR.png){#vegmini1}  
  >
  > 4. There are two possibilities because it is not specified which interaction is 
  > "stronger". Here we show when A is stronger. Option 1: $NOT$ **A** $AND$ **B**. 
  > 
  > ![](images/0-NOTA,B.png){#vegmini1}  
  > 
  > 5. $XOR$ gate (**A** $XOR$ **B**), meaning either but not both at the same time. 
  > ![](images/0-XOR.png){#vegmini1}  

:::

:::{#exr-non}


## Biology and Algorithmic thinking

Is there a logical gate that can be better represented with an ODE than with Boolean logic? Give an  
examples of biological regulatory interactions that can be described with each logical gate? 

:::

:::{.content-visible when-meta="params.show_answers"}

  > **Answer** All logical gates can be modelled correctly with either approach. With Boolean models 
  > we look quantitative resolution, with ODE we can model many more values than 0 and 1. 
  > 
  > Biological examples that can be modelled with the logical gates: 
  > 
  > - $AND$ gate can be that both genes code for transcription factors that form a protein complex that 
  > binds a promoter to regulate gene expression of $X$. It can also represent that one regulator 
  > promotes the expression of $X$, while the other phosphorylates protein $X$. As the phosphorylated
  > $X$ is the active form, both regulatory interactions are needed ($AND$). 
  > 
  > - $OR$ is that either TF can bind promoter and activate transcription. 
  > 
  > - $NOT$ is that a TF blocks the promoter so that activating TF cannot bind.
  > 
  > - $NOT$ **A** $AND$ $NOT$ **B** is that both TFs are repressors of the same gene. 
  > 
  > - $NOT$ **A** $AND$ **B** is that A is a repressor and B is an activator. 
  > 
  > - $XOR$ gate can be a promoter where either A or B can bind, the complex AB cannot bind. 


:::
## Gene regulatory network

Now let's move to a network model made of many individual regulatory interactions (@garcia2020system). 
This model includes regulatory interactions discovered for the cells of plant roots in years
of experimental research. Here, all this knowledge is encoded as logical rules. 

The model consists of 18 variables representing transcription factors, hormones, peptides. Look at the
`rootNetwork()` function in the `circuitFunctions.py` file. This function defines the state of 18 variables
(CK, ARR1, SHY2, AUXIAAR, etc.) based on an input stored in `parameters`, then it updates the state of each 
variable using the logical operators $AND$, $OR$ and $NOT$; the result is stored in `w_variable`. The function returns the update state `w_variable` for each of the 18 variables.  

### Initial condition timecourse
Let us define a random initial condition for each of these 18 variables , and the total number of timesteps 
we will solve the network using the logical functions. First, we need to input the initial condition of the 
variables to `rootNetwork()` using `parameters`. Next, we save the output of this function as the new current 
state. We repeat this procedure iteratively for as many timesteps as we defined, saving in a matrix the 
timecourse of the simulation. This can be done using a for loop as shown below: 

```python
timesteps=20
variables=18
matrix = np.zeros((timesteps+1, variables), dtype=int) 
matrix[0,:] = np.random.randint(0, 2, size=variables) #Random initial condition
for i in range(timesteps):
    parameters= {'CK': matrix[i,0], 'ARR1': matrix[i,1], 'SHY2': matrix[i,2], 'AUXIAAR': matrix[i,3], 'ARFR': matrix[i,4], 'ARF10': matrix[i,5], 'ARF5': matrix[i,6], 'XAL1': matrix[i,7], 'PLT': matrix[i,8], 'AUX': matrix[i,9], 'SCR': matrix[i,10], 'SHR': matrix[i,11], 'MIR165': matrix[i,12], 'PHB': matrix[i,13], 'JKD': matrix[i,14], 'MGP': matrix[i,15], 'WOX5': matrix[i,16], 'CLE40': matrix[i,17]}
    
    matrix[i+1, :] = rootNetwork(parameters) # we save the output in i+1

plotBooleanTimecourse(matrix,timesteps)
```

At the end the function `plotBooleanTimecourse()` will make a plot to see how each variable in the network 
changes ts activity throughout the simulated timesteps. 100 timesteps is enough to reach an attractor for 
this network. 

:::{.content-visible when-meta="params.show_answers"}

  > ![Timecourse simulations](images/0-timecourse.png){#vegmini1}

:::

* For the initial condition you can also use that of one of the attractors reported in the paper and check 
what happens when you update them.


:::{#exr-non}

## Algorithmic thinking
Try this initial condition: 

```python
matrix[0,:]=[0,1,1,0,1,1,0,0,1,0,1,1,1,1,1,0,1,0]
```

Solve this initial condition using `rootNetwork()` and `rootNetworkAsynchronous()`. Compare the output in 
each case. What happens and why? What does an asynchronous update do?
:::

:::{.content-visible when-meta="params.show_answers"}

  > **Answer** The asynchronous updating function introduces a probability of update (95%) to each node in 
  > the simulation. This means the nodes might not be all updated each timestep. The initial condition 
  > converges to a cyclic attractor in the synchronous updating function (`rootNetwork()`), and to a fixed
  > point attractor in the asynchronous function (`rootNetworkAsynchronous()`). This means the cyclic 
  > behaviour recovered with the synchronous updating scheme was an artifact of updating all the nodes at 
  > the same time. 

:::

This network has 18 variables, and then $2^{18}$ = 262,144 possible states. We can solve each of 
these conditions, or instead explore just a subset of them. 

:::{#exr-non}

## Algorithmic thinking
Using the previous code, add for loop to solve 100 random initial conditions, and then save the final activity
configurations (attractors) in the attractors matrix. The attractors matrix should have the dimensions  
(initial_conditions, variables) so that you can plot the results using the `plotBooleanAttractors()` function. 

* Notice here you should save the final state for each initial condition you explore. 

* tip: 100 initial conditions is a good number to explore. 


```python
ICs=100
attractors = np.zeros((ICs, len(parameters))) 

# your code

plotBooleanAttractors(attractors) # it takes as argument a matrix of attractors
```
:::

:::{.content-visible when-meta="params.show_answers"}

  > **Answer** See `Boolean_answered-8.6.py` to see an implementation of this for loop.
  > 
  > ![Attractors reached by 100 random initial conditions](images/0-100ic.png){#vegmini1}

:::

You probably found many different attractors. First, let's use a multidimensional reduction technique to 
see how these attractors relate to each other.

```python
UMAPBoolean(attractors)
```

:::{#exr-non}

## Biology / Conceptual thinking
**Q5** Why do you see clearly defined groups and not a continuous distribution of attractors? 
:::

:::{.content-visible when-meta="params.show_answers"}

  > **Answer** We see clearly defined groups because we are doing the UMAP with the cells that have 
  > already reached an attractor, and not while they are in their trajectory towards the attractor. 
  >
  > ![Timecourse simulation: state of the variables (columns) through simulated time (rows).](images/UMAP-10kcells.png){#vegmini1}

:::

Now let's analyse the attractors you found. First, let's group similar attractors using the 
`sorted()` function:

```python
attractors_sorted = np.array(sorted(attractors.tolist()))
plotBooleanAttractors(attractors_sorted) 
```
:::{.content-visible when-meta="params.show_answers"}

  > ![Attractors reached by 100 random initial conditions - clustered](images/0-clustered_attractors.png){#vegmini1}

:::

:::{#exr-non}

## Biology / Conceptual thinking
**Q6** Do some attractors occur more frequently than others. Why is this? 
:::

:::{.content-visible when-meta="params.show_answers"}

  > **Answer** Yes, some attractors occur more often than others, and this is a consequence of the 
  > regulatory interactions of the model. The number of initial conditions that reached a specific attractor 
  > is a reflection of the size of their basin of attraction. The basins of attraction (all 
  > variable configurations  that converge to an attractor) are shaped by the AND, OR, and NOT gates in 
  > each of the modelled variables. Imagine cells are like marbles moving through a landscape, such that 
  > the regulatory interactions define the “rolling” direction, until eventually they land in different 
  > basins of attraction as they acquire different cell states. Here the landscape is multidimensional 
  > (as many dimensions as variables in the model, so 18). 

:::

:::{#exr-non}

## Biology
Some variables are active (1) in the majority of the attractors, others in half, and others in very few. 
In how many attractors is the node SHR active? What does this suggest about its regulation?
:::

:::{.content-visible when-meta="params.show_answers"}

  > **Answer** How often a variable is active in the attractors, is defined by their logical rules. For
  > example, SHR logical rule is SHR = SHR. This means that SHR is an input node, that is not regulated by 
  > any other node. This splits the state space perfectly in two halves: one with SHR active and another 
  > with SHR inactive. You can implement this in `Boolean_answered-8.3.py` to visualize this split. 
  >
  > ![SHR activity regulated by itself (variable A)](images/0-SHR.png){#vegmini1}

:::

Now let's remove the repeated rows (duplicate attractor states) to see unique attractors using the 
`np.unique()` function: 

```python
_, unique_indices = np.unique(attractors, axis=0, return_index=True)
attractors_unique = attractors[np.sort(unique_indices)]
plotBooleanAttractors(attractors_unique) 
```

:::{.content-visible when-meta="params.show_answers"}

  > ![Unique attractors reached by random 100 initial conditions](images/0-unique_attractors.png){#vegmini1}

:::
:::{#exr-non}

## Biology / conceptual thinking
How many unique attractors did you find? Compare them with the ones reported in the paper. Are they all fixed points? 
:::

:::{.content-visible when-meta="params.show_answers"}

  > **Answer** This depends on how many initial conditions you test. The more initial conditions, the 
  > more likely you will find the maximum of 6 fixed point attractors this model can produce. 

:::

## Cell differentiation – jumping from one attractor to another

Depending on what we want to answer a continuous or discrete model may be more appropriate for a model. To study the role of many genes in cell differentiation, a Boolean model might be better particularly if we lack details of the parameters underlying each reaction. If we want to study how cells jump from one state to another, a continuous model might be more appropriate. 

Here we will see how we can convert the Boolean model to a continuous one and use it to predict which regulators are able of causing a change in the state of the system (changes in cell fate!)

Compare the code of the functions rootNetwork() and rootNetworkODE(). Notice how in rootNetworkODE() the logical rules are represented with min and max functions, and then used in a sigmoidal function to create a continuous ODE model. 
* AND operator is a min function, OR operator is a max function, and NOT operator is 1-x. Use the code below to run a random initial condition for the 18 variables (IC) and see how the system behaves.

```python
timerunning=10.1 
times = np.arange(0, timerunning, 0.1)

IC = np.random.randint(0, 2, size=18).tolist() #random initial condition
parameters = {'decayrate': 1, 'h': 50} 
cells = odeint(rootNetworkODE, IC, times, args=(parameters,)) 

plotODEroot(cells,times)
```

:::{#exr-non}

## Modeling choices
Do the attractors match those recovered with the Boolean network?
:::
:::{.content-visible when-meta="params.show_answers"}

  > **Answer** Yes. The ODE model is built with the same regulatory interactions from the Boolean model. 
  > The difference is that this model allows us to describe quantitative differences in the activity of the nodes. 

:::

Now let’s use the model to study cell differentiation. Let’s start in the following initial condition (IC vector), and find a change in a node that produce a jump to another attractor (end). For this you can simply flip the activity of a gene in the initial condition (from 0 ->1 or 1->0) and see the final attractor matches the desired end state. 

```python
# We start here: 
IC=[0,0,0,0,1,0,1,1,1,1,1,1,1,0,1,0,1,0]
# We want to end here. 
end=[1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,0,0,1]
# node order
# CK, ARR1, SHY2, AUXIAAR, ARFR, ARF10, ARF5, XAL1, PLT, AUX, SCR, SHR, MIR165, PHB, JKD, MGP, WOX5, CLE40

# your code 

plotODErootTransition(cells,times) # use this function to plot your result
```

:::{#exr-non}

## Algorithmic thinking / biology
What regulator causes the transition between these attractors? How many variables change their activity between the 
initial and final state? what could be the biological meaning of this switch? how would you test this experimentally?
:::

:::{.content-visible when-meta="params.show_answers"}

  > **Answer** SHR OFF (0) causes the transition between the specified activity configurations. We can interpret this
  > change between attractors as a cell fate change, in which the decrease in SHR activity triggers changes in other 
  > nodes of the network resulting in the differentiation of the cells. SHR could be a cell differentiation signal. 
  > To test this experimentally we can artificially repress SHR in the cells.

:::

:::{#exr-non}

## Biology
Finally, use the model to predict the rest of the attractor transitions because of single node changes. Are all attractor transitions possible, or are there preferred differentiation routes?
:::

:::{.content-visible when-meta="params.show_answers"}

  > **Answer** Not all attractor transitions are possible by single node changes. This is because the regulatory
  > interactions in the model constrain how this perturbation is interpreted, and with it the differentiation 
  > trajectories.

:::