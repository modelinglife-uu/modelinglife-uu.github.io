[
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "2  Schedule",
    "section": "",
    "text": "WEEK 1\nNov 10, 2025 – Welcome and Intro to Python (HC 13:15-17:00).\nNov 11, 2025 – Pattern formation I: Gradients and segments (HC 10:00-12:45 and WC1 13:15-17:00).\nNov 13, 2025 – Pattern formation II: Turing Digit patterning (HC 10:00-12:45 and WC2 13:15-17:00).",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Schedule</span>"
    ]
  },
  {
    "objectID": "schedule.html#week-2",
    "href": "schedule.html#week-2",
    "title": "2  Schedule",
    "section": "WEEK 2",
    "text": "WEEK 2\nNov 17, 2025 – Guest lecture: Max Rietkerk, Ecosystem’s spatial patterns (HC 13:15-17:00).\nNov 18, 2025 – Pattern formation III: Clock and Wavefront (HC 10:00-12:45 and WC3 13:15-17:00).\nNov 20, 2025 – Morphogenesis: Cell sorting (HC 10:00-12:45 and WC4 13:15-17:00).",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Schedule</span>"
    ]
  },
  {
    "objectID": "schedule.html#week-3",
    "href": "schedule.html#week-3",
    "title": "2  Schedule",
    "section": "WEEK 3",
    "text": "WEEK 3\nNov 24, 2025 – Guest lecture: Ina Sonnen, Signal encoding in multicellular systems (HC 13:15-17:00).\nNov 25, 2025 – Cell differentiation: gene regulation in time (HC 10:00-12:45 and WC5 13:15-17:00).\nNov 27, 2025 – Cell differentiation: gene regulation in space (HC 10:00-12:45 and WC6 13:15-17:00).",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Schedule</span>"
    ]
  },
  {
    "objectID": "schedule.html#week-4",
    "href": "schedule.html#week-4",
    "title": "2  Schedule",
    "section": "WEEK 4",
    "text": "WEEK 4\nDec 1, 2025 – Guest lectures: Vivek Bhardwak and Kaisa Kajala, What is a cell type? genomic and functional perspectives (HC 13:15-17:00).\nDec 2, 2025 – Environment and Development (HC 10:00-12:45 and WC7 13:15-17:00).\nDec 4, 2025 – Evolving populations I: Sticky cells (HC 10:00-12:45 and WC8 13:15-17:00).",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Schedule</span>"
    ]
  },
  {
    "objectID": "schedule.html#week-5",
    "href": "schedule.html#week-5",
    "title": "2  Schedule",
    "section": "WEEK 5",
    "text": "WEEK 5\nDec 8, 2025 – Guest lecture: Rutger Hermsen (HC 13:15-17:00).\nDec 9, 2025 - Evolving populations II: Genotype-phenotype map (HC 10:00-12:45 and WC9 13:15-17:00).\nDec 11, 2025 - Evolving populations III: Microbial communities (HC 10:00-12:45 and WC10 13:15-17:00).",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Schedule</span>"
    ]
  },
  {
    "objectID": "schedule.html#week-6-self-study-and-exam",
    "href": "schedule.html#week-6-self-study-and-exam",
    "title": "2  Schedule",
    "section": "WEEK 6 (self-study and exam)",
    "text": "WEEK 6 (self-study and exam)\nDec 18, 2025 –Exam",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Schedule</span>"
    ]
  },
  {
    "objectID": "schedule.html#week-7-9-mini-projects",
    "href": "schedule.html#week-7-9-mini-projects",
    "title": "2  Schedule",
    "section": "WEEK 7-9 (mini projects)",
    "text": "WEEK 7-9 (mini projects)\nJan 6, 2026 - Miniprojects presentation and making teams\nFollowing weeks you will have classrooms to work on your miniprojects (13:15-17:00). Also, you should schedule meetings with your supervisor to discuss progress of your miniproject.",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Schedule</span>"
    ]
  },
  {
    "objectID": "schedule.html#week-10-mini-symposium",
    "href": "schedule.html#week-10-mini-symposium",
    "title": "2  Schedule",
    "section": "WEEK 10 (mini symposium)",
    "text": "WEEK 10 (mini symposium)\nJan 29, 2026 - Miniprojects final presentation",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Schedule</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Modeling Life",
    "section": "",
    "text": "Modeling life\nThis website accompanies the Modeling Life course at Utrecht University. It primarily serves as a central hub for all the practicals (werkcolleges), with the necessarily files, links and other resources for each day.\nEach practical has its own page containing background explanations, code snippets, and questions that are designed for you to learn about the models. Most of these exercises build directly on the lectures, allowing you to explore biological questions—such as how morphogen gradients form, how spatial patterns emerge, or how cells evolve to “stick together”.\nYou can navigate the site using the sidebar or the left. The General Course Info section outlines the general course info (exams, learning goals, etc.). You can also find the Schedule on this website. The individual practicals sections provides detailed instructions for each day. In the second part of the course you will get even more experience doing things yourself by working on a mini-project.\nWe hope you’ll use this website actively. There’s lots to read, simulate, modify, and explore.\n\nNote: the Modeling Life course is new. This website is to help you, but is by no means perfect. Please let us know if you see any mistakes, typo’s or other issues. Any constructive feedback on how to make things better and easier for you is always welcome.",
    "crumbs": [
      "Course information",
      "Modeling life"
    ]
  },
  {
    "objectID": "general.html",
    "href": "general.html",
    "title": "1  General course info",
    "section": "",
    "text": "Our names, email addresses, an overview of the course content, learning goals, tips, grading, group formation, usage of Brightspace, materials they need, required attendencee, and feedback is welcome blabla.",
    "crumbs": [
      "Course information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>General course info</span>"
    ]
  },
  {
    "objectID": "pattern_intro_text.html",
    "href": "pattern_intro_text.html",
    "title": "3  Introduction",
    "section": "",
    "text": "TODO\n\nWrite a short intro on pattern formation part of the practicals.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html",
    "href": "pattern_practical_1.html",
    "title": "4  Pattern formation I  Gradients and segments",
    "section": "",
    "text": "4.1 Morphogen Gradients and Patterning\nIn this practical, we a going to look at how an organism can form segments along its body axis . The mathematical model that we will implement and study is an implementation of the so-called French flag conceptual model first proposed by Lewis Wolpert (Wolpert 1969). It assumes the spatially graded expression of a morphogen “M” that influences the expression of some downstream genes A, B and C. Their expression is often visualized by red, white and blue and the arising pattern resembles the French flag, hence the name (see the power of visualization).\nOne of the most well-studied organisms when it comes to body axis segmentation (although its segmentation mechanism is evolutionary derived and a-typical!) is the development of the fruit fly Drosophila melanogaster. Supporting the ideas of Wolpert, it was found that through tethering maternal Bicoid mRNA to one side of the embryo, Bicoid protein can form a gradient extending along the anterior-posterior axis, with so called gap genes as a first tier in the segmentation hierarchy differentially responding to different Bicoid protein levels (Driever and Nüsslein-Volhard 1988). Later it was found that often at least two opposing morphogen gradients drive downstream gene expression and genes typically respond to multiple inputs.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pattern formation I <br> Gradients and segments</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#mathematical-modeling---integrating-multiple-signals",
    "href": "pattern_practical_1.html#mathematical-modeling---integrating-multiple-signals",
    "title": "4  Pattern formation I  Gradients and segments",
    "section": "4.2 Mathematical modeling - integrating multiple signals",
    "text": "4.2 Mathematical modeling - integrating multiple signals\nPromotors/enhancers driving gene expression frequently make use of so called OR and AND gates to integrate inputs from different transcription factors. An OR gate can be implemented mathematically with a sum of the effect of the transcription factors, while an AND can be implemented mathematically with a product. Some examples:\n\n\\(\\frac{dX}{dt} = a(\\text{tf1}) + b(\\text{tf2})\\): Gene X is induced by transcription factor 1 and 2 in an OR fashion, either \\(a(\\text{tf1})\\) or \\(b(\\text{tf2})\\) needs to be high to give high transcription of X.\n\\(\\frac{dY}{dt} = a(\\text{tf1})\\cdot b(\\text{tf2})\\): Gene Y is induced by transcription factor 1 and 2 in an AND fashion, both \\(a(\\text{tf1})\\) and \\(b(\\text{tf2})\\), which are being multiplied, need to be high to give high transcription of X.\n\nNote that the shape of \\(a(\\text{tf1})\\) and \\(b(\\text{tf2})\\) (increasing or decreasing function of the transcription factor) determines whether tf1 and tf2 are repressing or activating.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pattern formation I <br> Gradients and segments</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#python-code",
    "href": "pattern_practical_1.html#python-code",
    "title": "4  Pattern formation I  Gradients and segments",
    "section": "4.3 Python code",
    "text": "4.3 Python code\n\n\n\n\n\n\nStarting code for this practical\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nLx = 40.0  # Length of the domain in x in microm\nLy = 10.0  # Length of the domain in y in microm\nT = 200  # Total time in seconds\ndx = 0.5  # Grid spacing in x\ndt = 0.1  # Time step\nnx = int(Lx/dx)+2  # Number of grid points in x + padding grid points\nny = int(Ly/dx)+2  # Number of grid points in y + padding grid points\n# Padding grid points to account for boundary conditions\nnt = int(T/dt)  # Number of time steps\nD = 0.4  # Diffusion coefficient in mm^2/s\ndecayM =0.01 # Decay rate in 1/s\n\n\n# Parameters for A, B, C\n... # TODO create parameters for A, B, C as needed in Q5\n\n# Stability criterion\nif D * dt / dx**2 &gt; 0.5:\n    raise ValueError(\"Stability criterion not met\")\n\n# A, B and C are required for later exercises.\nA = np.zeros((nx, ny))\nB = np.zeros((nx, ny))\nC = np.zeros((nx, ny))\n\n# Initial condition\nu = np.zeros((nx, ny))\nu[0, :] = 100\n\n# Reaction-diffusion equation\ndef reaction_diffusion_step(u, D, dt, dx, decay):\n    un = u.copy()\n    u[1:-1, 1:-1] = un[1:-1, 1:-1] +  D *dt / dx**2 * (un[2:, 1:-1] + un[:-2, 1:-1] + \\\n                    un[1:-1, 2:]  + un[1:-1, :-2] - 4 * un[1:-1, 1:-1]) - \\\n                    decay * un[1:-1, 1:-1] * dt\n    ## for loop version to understand the equation\n    # for i in range(1, nx-1):\n    #     for j in range(1, ny-1):\n    #         u[i, j] = (un[i, j] +\n    #                    D * dt / dx**2 * (un[i+1, j] + un[i-1, j] - 2 * un[i, j] +\n    #                    un[i, j+1] + un[i, j-1] - 4 * un[i, j]) - decay * un[i, j] * dt)\n    #boundary conditions\n    u[-1, :] = (u[-2, :]/u[-3, :])*u[-2, :]  if sum(u[-3, :]) != 0 else np.zeros(ny)\n    #to understand this line:\n    #if sum(u[-3, :]) != 0:\n    #    u[-1, :] = (u[-2, :]/u[-3, :])*u[-2, :]#extrapolate from third to last row\n    #else:\n    #    u[-1, :] = np.zeros(ny) #if already zero in third to last row, also zero in last row\n    u[:, 0] = u[:, 1]\n    u[:, -1] = u[:, -2]\n\n    return u\n\ndef reaction_diffusion_gradient(t, u, D, dx, decay, switch_time = None, noise = False):\n    '''\n    Function to create a gradient in the u array that could decay after a certain time.\n    t: current time step\n    u: array to create the gradient in\n    D: diffusion coefficient\n    dx: grid spacing\n    decay: decay rate\n    switch_time: time step after which the gradient decays. If no switch is desired, set to None\n    noise: whether to add noise to the gradient\n    '''\n    # TODO for student: write code for the noise and the switch.\n    added_noise = np.zeros_like(u)  # Initialize noise array\n    if noise:\n        ...  # TODO: add noise generation code here for Q10\n    \n    if switch_time is None or t &lt;= switch_time:\n        # define a exponential decay gradient over the array in the x direction with numpy array operations using the index\n        for i in range(u.shape[0]):\n            u[i, :] = np.maximum(100 * np.exp(-i*dx/np.sqrt(D/decay))+added_noise[i, :], 0)\n        return u\n    if t &gt; switch_time:\n        ...# TODO Q7: implement a gradient that decays over time, otherwise return the original u array\n        return u\n    # In all other cases, return the original u array        \n    return u\n\ndef hill(x, Km, pow):\n    \"\"\"Hill function for the reaction kinetics.\"\"\"\n    return (x**pow) / (Km**pow + x**pow) \n\ndef ihill(y, Km, pow):\n    \"\"\"Inverse Hill function for the reaction kinetics.\"\"\"\n    return( (Km**pow) / (y **pow  + Km**pow))\n\n# TODO for student: write update functions for A, B, C as needed in Q5\n\n\n# initilize figure and axes for plotting\n# TODO for student: Add a new axis for the ABC flag visualization as suggested in Q5\nfig, (ax_M, ax_lines) = plt.subplots(2, figsize=(10, 8), gridspec_kw={'height_ratios': [3, 1]})  # Make the first graph 3 times the height of the second\n\n# Time-stepping simulation loop\nfor n in range(nt):\n    # Update all variables\n    u = reaction_diffusion_step(u, D, dt, dx, decayM)\n    # TODO for student: use precomputed gradient, update A, B, C as needed in Q5\n    \n    if n == 0:  # Initial plot\n        imshow_M_plot = ax_M.imshow(u.T, cmap='viridis', origin='lower', aspect='auto')\n        ax_M.set_title(f\"Time: {n*dt}\")\n        ax_M.set_xlabel('x direction')\n        ax_M.set_ylabel('y direction')\n        ax_M.set_xticks([])\n        ax_M.set_yticks([])\n\n        # Plot the concentration at a specific y index (e.g., y=2)    \n        line_plot = ax_lines.plot([x*dx for x in range(nx)], u[:, 2], label='M', color='green')\n        # TODO: Add lines for A, B, C as needed in Q5\n\n        \n        ax_lines.legend(loc='upper right')\n        ax_lines.set_ylim(0, 100)\n        ax_lines.tick_params(axis='y')\n        ax_lines.set_xlim(0, dx*nx)\n        ax_lines.set_xlabel('x')\n        ax_lines.set_ylabel('Concentration at y=2')\n        ax_lines.tick_params(axis='x')\n\n    if n % 20 == 0:  # Update plot every so many time steps\n        #update the imshow M plot with the new data\n        imshow_M_plot.set_data(u.T)\n        ax_M.set_title(f\"Time: {n*dt}\")\n            \n        # Update the line plots with new data\n        line_plot[0].set_ydata(u[:, 2])\n        # TODO: Update A, B, C line plots as needed in Q5\n\n    plt.pause(0.001)  # Pause to refresh the plot\n\n# And keep the last plot open\n# plt.show()\n\n# Or close the plot window when done\nplt.close(fig)",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pattern formation I <br> Gradients and segments</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#questions",
    "href": "pattern_practical_1.html#questions",
    "title": "4  Pattern formation I  Gradients and segments",
    "section": "4.4 Questions",
    "text": "4.4 Questions\n\nExercise 4.1 (Algorithmic thinking) Have a look at the reaction-diffusion equation for the morphogen and the implementation of it in the file morphogengradient_to_segments.py in the reaction_diffusion_step function, as well as at the initialization of the array u. How is this different from the gradient formation modeling we discussed during the lecture? What is done at the terminal boundary in the length direction and why does this make sense? (hint: outcommented we provided code doing essentially the same but not using numpy arrays and hence written in a less compact matter to help you understand what is happening)\n\n\nExercise 4.2 (Important concept) Play with the morphogen diffusion rate and the morphogen decay rate and describe what happens. What happens in terms of dynamics and steady state if you change both, but the ratio stays the same? Hint: it might help to draw a horizontal line at a certain height to ease comparison.\n\n\nExercise 4.3 (Biology & mathematical thinking) Next, we are going to introduce the genes A, B and C in the model. We want these genes to be expressed dependent on M, and in the head, trunk and tail respectively, so A on the left, B in the middle and C on the right. Think of what conditions in terms of M should lead to expression of A/B/C. What Hill functions (normal/inverse/any combination) corresponds to those conditions? Write down (pen and paper, not in code) full equations for the genes, do we need any other terms than just Hill functions, would we need specific parameter conditions?\n\n\nExercise 4.4 (Biology & algorithmic/mathematical thinking) From hereon we assume that the morphogen gradient reaches steady state very quickly, and no longer use the numerical implementation of the diffusion equation and instead work with a superimposed morphogen profile defined by reaction_diffusion_gradient to save time. (Hint: to not call the function any more use # in front of where it is called) Change the simulation loop such that it computes the morphogen gradient once. What type of function is the superimposed morphogen profile and how does this relate to question 2.\n\n\nExercise 4.5 (Biology & algorithmic/mathematical thinking)  \n\nNow create functions to update A, B and C according to your equations from the previous question. You may use the predefined hill and ihill functions that are provided in the code. For simplicity, you may keep most of the parameters the same across genes, but some have to be different to ensure the right location of the genes (see your reasoning to the previous question). (Hint: using array properties to update A/B/C, like in the reaction_diffusion_step function, makes your code run a lot faster than using for-loops)\nAlso make sure that the levels of A, B and C are updated in the simulation loop. (Hint: using array properties to update A/B/C, like in the reaction_diffusion_step function, makes your code run a lot faster than using for-loops)\nNext, ensure A, B and C are visualized in the bottom plot axis (copy and adapt the code for the visualization of M). You can add an extra third axis to the plot to visualize the (French) flag pattern, by getting which of the three genes is maximal at each location with np.argmax(np.array([A, B, C]), axis=0)and turning that into an array of RGB colors of choice.\nDo you get the expected “French flag” pattern? If not, think of why not and improve your equations from previous question, parameters or your code.\n\n\n\nExercise 4.6 (Biology) At some point in development, the morphogen gradient will disappear, for example in the case of the Drosophila Bicoid gradient because the maternal mRNA is degraded. Predict what will happen to the expression of A,B and C (and hence the French flag pattern) if the morphogen gradient disappears over time and assume A, B, and C are regulated by our equations (first try think about this without actually simulating this).\n\n\nExercise 4.7 (Algorithmic/mathematical thinking) Now write the code in reaction_diffusion_gradient that updates the morphogen concentration, such that after the time point A, B and C have gotten close to equilibrium, the morphogen gradient gradually disappears. Adapt the simulation loop where necessary and run your code: was your prediction on A/B/C from the previous question correct? Why/why not? Hint: you might need to increase the duration of your simulation, especially if it takes a long time for A, B and C to reach equilibrium (or you can change the parameters to speed things up by using same production/degradation rate ratio yet higher absolute values of the individual parameters).\n\n\nExercise 4.8 (Biological & mathematical thinking) A, B and C cannot remain in a stable pattern if they are only influenced by M. How can we stabilize the pattern in absence of M? Test your ideas by creating new update functions for A, B and C and let these new ‘rules’ kick in at the same time when M starts to decline. Again, you may find Hill functions useful and perhaps also the before/after switch time structure used in reaction_diffusion_gradient for M. (Hint: think about how the genes should affect each other, and assume that in this new phase, when genes have already been initialized in absence of repression the genes will be expressed). Can you maintain the expression domains of A, B and C and does their shape change?\n\n\nExercise 4.9 (Biology & algorithmic/mathematical thinking) A sudden switch from phase 1 (stable M gradient) to phase 2 (decaying M gradient) resulting in the genes following different differential equations is biologically implausible. In reality, genes have complex promotors and enhancers integrating different inputs that arise in different developmental stages. Try to come up with one integrated expression for each gene, incorporating simultaneous input from the morphogen gradient and the other genes. Create new update functions for A/B/C and test your ideas. Can you get a stable pattern before and after the decline in M? A couple of things you could consider: a. Think of how positively and negatively M regulated expression behave once the gradient starts declining: what is the best way to combine (AND/OR) that with the regulation by the genes? a. Consider splitting up the M regulated expression of middle gene B into a positive and negatively regulated morphogen part before integrating the other genes inputs. a. It is also possible to give certain genes a bit of a constant boost to prevent their takeover by other genes due to timing issues\n\n\nExercise 4.10 (Biology & algorithmic/mathematical thinking) Write code to get noise in the morphogen gradient, both in its steady state and decaying phase. During which phase do the expression domains of A, B and C suffer more from the noise. Explain why? How could we make the system more robust in a manner that is also likely occurring in nature?",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pattern formation I <br> Gradients and segments</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#extra-questions",
    "href": "pattern_practical_1.html#extra-questions",
    "title": "4  Pattern formation I  Gradients and segments",
    "section": "4.5 Extra questions",
    "text": "4.5 Extra questions\nIf you’re done early or a master student, you can make these extra questions. These questions need not be made in the order they are provided, you can choose what you would like to investigate.\n\nExercise 4.11 (Biological thinking) Play with the size of the domain to see what happens to the gene expression domains. What would this mean for an organism?\n\n\nExercise 4.12 (Biological & algorithmic thinking) Various mechanisms have been proposed to ensure that the domains of the morphogen controlled genes scale with the size of the domain. One proposed mechanism suggests the existence of an also diffusible “expander” molecule which expression is repressed by the morphogen but which itself either represses the degradation of the morphogen or enhances its diffusion (see e.g. https://www.pnas.org/doi/full/10.1073/pnas.0912734107 and https://onlinelibrary.wiley.com/doi/10.1111/dgd.12337).\nFor the expander we can write:\n\\[\n∂E/∂t=p K^h/(K^h+M^h )-dE+D_E ∆E\n\\]\nAssume E reduces degradation of M (easier to implement than enhancement of diffusion) and study the effect of scaling. (Hint, vary the size of the domain in the length direction but plot domains as a function of relative instead of absolute domain size to compare domain sizes).\n\n\nExercise 4.13 (Algorithmic thinking) In b, we can also implement other boundary conditions, especially for the right boundary. What happens to the profile if we make a no-flux boundary by copying the value at n-2 to n-1? And what if we set it to a sink (force concentration to zero)?\n\n\nExercise 4.14 (Algorithmic thinking) From question 4 onwards, how do things change if we do not assume a quasi-steady-state for the morphogen gradient (i.e. keep the morphogen dynamics instead of replacing it by the superimposed exponential)? How would you implement a disappearing gradient and how does it shape change the outcomes of the flag?\n\n\nExercise 4.15 (Algorithmic thinking) Implement your solution to make the system more robust for noise from question 10. Did it work?",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pattern formation I <br> Gradients and segments</span>"
    ]
  },
  {
    "objectID": "pattern_practical_1.html#relevant-literature-further-reading",
    "href": "pattern_practical_1.html#relevant-literature-further-reading",
    "title": "4  Pattern formation I  Gradients and segments",
    "section": "4.6 Relevant literature / further reading",
    "text": "4.6 Relevant literature / further reading\nhttps://www.nature.com/articles/ncomms6077\nDagmar Iber group, scaling from non-steady state dynamics and uniform growth\nhttps://pmc.ncbi.nlm.nih.gov/articles/PMC3109599/\nhttps://www.nature.com/articles/ncomms7679\nBicoid gradient: larger eggs get more Bicoid mRNA so higher production rate, when it scales with volume this helps scale the gradient\nhttps://onlinelibrary.wiley.com/doi/10.1111/dgd.12337\nhttps://www.pnas.org/doi/abs/10.1073/pnas.0912734107\nExpansion repression model\nChordin, Bmp, Sizzled\nChordin represses Bmp which induces Sizzled (which has low decay rate), yet Sizzled reduces Chordin decay\nChordin is morphogen\nSizzled is expander (by reducing decay of morphogen)\n\n\n\n\nDriever, Wolfgang, and Christiane Nüsslein-Volhard. 1988. “The Bicoid Protein Determines Position in the Drosophila Embryo in a Concentration-Dependent Manner.” Cell 54 (1): 95–104.\n\n\nWolpert, Lewis. 1969. “Positional Information and the Spatial Pattern of Cellular Differentiation.” Journal of Theoretical Biology 25 (1): 1–47.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pattern formation I <br> Gradients and segments</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html",
    "href": "pattern_practical_2.html",
    "title": "5  Pattern formation II  Turing digit patterns",
    "section": "",
    "text": "A foundational work in Theoretical Biology is Alan Turing’s paper “The Chemical Basis of Morphogenesis” [1]. In this work, Turing mathematically demonstrates a plausible mechanism whereby a reaction-diffusion system can lead to the formation of a spatially-patterned solution in steady state. Mathematically and conceptually, Turing’s key innovation was considering diffusion-driven instability. That is: An unpatterned steady state solution becomes unstable in the presence of diffusion, leading to the formation of a spatially patterned state.\nTuring-type patterns emerge when a system exhibits short-ranged activation and long-ranged inhibition. The most well-known realization of a Turing reaction-diffusion system is the combination of a slow-diffusing activator and fast-diffusing inhibitor. Many more examples exist which can be reduced to a mathematically equivalent form. In this practical, we will explore a 3-component Turing system developed by Raspopovic and coauthors to explain the patterning of fingers on the paws of mice [2].\nIn this practical you will work with a total of 6 different python codes. Please note that each code simply differs by an extension or modification from the previous code, so that in the end you will have a long script that performs all the steps in one go.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pattern formation II <br> Turing digit patterns</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#section",
    "href": "pattern_practical_2.html#section",
    "title": "5  Pattern formation II  Turing digit patterns",
    "section": "",
    "text": "Turing, A. M. “The Chemical Basis of Morphogenesis.” Philosophical Transactions of the Royal Society of London. Series B, Biological Sciences 237.641 (1952): 37–72.\n\nRaspopovic, Jelena, et al. “Digit patterning is controlled by a Bmp-Sox9-Wnt Turing network modulated by morphogen gradients.” Science 345.6196 (2014): 566-570.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pattern formation II <br> Turing digit patterns</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#equivalence-of-turing-models",
    "href": "pattern_practical_2.html#equivalence-of-turing-models",
    "title": "5  Pattern formation II  Turing digit patterns",
    "section": "5.1 Equivalence of Turing models",
    "text": "5.1 Equivalence of Turing models\nThe model proposed by Raspopovic et al. for generating Turing patterns underlying limb bone modeling consists of 3 instead of 2 interacting variables. We will refer to this model as “BSW” model, as it represents interactions between Bmp, Sox9, and Wnt.\n\nExercise 5.1 (Conceptual thinking) Study the schemes below. The arrows represent activating or inhibiting interactions, while the wavy lines represent diffusion of components. Simplify the BSW model scheme to a 2-component system and explain why the relevant Turing constraints apply to the BSW model. In your answer, think about the logic of the interactions in the system conceptually; we do not expect you to answer by writing down equations.\n\n\n\n\n\n\n\n\nFigure 5.1: Schemes and numerical solutions of two prototypical 2-component Turing models\n\n\n\n\n\n\n\n\n\n\nFigure 5.2: Scheme of the BSW model",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pattern formation II <br> Turing digit patterns</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#patterning-in-a-fixed-domain-size",
    "href": "pattern_practical_2.html#patterning-in-a-fixed-domain-size",
    "title": "5  Pattern formation II  Turing digit patterns",
    "section": "5.2 Patterning in a fixed domain size",
    "text": "5.2 Patterning in a fixed domain size\nThe code in the script 01__digits_squarehomogeneoustissue.py simulates the model in a 2D square tissue of constant size. This setup can be considered as a small region of a large Petri dish in which mesenchymal cells have been plated with the correct chemicals to undergo bone formation (Supplementary Figure S3 in the paper).\n\nExercise 5.2 (Biology) Play with the reaction parameters and diffusion constants to study their effects on the wavelength of the patterns. Note down the following:\n\nWhich parameter changes lead to a pattern with thicker/thinner stripes?\nWhich parameter changes lead to a pattern with spots?\n\nNote: To make things easier on yourself, only change one parameter at a time. Use a narrow range around the reference value to stay in the numerically stable regime of the forward Euler solver. If the solution becomes blank or wildly oscillating, you’re likely in the numerically unstable regime and you should try a smaller change of values. When increasing diffusion constants, you may need to reduce the time stepping dt.\n(only Master students) Based on the BSW interaction scheme, give a short interpretation of why the following parameter alterations change the spatial pattern:\n\nParameters of Sox9-BMP interaction k2 and k4\nParameters of Sox9-Wnt interaction k3 and k7\nFold change difference in BMP diffusion compared to Wnt diffusion\n\nHint: Use the maximum and minimum values of the variables to guide your thinking.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pattern formation II <br> Turing digit patterns</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#the-homogenous-steady-state-in-turing-models",
    "href": "pattern_practical_2.html#the-homogenous-steady-state-in-turing-models",
    "title": "5  Pattern formation II  Turing digit patterns",
    "section": "5.3 The homogenous steady state in Turing models",
    "text": "5.3 The homogenous steady state in Turing models\nIn a system exhibiting Turing instability, the spatially unpatterned steady state is unstable in the presence of diffusion.\n\nExercise 5.3 (Conceptual thinking) Modify the initial condition in the script 01__digits_squarehomogeneoustissue.py to be exactly in this state (Sox9, BMP, Wnt should be all zero everywhere) and run the simulation. Explain the simulation result.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pattern formation II <br> Turing digit patterns</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#patterning-in-a-growing-domain-size",
    "href": "pattern_practical_2.html#patterning-in-a-growing-domain-size",
    "title": "5  Pattern formation II  Turing digit patterns",
    "section": "5.4 Patterning in a growing domain size",
    "text": "5.4 Patterning in a growing domain size\nBesides parameter values, the pattern that emerges from a Turing system is also strongly influenced by initial conditions and the size and shape of the domain where reactions and diffusion happen.\nIn the script 02__digits_growingsquare_PD.py we added tissue growth in the proximo-distal (body to limb) direction. Growth is controlled by a growth rate vi.\n\nExercise 5.4 (Biology)  \n\nStudy the code to understand what it does.\n\nIncrease the horizontal growth rate vi in small increments (try: 0.01, 0.05, 0.1, 0.2, 0.5) and study what happens to the pattern. Explain why you think this happens.\n\nNote: Increase the totaltime parameter to 5000 when using growth rate of 0.01.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pattern formation II <br> Turing digit patterns</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#patterning-along-two-growth-axes",
    "href": "pattern_practical_2.html#patterning-along-two-growth-axes",
    "title": "5  Pattern formation II  Turing digit patterns",
    "section": "5.5 Patterning along two growth axes",
    "text": "5.5 Patterning along two growth axes\nIn reality, the limb bud grows in both the proximo-distal and anterior-posterior direction. In the script 03__digits_growingsquare.py this is implemented with growth rates vi for proximo-distal growth and vj for anterior-posterior growth.\n\nExercise 5.5 (Biology) Play with the relative size of these growth rates and study what happens. Compare the order of appearance of stripes to the experimental data in the paper (see Figure 3F in the Raspopovic paper).",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pattern formation II <br> Turing digit patterns</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#making-a-virtual-tissue-grow",
    "href": "pattern_practical_2.html#making-a-virtual-tissue-grow",
    "title": "5  Pattern formation II  Turing digit patterns",
    "section": "5.6 Making a virtual tissue grow",
    "text": "5.6 Making a virtual tissue grow\nThink about how tissue growth is implemented in the script 03__digits_growingsquare.py.\n\nExercise 5.6 (Algorithmic and conceptual thinking) What is the default value of the newly added tissue when it grows? Is the concentration elsewhere in the tissue changed?\nDo you think this approach is reasonable to model biological growth of a tissue? Explain why/why not.\nHint: Think about it from the perspective of a growing cell containing a number of molecules “X”.\nIf the cell increases in volume and does not produce/degrade X, what happens to the concentration of X?\nWhat would be the concentration of X in the two daughter cells if the cell divides?\nHow would the situation change if X is constantly produced and degraded?\nIn the paper, Raspopovic et al. create a “tissue growth map” (see Figure 3A), which they use to map concentration values from one timepoint to the next using interpolation-based transformations.\nInspired by this approach, the script 04__digits_growingsquare.py implements a different growth function that uses bilinear interpolation to expand the tissue. Play around with the growth rate parameters and compare the results to what you found earlier. Do the patterns differ? If yes, how do they differ?\nHint: Try the supplementary script supp_g__bilinear_interpolation.py to understand how interpolation-based growth works.\nFor master students: yet another way of implementing tissue growth would be to take cell division and inheritance of maternal state by the two daughter cells literal and implement this by new boundary cells copying the state of their direct neighbors. Implement this alternative growth and see how this affects your results.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pattern formation II <br> Turing digit patterns</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#spatial-modulation-of-parameters-k4-and-k7",
    "href": "pattern_practical_2.html#spatial-modulation-of-parameters-k4-and-k7",
    "title": "5  Pattern formation II  Turing digit patterns",
    "section": "5.7 Spatial modulation of parameters k4 and k7",
    "text": "5.7 Spatial modulation of parameters k4 and k7\nLet us now ignore growth and its role on orienting stripes for a while and explore once again the influence of parameters on the patterns. In reality, digits are patterned further apart at the distal end than at the proximal end, where they need to converge on a hand and wrist. This implies that the wavelength of the Turing pattern should not be constant. In a previous question you probably found that the k7 and k4 parameters impact the wavelength of the Turing pattern. The authors speculate that the FGF and Hox gene gradients observed in the limb bud exert an effect on the Sox9-BMP-Wnt patterning module through these parameters.\n\nExercise 5.7 (Biology) The script 05__digits_squarek4k7gradient.py allows you to implement exponential gradients of k4 and k7 across the tissue. You can set the minimum and maximum values, axis (x=horizontal, y=vertical) and direction (0=decreasing, 1=increasing). Look in the supplement of the Raspopovic paper, page 48 Fig 2C, left for the estimated change of k4 and k7 across the tissue and try to reproduce (not exactly but similarly) Figure 2C, right side, by playing with the parameters affecting the k4 and k7 gradients. Describe along which axis, in which direction and to what extent k4 and k7 are changing. Estimate the change in Turing pattern wavelength this results in.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pattern formation II <br> Turing digit patterns</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#hoxd13-and-fgf",
    "href": "pattern_practical_2.html#hoxd13-and-fgf",
    "title": "5  Pattern formation II  Turing digit patterns",
    "section": "5.8 Hoxd13 and FGF",
    "text": "5.8 Hoxd13 and FGF\nAs mentioned above, the biological factors thought to underly the variation in the k4 and k7 parameters are Hoxd13 and FGF. Hoxd13 is highly expressed in the distal domain of the paddle and not expressed elsewhere, and this expression domain is growing as the paddle grows. FGF is expressed from the distal edge of the paddle and spreads through diffusion. For an illustration see Fig S8A of the supplement of the Raspopovic paper (page 10). Experimental data furthermore suggest that Hoxd13 and FGF together affect k4 and k7, which the authors decided to model using the following equations:\n\\[\nk4^* = k4 - k_{HF_{bmp}} * fgf(i,j) * hox(i,j)\n\\]\n\\[\nk7^* = k7 + k_{HF_{wnt}} * fgf(i,j) * hox(i,j)\n\\]\n\nExercise 5.8 (Algorithmic and biological thinking) The script 06__digits_squarehoxdfgf.py implements how k4 and k7 are a function of local FGF and Hox values, but does not yet include Hox and FGF spatial patterns and how these develop over time. Adjust the code to incorporate the observed Hoxd13 and FGF patterns and study how the digit patterns compare to what you found under question 7. Note that arrays for hox and fgf are included, and decay and diffusion values for fgf are provided already in the code. Also note that hox and fgf each have a maximum value of 1.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pattern formation II <br> Turing digit patterns</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#shape-makes-the-tissue",
    "href": "pattern_practical_2.html#shape-makes-the-tissue",
    "title": "5  Pattern formation II  Turing digit patterns",
    "section": "5.9 Shape makes the tissue",
    "text": "5.9 Shape makes the tissue\nHaving studied the effects of growth and genetic factors modulating the Turing pattern now it is time for the final step. So far, we’ve approximated the limb bud very crudely with a rectangle. As you probably noticed in your parameter exploration, the tissue boundary can bias stripe orientation. Therefore it is interesting to study the interplay between the shape of the “paddle” or limb bud in which the digits develop and how it grows with the temporal development of the hox and fgf patterns. In the script 07__digits_growingpaddle.py we implemented two different tissue geometries: An ellipse and a “paddle” that imitates the shape of the limb bud. Note that to implement Hox and FGF domains on a complex growing shape, quite a bit of complex code involving masks describing the tissue domain and angles to control the Hox and FGF domains was needed. At first, we are going to ignore these technical details.\n\nExercise 5.9 (Biology) Switching between geometries is easily done by changing the value of the parameter geometry on line 78 of the script. Start with the “ellipse” geometry. What do you observe with regards to the FGF gradient? What consequences does this have? Why would this be “a smart thing to do”?\nPlay around with vi/vj and Lx0 to investigate the effect of ellipse shape and development over time on the number, shape and robustness of digits that form.\nNow switch to the paddle geometry. Observe the patterns that emerge and compare these to the simulated and experimentally observed patterns in Figure 3E and 3F of the Raspopovic article. According to you what does and what doesn’t the model explain well?\nThe model explains the formation and positioning of the 4 digits, and how the distance between these digits increases along the limb bud. However, the model clearly does not simulate/explain the formation of the wrist bones that is observed experimentally. Interestingly the experimental data suggest that while digits may form from the “right to the left”, the “leftmost” bones of the wrist are there the earliest, suggesting there locally different conditions apply allowing earlier Turing patterning but with a very large wavelength happening there.\nTo implement non-square geometries, the script uses “masks”. Study how these masks are created in the functions create_ellipse_mask and create_tissue_mask.\nHint: Try the supplementary script supp_i__geometries.py.\nNote: For computational convenience, we use the “Class” data structure to implement common functions shared by the masks. This is a somewhat more advanced programming concept, so it’s ok if you don’t understand what it does yet. For the extra curious and motivated, feel free to check out the supplementary script supp_i__class_data_structure.py.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pattern formation II <br> Turing digit patterns</span>"
    ]
  },
  {
    "objectID": "pattern_practical_2.html#master-students-exercise",
    "href": "pattern_practical_2.html#master-students-exercise",
    "title": "5  Pattern formation II  Turing digit patterns",
    "section": "5.10 Master students exercise",
    "text": "5.10 Master students exercise\n\nExercise 5.10 (Poly and oligodactyly) Above we played with ellipse size and growth rates, however in addition to mutations affecting tissue size and growth, also mutations in genes affecting the Hox and FGF morphogens may occur. Play with parameters that determine Hox and FGF expression zones on the paddle geometry. Which parameter changes lead to the formation of supernumerary fingers (polydactyly)? Which parameters lead to too few fingers (oligodactyly)?\nHint: The following supplementary scripts will be helpful to understand how the FGF and Hox domains were coded:\n\nsupp_i__ellipse_slice.py visualizes the usefulness of masks based on the example of selecting a slice of an ellipse;\nsupp_i__smooth_function.py visualizes the function smooth_function();\nsupp_i__morphological_operations.py visualizes morphological operations (binary dilate/erode and Gaussian blur) which are used for mask operations, calculating the Laplacian on the irregular domain, and to select pixels to generate the FGF and Hox pattern;\nsupp_i__maskDifference.py visualizes the difference of masks, which is how the function single_step_growth() checks if the tissue domain is growing or shrinking.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pattern formation II <br> Turing digit patterns</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html",
    "href": "pattern_practical_3.html",
    "title": "6  Pattern formation III  Clock-and-wavefront",
    "section": "",
    "text": "6.1 Goal of the tutorial:\nIn this tutorial you will look at gradient formation and patterning using different mechanisms than you have seen previously. We will model the so called clock-and-wavefront pattern, which stems from oscillations in gene and gene products and results in a regularly striped pattern in a growing tissue.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pattern formation III <br> Clock-and-wavefront</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#goal-of-the-tutorial",
    "href": "pattern_practical_3.html#goal-of-the-tutorial",
    "title": "6  Pattern formation III  Clock-and-wavefront",
    "section": "6.1 Goal of the tutorial:",
    "text": "6.1 Goal of the tutorial:\nIn this tutorial you will look at gradient formation and patterning using different mechanisms than you have seen previously. We will model the so called clock-and-wavefront pattern, which stems from oscillations in gene and gene products and results in a regularly striped pattern in a growing tissue.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pattern formation III <br> Clock-and-wavefront</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#the-model-system",
    "href": "pattern_practical_3.html#the-model-system",
    "title": "6  Pattern formation III  Clock-and-wavefront",
    "section": "6.2 The model system",
    "text": "6.2 The model system\nThe clock-and-wavefront model is an important model in describing somitogenesis. In this process early in embryo development, the somites, a precursor tissue for the vertebrae and other tissues later in development, are formed from the pre-somitic mesoderm. This mesodorm extends on the posterior end by growth, and the somites bud off periodically at the anterior end in the order of a couple of weeks (in humans).\nKey players in this model system are the protein FGF (fibroblast growth factor), and many genes and gene products that have an oscillatory pattern that will determine cell fate. However, for this tutorial, we simplify this to a single pair of gene mRNA and product, denoted with \\(m\\) and \\(p\\) for short.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pattern formation III <br> Clock-and-wavefront</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#programming-with-classes",
    "href": "pattern_practical_3.html#programming-with-classes",
    "title": "6  Pattern formation III  Clock-and-wavefront",
    "section": "6.3 Programming with classes",
    "text": "6.3 Programming with classes\nBecause we are going to make a more complex model with a tissue existing of multiple cells, and each cell having its own concentrations of FGF, \\(m\\) and \\(p\\), we are going to use Classes in our code. You have been using Classes already: the data types such as int, str and bool have their own class, and the str class has many methods (=functions working on that class) defined, such as \"hello world\".upper(), but it is also possible to create custom classes. With classes, you can easily make objects, which is part of the object-oriented programming paradigm.\nToday, we are going to use classes for the different levels of our model: 1) tissue, 2) cell, 3) \\(m\\) & \\(p\\) clock and 4) the plotting. By using classes, we can separate things that happen on a tissue/cellular/clock scale, and seperate the model from the visualization of it. You will first work with 1 & 2 & 4, then 3 on its own and then combine all four yourself into one model.\nImportant concepts when working with classes are\n\nClass versus instance\nDefining the __init__ method and other methods\nClass attributes and using the keyword self\n\nThis tutorial should be doable without an extensive knowledge of classes as there are plenty of examples to copy-paste from, but feel free to read up on these concepts here at this online tutorial",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pattern formation III <br> Clock-and-wavefront</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#questions",
    "href": "pattern_practical_3.html#questions",
    "title": "6  Pattern formation III  Clock-and-wavefront",
    "section": "6.4 Questions",
    "text": "6.4 Questions\n\nExercise 6.1 In practical 1 we saw how gradients can be created through local production, diffusion and decay. However, other mechanisms for gradient formation are possible, such as cell lineage transport. Here we work with a model for the FGF gradient (fgfgradientfromgrowth.py) where only the rightmost/posterior cell produces FGF and grows, and in which cells upon division inherit this FGF from their mother cell. Play with the model by varying the decay rate of FGF and the division rate of the cells. How does this affect the gradient?\n\n       \n\nConceptual thinking When would this type of gradient formation be more applicable than the earlier studied production, diffusion, decay type of gradient formation? Compare how this model is built-up to a production/diffusion/decay gradient formation model.\n\nAnswer Diffusion slow, degradation slow. In other words, a mostly stable, immobile compound.\n\nMathematics Let us now move to the other half of the clock and wavefront model, the clock part (clock.py), in which we implemented one of the earliest models for the somitogenesis oscillator from Lewis (2003) which models a gene that codes for a mRNA (\\(m\\)) that encodes a protein (\\(p\\)) that acts as a repressive transcription factor of this same gene. In class we discussed how for oscillations negative feedbacks, delays and non-linearity are important. Examine the code to find the differential equations governing this model and determine the negative feedback, delay and non-linearities in them.\n\n\nAnswer Non-linearity is in saturation function with power n, negative feedback is because affects own expression negatively, delay is here modeled explicitly through a special delay type differential equation\n\n\nBiology Play with the parameters of the model. How does the delay (tau/ \\(\\tau\\)) affect oscillations? &gt; Answer longer period (lower frequency) and higher amplitude. Remember how in class we discussed how removing introns reduced delays and affected oscillator period.\nAlgorithmic thinking In the file rolling_clock.py, there is a different implementation of the clock. Compare the two files and find out how they differ. What benefits for studying the model does clock.py have over rolling_clock.py and vice versa? Ignore the added functions __copy__ and set_tau in this comparison. Some differences become clearer when you run the code too.\n\nAnswer The rolling clock only remembers a certain time window of the clock state, namely as long as needs to be remembered plus some buffer for when the clock’s tau changes. A drawback is that not all history is memorized, but it could still be stored to a file. A big win is clear when we run the code and see that it is much faster, especially at later time points.\n\nNext, we will combine the clock and FGF wavefront into a single model. For this, we offer two options of this exercise: A. reading and interpreting existing code from the file clockplusfgf.py, or B. write your own code to combine the two.\n\nRead and interpret existing code: Read the code of clockplusfgf.py and try to understand the assumptions from this model implementation by answering the following questions:\n\nEach cell has its own clock. What clock states is the tissue initialized with? And what clock states do newly divided cells get?\nThe FGF wavefront affects tau: what function is used for that? What are your expectations for the effect of the FGF wavefront on the cells’ clocks?\nDoes growth affect the clock state?\nWhat is your opinion on the assumptions from the three questions? &gt; Answer &gt; 1. The cells are initialized with the same state, namely the default with &gt; m=0 and p=0, and all clock parameters set to one defined in the file. &gt; Newly divided cells get the same clock as the original cell, so we get &gt; two exact copies. &gt; 2. The function is \\[\\tau_\\text{cell}=\\tau_\\text{model}(1+0.5\\frac{100-\\text{FGF}\\_\\text{cell}}{100}),\\] &gt; where \\(\\tau_\\text{cell}\\) is the cell’s new \\(tau\\) and \\(\\tau_\\text{model}\\) the general “model” one’s. &gt; So, we would expect tau to become larger, i.e., the clock to become slower as the FGF wavefront &gt; decays the further to the left we get. &gt; 3. No, there is currently no dilution from \\(m\\) or \\(p\\) from growth. &gt; 4. If we start with few cells that are likely also each other’s sister cells, &gt; the assumption of the same, or at least similar clock states is plausible. &gt; Same for cell division assuming the molecules get evenly distributed. &gt; The current function of FGF on \\(\\tau\\) is imposed, but the idea of slowing down is from &gt; experimental observations. &gt; We could argue about the effect of growth on the clock state, but only few cells are &gt; dividing, so including growth in there would have only a limited effect (but feel free &gt; to test this!).\n\nProgramming As to not spoil the beans to students not wanting to code the model extension, since the hints for programming may answer above questions, please see instructions for implementing it yourself at the end of this tutorial.\n\nBiology With the existing model, or your own model working, describe how this model behaves. Do we get stable somites?\n\nAnswer we get waves of oscillations moving from left to right with increasing amplitudes. Not yet conversion to a stable stripe pattern\n\nBiology & Programming What is still missing is a means to transform the temporal oscillations in the posterior of the tissue into a spatial pattern in the anterior. Now, let’s implement a model that allows for fixation of the somite states.\n\nWe will add an extra ‘memory’ molecule M inside the cell that will be produced depending on the values of FGF and the clock.. To do so add a new attribute to the cell Class that will contain the value of a memory molecule. Also, upon division, let cells inherit the memory value from the mother cell.\nChange the run_clocks function by creating two conditions:\n\nIf the fgf level is between some upper and some lower bound, the clock is updated and simulated after the memory value is updated according to this formula: \\[\\frac{dM}{dt}=c\\max\\left(\\frac{p^4}{h_p^4+p^4}, \\frac{M^4}{h_M^4+M^4}\\right)-\\delta M.\\] Add the new memory parameters as global parameters at the top of the file. For starters, you can give them the following values:\n\n\\(\\text{FGF upper bound}=10\\)\n\\(\\text{FGF lower bound}=9.75\\)\n\\(c=0.01\\)\n\\(h_p=8.5\\)\n\\(h_M=0.5\\)\n\\(\\delta=0.01\\)\n\nOtherwise, the clock is updated and simulated as normal, and nothing changes with the memory molecule of the cell\n\nTo visualize the memory, follow the same procedure as for visualizing the fgf and p values: put in a string referring to the new attribute you created for the molecule in step 1.\n\nBiology Do you get stable somite formation on the left/anterior of the tissue? Is it a regular pattern of somites? What happens if the requirement for updating \\(M\\) is only that FGF should be below a certain value? What happens if the equation for \\(\\frac{dM}{dt}\\) only depends on \\(p\\) and not \\(M\\) itself.\n\n\nAnswer They should get somite patterns that are stable, but not necessarily regular. If only one threshold all goes to high state, because eventually all go through all phases, you need to memorize who was within a limited time/space window in a particular state. If only P dependent M is activated but does not memorize so it will be just as unstable as P before.\n\n\nBiology Both zebrafish and mice are common model organisms, so we know a lot about the biological parameters of their somitogenesis. See the following list:\n\n\n\n\n\n\n\n\n\n\nParameter\nZebrafish\nReference\nMouse\nReference\n\n\n\n\nDuration of somitogenesis\n18 h\n(a)\n5 days\n(b)\n\n\nNumber of somites\n~30\n(a)\n65\n(c)\n\n\nSomite size\n50 micron / 30 micron\n(d) (a)\n120 micron\n(c)\n\n\nCells per somite\n~5 cell in diameter\n(a)\n5-11 (estimated from total cell size in 3D, ranging 1 order of magnitude)\n(c)\n\n\nClock period\n25 min /30 min\n(d) / (e) / (f)\n2-3 h\n(e)\n\n\n\nFrom these parameters, you can derive a number of desired model inputs/outcomes:\n\nThe total size of the tissue at the end of somitogenesis\nThe size of a cell\nSpeed of division\n\nUse the model and try to find suitable model parameters to recreate the development of both zebrafish and mice: is this model able to describe both of these processes? I.e., is this model able to deal with the scale differences between zebrafish and mice?\nA couple of notes:\n\nYou don’t have to exactly recreate the biological parameter with 100% precision, except for the number of segments/somites, although it can be a fun challenge to get a complete match.\nYou might want to adapt your plotting timestep to have sufficient but not too many plot updates in one simulation.\nYou can test the clock parameters separately with the clock.py/rolling_clock.py script. Don’t forget that FGF has an effect on tau!",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pattern formation III <br> Clock-and-wavefront</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#further-open-questions",
    "href": "pattern_practical_3.html#further-open-questions",
    "title": "6  Pattern formation III  Clock-and-wavefront",
    "section": "6.5 Further (open) questions",
    "text": "6.5 Further (open) questions\nThe model currently has a number of assumptions that we can question. Feel free to explore any of these further open questions and study how it effects the outcome of the model:\n\nWhat if the relationship between FGF and tau is shaped differently? For instance, if the clock runs faster on the left/anterior than on the right/posterior?\nWhat if the clock state of a daughter cell is started fresh rather than being a copy from the mother cell?\nWhat if the clock \\(m\\) and \\(p\\) are diluted by growth?\nWhat if tau is unaffected by FGF: can we still get somites fixed in place?",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pattern formation III <br> Clock-and-wavefront</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#references-for-biological-parameters",
    "href": "pattern_practical_3.html#references-for-biological-parameters",
    "title": "6  Pattern formation III  Clock-and-wavefront",
    "section": "6.6 References for biological parameters:",
    "text": "6.6 References for biological parameters:\n\nhttps://anatomypubs.onlinelibrary.wiley.com/doi/10.1002/1097-0177(2000)9999:9999%3C::AID-DVDY1065%3E3.0.CO;2-A\nhttps://doi.org/10.1016/j.gde.2012.05.004\nhttps://doi.org/10.1242/dev.65.Supplement.103\nhttps://doi.org/10.1242/dev.161257\nhttps://doi.org/10.3389/fcell.2022.944016\nhttps://www.sciencedirect.com/science/article/pii/S0079610718300178",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pattern formation III <br> Clock-and-wavefront</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#combining-the-clock-and-fgf-wavefront-model---programming-instructions",
    "href": "pattern_practical_3.html#combining-the-clock-and-fgf-wavefront-model---programming-instructions",
    "title": "6  Pattern formation III  Clock-and-wavefront",
    "section": "6.7 Combining the clock and FGF wavefront model - programming instructions",
    "text": "6.7 Combining the clock and FGF wavefront model - programming instructions\nLet us now combine the (rolling) clock and the wavefront, and assume that the FGF wavefront affects tau such that as FGF levels drop tau goes up and oscillations slow. Here are some tips and hints to help you along the way:\n\nTry implementing things in steps and run your code in between steps: this is easier to debug than changing everything in one go.\nUse the file rolling_clock.py to import the clock class from. Make sure that every cell gets initialized with a clock by adding a clock as a cell Class attribute.\nOf course, we must not forget that a cell inherits the clock from its mother. Use the __copy__ method from the clock Class to set the clock of the freshly divided daughter cell the same as the mother’s.\nThere are many ways that FGF could affect tau. For this tutorial, stick to the following relationship: \\[\\tau_\\text{cell}=\\tau_\\text{model}(1+0.5\\frac{100-\\text{FGF}\\_\\text{cell}}{100}),\\] where \\(\\tau_\\text{cell}\\) is the tau of a specific cell, and \\(\\tau_\\text{model}\\) is a global tau set as a model parameter. To implement this, create a method update_clock for the cell Class, that uses the clock Class’s set_tau method to update the clock of the cell.\nMake a method in the tissue class called run_clocks that simulates the clock of every cell in the tissue. Use the Clock’s simulate method. For simplicity, we assume that growth does not affect the concentrations of \\(m\\) and \\(p\\).\nMake sure that the tissue method run_clocks also updates the clock of the cell, and that the simulate_development function also lets the clocks run.\nVisualize the p values of every cell. You can reuse the existing visualisation methods initialize_axis_cell_data and update_plot_cell_data from graphics.py, but now let them display p values instead of fgf values. You can give the name of the attribute as a string to the initialize_axis_cell_data function, so something like clock.p_values[-1] instead of fgf might already work depending on your exact implementation of the clock.\nOnce you’re done, check if your model behaves as it should with the teacher/assistant or the file clockplusfgf.py directly.",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pattern formation III <br> Clock-and-wavefront</span>"
    ]
  },
  {
    "objectID": "pattern_practical_3.html#relevant-literature",
    "href": "pattern_practical_3.html#relevant-literature",
    "title": "6  Pattern formation III  Clock-and-wavefront",
    "section": "6.8 Relevant literature",
    "text": "6.8 Relevant literature\nIf you want to know more about the model system and previous models, have a look at the following (after the tutorial):\nLewis (2003) _Autoinhibition with Transcriptional Delay A Simple Mechanism for the Zebrafish Somitogenesis Oscillator",
    "crumbs": [
      "I) Pattern formation",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pattern formation III <br> Clock-and-wavefront</span>"
    ]
  }
]