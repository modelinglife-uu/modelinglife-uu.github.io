---
params:
  show_answers: true
---

# Pattern formation III <br> Clock-and-wavefront

## Goal of the tutorial:

In this tutorial you will look at gradient formation and patterning
using different mechanisms than you have seen previously. We will model
the so called clock-and-wavefront pattern, which stems from oscillations
in gene and gene products and results in a regularly striped pattern in
a growing tissue.

## The model system

The clock-and-wavefront model is an important model in describing
somitogenesis. In this process early in embryo development, the somites,
a precursor tissue for the vertebrae and other tissues later in
development, are formed from the pre-somitic mesoderm. This mesodorm
extends on the posterior end by growth, and the somites bud off
periodically at the anterior end in the order of a couple of weeks (in
humans).

Key players in this model system are the protein FGF (fibroblast growth
factor), and many genes and gene products that have an oscillatory
pattern that will determine cell fate. However, for this tutorial, we
simplify this to a single pair of gene mRNA and product, denoted with $m$
and $p$ for short.

## Programming with classes

Because we are going to make a more complex model with a tissue existing
of multiple cells, and each cell having its own concentrations of FGF, $m$
and $p$, we are going to use Classes in our code. You have been using
Classes already: the data types such as `int`, `str` and `bool` have their own
class, and the `str` class has many *methods* (=functions working on that
class) defined, such as `"hello world".upper()`, but it is also possible
to create custom classes. With classes, you can easily make objects,
which is part of the object-oriented programming paradigm.

Today, we are going to use classes for the different levels of our
model: 1) tissue, 2) cell, 3) $m$ & $p$ clock and 4) the plotting. By using
classes, we can separate things that happen on a tissue/cellular/clock
scale, and seperate the model from the visualization of it. You will
first work with 1 & 2 & 4, then 3 on its own and then combine all
four yourself into one model.

Important concepts when working with classes are

-   Class versus instance
-   Defining the `__init__` method and other methods
-   Class attributes and using the keyword `self`

This tutorial should be doable without an extensive knowledge of classes
as there are plenty of examples to copy-paste from, but feel free to
read up on these concepts here at [this online
tutorial](https://www.datacamp.com/tutorial/python-oop-tutorial)



## Questions

:::{#exr-test}

## Biology 
In practical 1 we saw how gradients can be created through local
production, diffusion and decay. However, other mechanisms for
gradient formation are possible, such as cell lineage transport.
Here we work with a model for the FGF gradient
(`fgfgradientfromgrowth.py`) where only the rightmost/posterior cell
produces FGF and grows, and in which cells upon division inherit
this FGF from their mother cell. Play with the model by varying the
decay rate of FGF and the division rate of the cells. How does this
affect the gradient?
:::


::: {.content-visible when-meta="params.show_answers"}

> **Answer** *If growth rate goes up cell volumes increase faster, causing more
> dilution of FGF and hence a lower maximum of the gradient as due to
> the stable protein quite some time is needed to compensate for this
> decrease by more production, at the same time the gradient is less
> steep as cell division follow up faster and hence less time has passed
> and less day has taken place. If decay rate goes up, maximum goes down
> but gradient become steeper and shorter as for same time between
> divisions more decay takes place*
  
:::
  
:::{#exr-test}
## Conceptual thinking

When would this type of gradient formation
    be more applicable than the earlier studied production, diffusion,
    decay type of gradient formation? Compare how this model is built-up
    to a production/diffusion/decay gradient formation model.
:::

::: {.content-visible when-meta="params.show_answers"}

  > **Answer** Diffusion slow, degradation slow. In other words, a
  > mostly stable, immobile compound.
:::

:::{#exr-test}
## Mathematics

Let us now move to the other half of the clock and
    wavefront model, the clock part (`clock.py`), in which we implemented
    one of the earliest models for the somitogenesis oscillator from
    [Lewis (2003)](https://doi.org/10.1016/S0960-9822(03)00534-7) which
    models a gene that codes for a mRNA ($m$) that encodes a protein ($p$)
    that acts as a repressive transcription factor of this same gene. In
    class we discussed how for oscillations negative feedbacks, delays
    and non-linearity are important. Examine the code to find the
    differential equations governing this model and determine the
    negative feedback, delay and non-linearities in them.
:::

::: {.content-visible when-meta="params.show_answers"}

  > **Answer** Non-linearity is in saturation function with power n, negative
  > feedback is because affects own expression negatively, delay is here
  > modeled explicitly through a special delay type differential equation
:::

:::{#exr-test}
## Biology

Play with the parameters of the model. How does the delay
   (`tau`/ $\tau$) affect oscillations?
:::

::: {.content-visible when-meta="params.show_answers"}

   > **Answer** *longer period (lower frequency) and higher
   amplitude. Remember how in class we discussed how removing introns
   reduced delays and affected oscillator period.*
:::

:::{#exr-test}
## Algorithmic thinking

In the file `rolling_clock.py`, there is a
    different implementation of the clock. Compare the two files and
    find out how they differ. What benefits for studying the model does
    `clock.py` have over `rolling_clock.py` and vice versa? Ignore the added
    functions `__copy__` and `set_tau` in this comparison. Some
    differences become clearer when you run the code too.
:::

::: {.content-visible when-meta="params.show_answers"}

  > **Answer** The rolling clock only remembers a certain time window of the
    clock state, namely as long as needs to be remembered plus some buffer for
    when the clock's tau changes. A drawback is that not all history is
    memorized, but it could still be stored to a file. A big win is clear when
    we run the code and see that it is much faster, especially at later time
    points.
:::

:::{#exr-test}

## 

Next, we will combine the clock and FGF wavefront into a single
    model. For this, we offer two options of this exercise: A. reading
    and interpreting existing code from the file clockplusfgf.py, or B.
    write your own code to combine the two.

1. **Read and interpret existing code:** Read the code of
    `clockplusfgf.py` and try to understand the assumptions from this
    model implementation by answering the following questions:

    1.  Each cell has its own clock. What clock states is the tissue
        initialized with? And what clock states do newly divided
        cells get?
    2.  The FGF wavefront affects `tau`: what function is used for
        that? What are your expectations for the effect of the FGF
        wavefront on the cells' clocks?
    3.  Does growth affect the clock state?
    4.  What is your opinion on the assumptions from the three
        questions?
:::

::: {.content-visible when-meta="params.show_answers"}
   > **Answer**
   > 1. The cells are initialized with the same state, namely the default with
   >    `m=0` and `p=0`, and all clock parameters set to one defined in the file.
   >    Newly divided cells get the same clock as the original cell, so we get
   >    two exact copies.
   > 2. The function is $$\tau_\text{cell}=\tau_\text{model}(1+0.5\frac{100-\text{FGF}\_\text{cell}}{100}),$$
   >    where $\tau_\text{cell}$ is the cell's new $tau$ and $\tau_\text{model}$ the general "model" one's.
   >    So, we would expect tau to become larger, i.e., the clock to become slower as the FGF wavefront
   >    decays the further to the left we get.
   > 3. No, there is currently no dilution from $m$ or $p$ from growth.
   > 4. If we start with few cells that are likely also each other's sister cells,
   >    the assumption of the same, or at least similar clock states is plausible.
   >    Same for cell division assuming the molecules get evenly distributed.
   >    The current function of FGF on $\tau$ is imposed, but the idea of slowing down is from
   >    experimental observations.
   >    We could argue about the effect of growth on the clock state, but only few cells are
   >    dividing, so including growth in there would have only a limited effect (but feel free
   >    to test this!).
:::

:::{#exr-test}

## Programming

As to not spoil the beans to students not wanting to code the model extension, since the hints for programming may answer above questions, please see instructions for implementing it yourself at the end of this tutorial.
:::

7.  **Biology** With the existing model, or your own model working,
    describe how this model behaves. Do we get stable somites?

::: {.content-visible when-meta="params.show_answers"}

    > **Answer** *we get waves of oscillations moving from left to right with increasing
    > amplitudes. Not yet conversion to a stable stripe pattern*
:::

8.  **Biology & Programming**
    What is still missing is a means to
    transform the temporal oscillations in the posterior of the tissue
    into a spatial pattern in the anterior. Now, let's implement a model
    that allows for fixation of the somite states.

    1.  We will add an extra 'memory' molecule `M` inside the cell that
        will be produced depending on the values of FGF and the clock..
        To do so add a new attribute to the cell Class that will contain
        the value of a memory molecule. Also, upon division, let cells
        inherit the memory value from the mother cell.

    2.  Change the `run_clocks` function by creating two conditions:

        1.  If the fgf level is between some upper and some lower bound,
            the clock is updated and simulated after the memory value is
            updated according to this
            formula:
            $$\frac{dM}{dt}=c\max\left(\frac{p^4}{h_p^4+p^4}, \frac{M^4}{h_M^4+M^4}\right)-\delta M.$$
            Add the new memory parameters as global
            parameters at the top of the file. For starters, you can
            give them the following values:

            1.  $\text{FGF upper bound}=10$
            2.  $\text{FGF lower bound}=9.75$
            3.  $c=0.01$
            4.  $h_p=8.5$
            5.  $h_M=0.5$
            6.  $\delta=0.01$

        1. Otherwise, the clock is updated and simulated as normal, and
            nothing changes with the memory molecule of the cell

    3.  To visualize the memory, follow the same procedure as for
        visualizing the `fgf` and `p` values: put in a string referring to
        the new attribute you created for the molecule in step 1.

9. **Biology** Do you get stable somite formation on the left/anterior of the tissue?
Is it a regular pattern of somites? What happens if the requirement for
updating $M$ is only that FGF should be below a certain value? What
happens if the equation for $\frac{dM}{dt}$ only depends on $p$ and not $M$ itself.

::: {.content-visible when-meta="params.show_answers"}

  > **Answer** *They should get somite patterns that are stable, but not necessarily
regular. If only one threshold all goes to high state, because
eventually all go through all phases, you need to memorize who was
within a limited time/space window in a particular state. If only P
dependent M is activated but does not memorize so it will be just as
unstable as P before.*
:::

10. **Biology** Both zebrafish and mice are common model organisms, so
    we know a lot about the biological parameters of their
    somitogenesis. See the following list:

    | Parameter                 | Zebrafish             | Reference                                                                                                                                            | Mouse                                                                     | Reference                                     |
    |---------------------------|-----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------|-----------------------------------------------|
    | Duration of somitogenesis | 18 h                  | (a)                                       | 5 days                                                                    | (b)     |
    | Number of somites         | ~30                   | (a)                                       | 65                                                                        | (c) |
    | Somite size               | 50 micron / 30 micron | (d) (a)    | 120 micron                                                                | (c) |
    | Cells per somite          | ~5 cell in diameter   | (a)                                       | 5-11 (estimated from total cell size in 3D, ranging 1 order of magnitude) | (c) |
    | Clock period              | 25 min /30 min        | (d) / (e) / (f) | 2-3 h                                                                     | (e)     |

    From these parameters, you can derive a number of desired model
    inputs/outcomes:

    -   The total size of the tissue at the end of somitogenesis
    -   The size of a cell
    -   Speed of division

    Use the model and try to find suitable model parameters to recreate the
    development of both zebrafish and mice: is this model able to describe
    both of these processes? I.e., is this model able to deal with the scale
    differences between zebrafish and mice?

    A couple of notes:

    -   You don't have to exactly recreate the biological parameter with
        100% precision, except for the number of segments/somites, although
        it can be a fun challenge to get a complete match.
    -   You might want to adapt your plotting timestep to have sufficient
        but not too many plot updates in one simulation.
    -   You can test the clock parameters separately with the `clock.py`/`rolling_clock.py`
        script. Don't forget that FGF has an effect on tau!

## Further (open) questions
The model currently has a number of assumptions that we can
  question. Feel free to explore any of these further open questions
  and study how it effects the outcome of the model:

-   What if the relationship between FGF and tau is shaped differently?
    For instance, if the clock runs faster on the left/anterior than on
    the right/posterior?
-   What if the clock state of a daughter cell is started fresh rather
    than being a copy from the mother cell?
-   What if the clock $m$ and $p$ are diluted by growth?
-   What if tau is unaffected by FGF: can we still get somites fixed in
    place?
    
    ::: {.content-visible when-meta="params.show_answers"}

  > **Answer** These are open questions and do not have a single correct answer. Feel free to discuss with us if you find something interesting or have an interesting answer. 
:::

## References for biological parameters:

(a) [*https://anatomypubs.onlinelibrary.wiley.com/doi/10.1002/1097-0177(2000)9999:9999%3C::AID-DVDY1065%3E3.0.CO;2-A*](https://anatomypubs.onlinelibrary.wiley.com/doi/10.1002/1097-0177(2000)9999:9999%3C::AID-DVDY1065%3E3.0.CO;2-A)

(b) [*https://doi.org/10.1016/j.gde.2012.05.004*](https://doi.org/10.1016/j.gde.2012.05.004)

(c) [*https://doi.org/10.1242/dev.65.Supplement.103*](https://doi.org/10.1242/dev.65.Supplement.103)

(d) [*https://doi.org/10.1242/dev.161257*](https://doi.org/10.1242/dev.161257)

(e) [*https://doi.org/10.3389/fcell.2022.944016*](https://doi.org/10.3389/fcell.2022.944016)

(f) [*https://www.sciencedirect.com/science/article/pii/S0079610718300178*](https://www.sciencedirect.com/science/article/pii/S0079610718300178)

## Combining the clock and FGF wavefront model - programming instructions

Let us now combine the (rolling) clock and the wavefront, and assume
that the FGF wavefront affects tau such that as FGF levels drop tau goes
up and oscillations slow. Here are some tips and hints to help you along
the way:

1.  Try implementing things in steps and run your code in between steps:
    this is easier to debug than changing everything in one go.
2.  Use the file `rolling_clock.py` to import the `clock` class from. Make
    sure that every cell gets initialized with a clock by adding a `clock`
    as a `cell` Class attribute.
3.  Of course, we must not forget that a cell inherits the clock from
    its mother. Use the `__copy__` method from the `clock` Class to set
    the clock of the freshly divided daughter cell the same as the
    mother's.
4.  There are many ways that FGF could affect tau. For this tutorial,
    stick to the following relationship:
    $$\tau_\text{cell}=\tau_\text{model}(1+0.5\frac{100-\text{FGF}\_\text{cell}}{100}),$$
    where $\tau_\text{cell}$ is the tau of a specific cell, and $\tau_\text{model}$ is a global
    tau set as a model parameter. To implement this, create a method
    `update_clock` for the `cell` Class, that uses the `clock` Class's `set_tau`
    method to update the clock of the cell.
5.  Make a method in the `tissue` class called `run_clocks` that simulates
    the clock of every cell in the tissue. Use the `Clock`'s `simulate`
    method. For simplicity, we assume that growth does not affect the
    concentrations of $m$ and $p$.
6.  Make sure that the tissue method `run_clocks` also updates the clock
    of the cell, and that the `simulate_development` function also lets
    the clocks run.
7.  Visualize the `p` values of every cell. You can reuse the existing
    visualisation methods `initialize_axis_cell_data` and
    `update_plot_cell_data` from `graphics.py`, but now let them display `p`
    values instead of `fgf` values. You can give the name of the attribute as a
    string to the `initialize_axis_cell_data` function, so something like
    `clock.p_values[-1]` instead of `fgf` might already work depending on
    your exact implementation of the clock.
8.  Once you're done, check if your
    model behaves as it should with the teacher/assistant or the file
    `clockplusfgf.py` directly.
    
    
## Relevant literature

If you want to know more about the model system and previous models,
have a look at the following (after the tutorial):

[Lewis (2003) _Autoinhibition with Transcriptional Delay
A Simple Mechanism for the Zebrafish Somitogenesis Oscillator](https://doi.org/10.1016/S0960-9822(03)00534-7)
