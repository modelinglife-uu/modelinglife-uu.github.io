---
params:
  show_answers: true
---

# Clock-and-wavefront patterning

## Goal of the tutorial:

In this tutorial you will look at gradient formation and patterning 
using different mechanisms than you have seen previously. We will 
model the so-called clock-and-wavefront pattern, which stems from 
oscillations in gene expression and gene products and results in a 
regularly striped segmentation pattern in a growing tissue. Note that 
as compared to the Drosophila French Flag type case, this is thought 
to be the evolutionary ancestral model of segmenting animal body axes.

## The model system

The clock-and-wavefront model is an important model in describing
somitogenesis. In this process early in embryo development, the somites,
a precursor tissue for the vertebrae and other tissues later in
development, are formed from the pre-somitic mesoderm. This mesodorm
extends on the posterior end by growth, and the somites bud off
periodically at the anterior end in the order of a couple of weeks (in
humans).

Key players in this model system are the protein FGF (fibroblast growth
factor), and many genes and gene products that have an oscillatory
pattern that will determine cell fate. However, for this tutorial, we
simplify this to a single pair of gene mRNA and product, denoted with $m$
and $p$ for short.

## Programming with classes

Because we are going to make a more complex model with a tissue existing
of multiple cells, and each cell having its own concentrations of FGF, $m$
and $p$, we are going to use Classes in our code. You have been using
Classes already: the data types such as `int`, `str` and `bool` have their own
class, and the `str` class has many *methods* (=functions working on that
class) defined, such as `"hello world".upper()`, but it is also possible
to create custom classes. With classes, you can easily make objects,
which is part of the object-oriented programming paradigm.

Today, we are going to use classes for the different levels of our
model: 1) tissue, 2) cell, 3) $m$ & $p$ clock and 4) the plotting. By using
classes, we can separate things that happen on a tissue/cellular/clock
scale, and seperate the model from the visualization of it. You will
first work with 1 & 2 & 4, then 3 on its own and then combine all
four yourself into one model.

Important concepts when working with classes are

-   Class versus instance
-   Defining the `__init__` method and other methods
-   Class attributes and using the keyword `self`

This tutorial should be doable without an extensive knowledge of classes
as there are plenty of examples to copy-paste from, but feel free to
read up on these concepts here at [this online
tutorial](https://www.datacamp.com/tutorial/python-oop-tutorial)



## Questions

:::{#exr-test}

## Biology - An alternative gradient forming mechanism
In practical 1 we saw how gradients can be created through local 
production, diffusion and decay. However, other mechanisms for 
gradient formation are possible, such as cell lineage transport. 
Here we work with a model for the FGF gradient (`fgfgradientfromgrowth.py`)
where only the rightmost/posterior cell produces FGF and grows, and 
in which cells upon division inherit this FGF from their mother cell. 
First study the code to see how it uses Classes and see what happens. 
Next, play with the model by varying the decay rate of FGF and the 
division rate of the cells. How does this affect the gradient? What 
happens if divisions are only allowed during the first half of the 
simulation (put `divisiontime` to 0.5 instead of 1).

:::


::: {.content-visible when-meta="params.show_answers"}

  > **Answer** If growth rate goes up cell volumes increase faster, causing more
  > dilution of FGF and hence a lower maximum of the gradient as due to
  > the stable protein quite some time is needed to compensate for this
  > decrease by more production, at the same time the gradient is less
  > steep as cell division follow up faster and hence less time has passed
  > and less day has taken place. 
  >
  > If decay rate goes up, maximum goes down but the gradient become steeper 
  > and shorter as for same time between divisions more decay takes place.
  > If divisions stop halfway the simulation FGF in last cell goes up (no 
  > longer any loss due to growth-induced dilution) and FGF in all other 
  > cells goes to zero (no fresh influx from newly divided cells still having FGF).
  
:::
  
:::{#exr-test}
## Conceptual thinking

When would this type of gradient formation
    be more applicable than the earlier studied production, diffusion,
    decay type of gradient formation? Compare how this model is built-up
    to a production/diffusion/decay gradient formation model.
:::

::: {.content-visible when-meta="params.show_answers"}

  > **Answer** Earlier gradient model: gradient length increases and slope 
  > decreases with faster diffusion and slower degradation. Here gradient 
  > driven by combination of growth/division and degradation. This new mechanism
  > can only work if growth and patterning are occurring simultaneously, 
  > not if growth precedes patterning..
:::

:::{#exr-test}
## Mathematics

Let us now move to the other half of the clock and
    wavefront model, the clock part (`clock.py`), in which we implemented
    one of the earliest models for the somitogenesis oscillator from
    [Lewis (2003)](https://doi.org/10.1016/S0960-9822(03)00534-7) which
    models a gene that codes for a mRNA ($m$) that encodes a protein ($p$)
    that acts as a repressive transcription factor of this same gene. In
    class we discussed how for oscillations negative feedbacks, delays
    and non-linearity are important. Examine the code to find the
    differential equations governing this model and determine the
    negative feedback, delay and non-linearities in them.
:::

::: {.content-visible when-meta="params.show_answers"}

  > **Answer** Non-linearity is in saturation function with power n, negative
  > feedback is because affects own expression negatively, delay is here
  > modeled explicitly through a special delay type differential equation
:::

:::{#exr-test}
## Biology

Play with the parameters of the model. How does the delay
   ($\tau$) affect oscillations?
:::

::: {.content-visible when-meta="params.show_answers"}

   > **Answer** Larger value of $\tau$=delay results in a longer period 
   > (lower frequency) and higher amplitude. Remember how in class we 
   >discussed how removing introns reduced delays and affected oscillator 
   >period.
:::

:::{#exr-test}
## Algorithmic thinking

In the file `rolling_clock.py`, there is a
    different implementation of the clock. Compare the two files and
    find out how they differ. What benefits for studying the model does
    `clock.py` have over `rolling_clock.py` and vice versa? Ignore the added
    functions `__copy__` and `set_tau` in this comparison. Some
    differences become clearer when you run the code too.
:::

::: {.content-visible when-meta="params.show_answers"}

  > **Answer** Working with delay functions implies that you need the value 
  > of a variable not on the current time but on time-$\tau$. In the previous 
  > model we simply memorized the entire history of both variables. Here 
  > instead we only store the variable state for the length of the time delay 
  > $\tau$. This saves memory and hence runtime. This will become especially 
  > important when simulating a larger number of individual cells each having 
  > their own clocks. In the plotting we only plotted stored values, hence 
  > you only see what happened between current_time-$\tau$ and current_time 
  > instead of what happened from start of simulation till current time. Of 
  > course if you want to dynamically change $\tau$ you need to make sure you store 
  > values over an interval corresponding to the largest possible value of $\tau$ 
  > and need to know this beforehand.
:::

:::{#exr-test}

## 

Next, we will combine the clock and FGF wavefront into a single
    model. 

**Read and interpret existing code:** Read the code of
    `clockplusfgf.py` and try to understand the assumptions from this
    model implementation by answering the following questions:

  1.  Each cell has its own clock. What clock states is the tissue
        initialized with? And what clock states do newly divided
        cells get?
    2.  The FGF wavefront affects tau: what function is used for
        that? What are your expectations for the effect of the FGF
        wavefront on the cells' clocks?
    3.  Does growth affect the clock state?
    4.  What is your opinion on the assumptions discussed in the three
        questions?
:::

::: {.content-visible when-meta="params.show_answers"}
   > **Answer**
   > 
   > 1. Going to code rolling_clock.py we see that clocks are initialized 
   > with the __init__ function of the Class Clock, which gets as arguments 
   > $m0$ and $p0$, this initialization function is called when in Class `Cell`, 
   > in its respective `__init__`  function `self.clock=Clock(..)` is called. 
   > It uses default values of $m=0$ and $p=0$ to pass to the `Clock`. (In turn, 
   > the initialization function of Class `Cell` is called from the
   > initialize_regular_tissue function of Class `Tissue` when the first cell 
   > is created). Newly divided cells inherit clock state and and FGF value 
   > from mother cell.
   > 
   > 2. The function is:
   > $$\tau_\text{cell}=\tau_\text{model}(1+0.5\frac{100-\text{FGF}\_\text{cell}}{100}),$$ 
   > So if localfgf=max=100,  $\tau{local}$=$\tau{global}$, and if localfgf=min=0
   > $\tau{local}$=1.5*$\tau{global}$ 
   > So for lower FGF $\tau$ increases slowing down the oscillations. 
   > 3. Not directly, growth of cells, leading to volume increase and potential
   > dilution effects is not affecting m or p levels, however since it is 
   > affecting FGF levels it is indirectly affecting the clock.
   > 4. Initialization is somewhat arbitrary, inheritance from mother cells is 
   > logical although in reality it is of course not perfect but noisy,  FGF 
   > effect is also reasonable to get the observed slowing and waves, but it 
   > would be more logical for clock state like fgf to also be diluted if cells 
   > grow their volume
:::

:::{#exr-test}

## Biology

Describe how the model behaves and why. Do we get stable somites?
:::

::: {.content-visible when-meta="params.show_answers"}

  > **Answer** First there is a startup period where we have synchronized 
  > oscillations in the first formed cells that all still have high FGF. 
  > Then as the tissue grows and the FGF gradient forms we obtain waves of 
  > oscillations moving from right to left with increasing amplitudes. The 
  > right to left movement arises because oscillations are faster on the right 
  > than on the left, this difference in oscillation frequency arises from the 
  > impact of FGF on oscillator frequency. However, the oscillations do not 
  > become halted and transformed into a stable spatial pattern because there 
  > is no memory mechanism in place.
:::

:::{#exr-test}
## Biology & Programming

What is still missing is a means to transform the temporal oscillations in 
the posterior of the tissue into a spatial pattern in the anterior.  In the 
French Flag morphogen gradient lecture we discussed that memory mechanisms 
are important to stabilize spatial patterns once the start up signal that broke 
the symmetry and initialized patterning has gone. It turns out that such a
memorization/stabilization mechanism is also essential to convert oscillations 
to stripes. Add a memorization mechanism to the model to achieve this. *Hint*: Make 
use of an extra ‘memory’ molecule $M$ in each cell and perform its updating inside 
the function `run_clocks`. To see what you are doing, visualize the spatial pattern 
of $M$` over time following the same procedure as for visualizing the `fgf` and $p$ 
values. Think about where, when and what should be memorized to design how $M$ 
is regulated and what $M$ itself affects and take a stepwise approach.

  1.  Add an extra 'memory' molecule $M$ as a new attribute to the Class `Cell`,
    which value is inherited from the mother cell upon division. To create memory 
    we need bistability, which can be easily achieved by having the memory molecule 
    having a non-linear saturating positive feedback on itself.  However, doing only 
    this it will depend on the initial value of  $M$ -below or above a threshold- whether 
     $M$ will autoactivate or not. Additionally, if it happens it will occur across 
    the entire tissue.  

2.  Thus, we need to make $M$ dependent on the clock. To achieve this, we can start 
    with low values of  $M$ that prevent autoactivation, and then have $M$ activated by 
    either $p$ (part of the clock) or $M$ itself using the following function: 
            $$\frac{dM}{dt}=c\max\left(\frac{p^4}{h_p^4+p^4}, \frac{M^4}{h_M^4+M^4}\right)-\delta M.$$
            
    However, now we simply always get activation of $M$ everywhere.
3.  Since oscillations occur in the PSM and stripe formation occurs only more anteriorly 
    we should constrain memorization to occur only below a certain FGF value. As a consequence, 
    high levels of $M$ now only arise anteriorly, but there is no pattern yet and oscillations 
    keep occurring.  This is because cells cycle through high and low p values so all cells at 
    some point have high $p$ values and can induce $M$.
4. So in addition to have memorization occur only below a certain FGF value it should also 
    occur above another, lower FGF value, constraining it to occur in a limited temporal window 
    that enables cells passing through there with a high $p$ state to induce a high $M$ state while 
    cells pasing through with a low $p$ state to not induce a high $M$ state. You should get somite 
    patterns that are stable, but not necessarily regular. Still $m$ and $p$ oscillations continue.
5. As a final step, beyond the FGF window where we memorize $M$ we no longer update either $M$ 
    or the clock.
:::
::: {.content-visible when-meta="params.show_answers"}

  > **Answer** See code `05_answers_clockplusfgf_memory.py`

:::
:::{#exr-test}

## Biology

Both zebrafish and mice are common model organisms, so we know a lot about the biological 
parameters of their somitogenesis. See the following list:

| Parameter                           | Zebrafish             | Reference                                                                                                                                            | Mouse                                                                     | Reference |
  |----------------------------------------------------------------------------------|----------------------------------|-----------------------------------------------------|---------------------------------------------------------------------------|-----------------------------------------------|
  | Duration of somitogenesis | 18 h                  | (a)                                       | 5 days                                                                    | (b)     |
  | Number of somites         | ~30                   | (a)                                       | 65                                                                        | (c) |
  | Somite size               | 50 micron / 30 micron | (d) (a)    | 120 micron                                                                | (c) |
  | Cells per somite          | ~5 cell in diameter   | (a)                                       | 5-11 (estimated from total cell size in 3D, ranging 1 order of magnitude) | (c) |
  | Clock period              | 25 min /30 min        | (d) / (e) / (f) | 2-3 h                                                                     | (e)     |

  From these parameters, you can derive a number of desired model
  inputs/outcomes:

  -   The total size of the tissue at the end of somitogenesis
  -   The size of a cell
  -   Speed of division

  Use the model and try to find suitable model parameters to recreate the
  development of both zebrafish and mice: is this model able to describe
  both of these processes? I.e., is this model able to deal with the scale
  differences between zebrafish and mice?

  A couple of notes:

  -   You don't have to exactly recreate the biological parameter with
      100% precision, except for the number of segments/somites, although
      it can be a fun challenge to get a complete match.
  -   You might want to adapt your plotting timestep to have sufficient
      but not too many plot updates in one simulation.
  -   You can test the clock parameters separately with the `clock.py`/`rolling_clock.py`
      script. Don't forget that FGF has an effect on tau!
:::

::: {.content-visible when-meta="params.show_answers"}

  > **Answer** See codes `06_answers_clockplusfgf_memory_mouse.py` and
  `06_answers_clockplusfgf_memory_zebrafish.py`.
  > 
  > **Zebrafish:**
  > 
  > Totaltime: 18 hours for duration of somitogenesis + 10 hours startup phase.
  >
  > Cell width= 30-50 $\mu$ sized somite/5 cells per somite = 6-10 so 8
  > 
  > Growthrate: 30 somites x 5 cells x 8$\mu$ / 18 hours = $1200$\mu$/18*3600$s
  > 
  > For clock frequency:
  > 
  > $\tau$ times 0.25
  > 
  > Fac = 6 (multiplies alpha, beta, mu, v)
  >
  > This gives 32/31 somites with on average 4.9 cells, so perfect.
  > 
  >
  > **Mouse:**
  > 
  > Simply doing the computations would give you: 
  >
  >
  > Totaltime: 5 days for duration of somitogenesis + 15 hours startup phase
  >
  > Cell width = 120$\mu$ sized somite/5-11 cells = $120/8=15$
  >
  > Growthrate: 65 somites x 8 cells x 15$\mu$ / 5 days = $7800/5* 24 *3600$s
  >
  > For clock frequency:
  >
  > $\tau$ times 1.4-1.6 is sufficient (Fac=1 (multiplies alpha, beta, mu, v))
  > 
  > Somehow this does not fully work:
  > 
  > Too few cells (not $65*8=520$) too short tissue (not $65*8*15=7800$) and only 
  > 24 segments. First, remember $\tau_{local}=(1+0.5 *(100-localfgf)/100))*\tau_{global}$. 
  > So $\tau_{local}$ max 1.5 times $\tau_{global}$  so the also increasing $\tau_{global}$ 
  > 1.4-1.6 times 1.5 makes it really slow. Indeed $\tau$ times 1.2 gives 31 segments, $\tau$ 
  > times 1 gives   > 36 segments, $\tau$ times 0.7 gives 49 segments
  > 
  > Good to realize that the numbers in the table do not completely add up:
  > 
  > If it takes 5 days =$5*24=120$ hours, and the period is 2-3 hours this would result 
  > in 40-60 segments but never 65. For a duration of 5.5 days and $\tau$ times 0.6 we 
  > get to 62 somites of size 9, so quite close.

:::

:::{#exr-test}

## Questions for master students

The model currently has a number of assumptions that we can
  question. Feel free to explore any of these further open questions
  and study how it effects the outcome of the model:

-   What if the relationship between FGF and $\tau$ is shaped differently?
    For instance, if the clock runs faster on the left/anterior than on
    the right/posterior?
-   What if the clock state of a daughter cell is started fresh rather
    than being a copy from the mother cell?
-   What if the clock $m$ and $p$ are diluted by growth?
-   What if $\tau$ is unaffected by FGF: can we still get somites fixed in
    place?
:::

::: {.content-visible when-meta="params.show_answers"}

  > **Answer** These are open questions and do not have a single correct answer. Feel free 
  > to discuss with us if you find something interesting or have an interesting answer. 
:::

## Relevant literature

If you want to know more about the model system and previous models,
have a look at the following (after the tutorial):

@lewis2003autoinhibition Autoinhibition with transcriptional delay: a simple mechanism for the zebrafish somitogenesis oscillator. 

@hester2012multi A Multi-cell, Multi-scale Model of Vertebrate Segmentation and Somite Formation. 

@herrgen2010intercellular Intercellular coupling regulates the period of the segmentation clock.

@soroldoni2014doppler Genetic oscillations. A Doppler effect in embryonic pattern formation.

@sonnen2018modulation Modulation of Phase Shift between Wnt and Notch Signaling Oscillations Controls Mesoderm Segmentation. 

@bulusu2017spatiotemporal Spatiotemporal Analysis of a Glycolytic Activity Gradient Linked to Mouse Embryo Mesoderm Development.

@van2025scaling Coupling of cell proliferation to the segmentation clock ensures robust somite scaling.

## References for biological parameters:

(a) @stickney2000somite

(b) @saga2012mechanism

(c) @tam1981control

(d) @ishimatsu2018size

(e) @carraco2022vertebrate

(f) @tomka2018travelling
