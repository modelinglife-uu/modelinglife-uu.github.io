<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>6&nbsp; Cell sorting by differential adhesion – Modeling Life</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./differentiation_intro_text.html" rel="next">
<link href="./morpho_intro_text.html" rel="prev">
<link href="./images/favicon.ico" rel="icon">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<script src="site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./morpho_intro_text.html">II) Morphogenesis</a></li><li class="breadcrumb-item"><a href="./morpho_cpm_practical.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Cell sorting by differential adhesion</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      <img src="./images/android-chrome-512x512.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Modeling life</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false">
 <span class="menu-text">Course information</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Modeling life</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./general.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">General course info</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./schedule.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Schedule</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./slides.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Slides</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro_to_python.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">0) Introduction to Python</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false">
 <span class="menu-text">I) Pattern formation</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pattern_intro_text.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Pattern formation (intro)</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pattern_practical_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Gradients and segments</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pattern_practical_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Turing patterns, repetitive patterning</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pattern_practical_3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Clock-and-wavefront patterning</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">II) Morphogenesis</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./morpho_intro_text.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Introduction to Morphogenesis</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./morpho_cpm_practical.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Cell sorting by differential adhesion</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false">
 <span class="menu-text">III) Cell differentiation</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./differentiation_intro_text.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Cell differentiation introduction</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./differentiation_practical_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Gene regulation in time</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./differentiation_practical_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Gene regulation in space</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false">
 <span class="menu-text">IV) Environment</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./evdev_intro_text.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Environmental inputs</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./evdev_practical.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Modeling Thermomorphogenesis in Plants</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="false">
 <span class="menu-text">V) Evolution</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./evo_intro_text.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Introduction to evolution</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./evo_practical_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Sticking together</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./evo_practical_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">What gets selected?</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./evo_practical_3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Public goods</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="-1">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#morphogenesis" id="toc-morphogenesis" class="nav-link active" data-scroll-target="#morphogenesis"><span class="header-section-number">6.1</span> Morphogenesis</a></li>
  <li><a href="#biological-background" id="toc-biological-background" class="nav-link" data-scroll-target="#biological-background"><span class="header-section-number">6.2</span> Biological background</a></li>
  <li><a href="#the-cellular-potts-glazier-graner-hogeweg-model" id="toc-the-cellular-potts-glazier-graner-hogeweg-model" class="nav-link" data-scroll-target="#the-cellular-potts-glazier-graner-hogeweg-model"><span class="header-section-number">6.3</span> The cellular Potts / Glazier-Graner-Hogeweg model</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">6.4</span> Exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./morpho_intro_text.html">II) Morphogenesis</a></li><li class="breadcrumb-item"><a href="./morpho_cpm_practical.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Cell sorting by differential adhesion</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Cell sorting by differential adhesion</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="morphogenesis" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="morphogenesis"><span class="header-section-number">6.1</span> Morphogenesis</h2>
<p>Morphogenesis is the culmination of gene expression, biochemical signaling, and biophysical forces at the cell and tissue levels. These processes are complex and not completely understood, so we don’t yet have a “perfect” model of how we should simulate morphogenesis. For this reason, several research groups independently developed simulation approaches that fit their needs. In this practical, you will get acquainted with one such approach, the cellular Potts model.</p>
</section>
<section id="biological-background" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="biological-background"><span class="header-section-number">6.2</span> Biological background</h2>
<p>Classical experiments in the 1950s dissociated animal embryonic tissues and recombined them <em>in vitro</em> to try to understand the principles of self-organization. Instead of staying mixed, each cell type sorts out into its own region, resembling the organization in the embryo.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/upscaled_Gilbert_Figure.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Sorting of aggregates of embryonic cells, based on experiments by Townes and Holftreter in 1955. Image adapted from Gilbert “Developmental Biology” 11th edition."><img src="images/upscaled_Gilbert_Figure.png" class="img-fluid figure-img" alt="Sorting of aggregates of embryonic cells, based on experiments by Townes and Holftreter in 1955. Image adapted from Gilbert “Developmental Biology” 11th edition."></a></p>
<figcaption>Sorting of aggregates of embryonic cells, based on experiments by Townes and Holftreter in 1955. Image adapted from Gilbert “Developmental Biology” 11th edition.</figcaption>
</figure>
</div>
<p>According to the “differential adhesion hypothesis”, unlike expression levels of cell-cell adhesion molecules is the mechanistic driver of cell sorting. Biophysically, cells form aggregates that minimize the contact energy at interfaces, rearranging into the most thermodynamically stable pattern. In 1992, the cellular Potts model was developed to test this hypothesis using simulations (<span class="citation" data-cites="graner1992simulation">Graner and Glazier (<a href="references.html#ref-graner1992simulation" role="doc-biblioref">1992</a>)</span>).</p>
</section>
<section id="the-cellular-potts-glazier-graner-hogeweg-model" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="the-cellular-potts-glazier-graner-hogeweg-model"><span class="header-section-number">6.3</span> The cellular Potts / Glazier-Graner-Hogeweg model</h2>
<p>The cellular Potts Model (CPM), also known as Glazier-Graner-Hogeweg (GGH) model after its major developers and popularizers, simulates stochastic dynamics of cell shapes on a grid (=a <strong>lattice</strong>). The model has its historical roots in physical models of magnetization of metals and formation of foam bubbles, so some of the terminology harkens back to that. Each grid site on the lattice has a <strong>spin</strong> value <em>σ</em> (Greek small letter sigma), usually an integer number. A biological cell is represented by all lattice sites with equal value <em>σ</em>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/sigma_field.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Example of a σ field with four unique integer values. The value 0 is reserved for the medium, while the non-zero values represent three cells."><img src="images/sigma_field.png" class="img-fluid figure-img" style="width:30.0%" alt="Example of a σ field with four unique integer values. The value 0 is reserved for the medium, while the non-zero values represent three cells."></a></p>
<figcaption>Example of a σ field with four unique integer values. The value 0 is reserved for the medium, while the non-zero values represent three cells.</figcaption>
</figure>
</div>
<p>Cell shapes change by elementary changes called <strong>copy attempts</strong>, where one site of the lattice (the source site <em>x<sub>S</sub></em>) attempts to copy its <em>σ</em> value to a neighboring lattice site (the target site <em>x<sub>T</sub></em>). Copy attempts can succeed (be accepted) or fail (be rejected).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/copy_attempt.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Every copy attempt affects a pair of neighboring lattice sites."><img src="images/copy_attempt.png" class="img-fluid figure-img" alt="Every copy attempt affects a pair of neighboring lattice sites."></a></p>
<figcaption>Every copy attempt affects a pair of neighboring lattice sites.</figcaption>
</figure>
</div>
<p>Choosing and accepting copy attempts occurs via a stochastic <strong>Monte Carlo</strong> method. More specifically, a modified Metropolis-Hastings algorithm, which is an algorithm that minimizes an energy function H calculated based on the lattice configuration. The probability that a copy attempt is accepted <em>P</em>(accept) depends on the change in energy <em>ΔH</em> between the configuration before and after a copy attempt:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/acceptance.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Equation 1."><img src="images/acceptance.png" class="img-fluid figure-img" style="width:70.0%" alt="Equation 1."></a></p>
<figcaption>Equation 1.</figcaption>
</figure>
</div>
<p>In the above equation, <em>T</em> is a parameter that determines how likely it is that an unfavorable copy attempt that increases the energy is accepted, while <em>H<sub>0</sub></em> is a parameter representing the yield, that is, how easily the cell membrane changes shape (often, this parameter is set to <em>H<sub>0</sub> = 0</em>). What this equation says is: Configurational changes that lower the energy below at least <em>H<sub>0</sub></em> are always accepted (probability of 1), while configurational changes that increase the energy are accepted with a probability that decreases exponentially with the energy cost. In a biological sense, cells consume energy from ATP to create configurations that are physically unfavorable (<em>ΔH ≥ -H<sub>0</sub></em>). Therefore, the parameter <em>T</em> can be interpreted as intrinsic cell activity.</p>
</section>
<section id="exercises" class="level2" data-number="6.4">
<h2 data-number="6.4" class="anchored" data-anchor-id="exercises"><span class="header-section-number">6.4</span> Exercises</h2>
<div id="exr-non" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 6.1 (Algorithmic thinking - Anatomy of a cellular Potts model)</strong></span> A minimal cellular Potts model simulation of cell sorting contains the following ingredients:</p>
<ul>
<li>definition of the “sigma field”</li>
<li>definition of the “tau field”</li>
<li>the initial condition of sigma and tau fields</li>
<li>the neighborhood of a grid site</li>
<li>a Monte Carlo stepping procedure</li>
<li>definition and calculation of the energy function H</li>
</ul>
<p>Study the code provided in the script <code>01_cpm.py</code>. Then, answer the following questions:</p>
<ul>
<li>Which functions in the script correspond to the above ingredients?</li>
<li>What is the default initial condition?</li>
<li>What is the default neighborhood?</li>
<li>Run the script and observe the plots that appear. Explain in your own words what is the sigma field and what is the tau field. Do you understand why two different fields are needed?</li>
</ul>
</div>
<blockquote class="blockquote">
<p><strong>Answer</strong> Both the sigma and tau fields are defined in the function <code>initialize</code>. This is also where the initial conditions for these fields are set. Different modes of initialization can be selected by changing the value of the variable <code>init_mode</code> that is passed in the dictionary of simulation parameters.</p>
<p>The neighborhood of a grid site is defined in the function <code>get_neighborhood</code>. This function specifies which neighboring sites will be considered for all calculations that involve neighboring sites. The type of neighborhood (e.g., Von Neumann or Moore) can be selected by changing the value of the variable <code>neighborhood</code> in the dictionary of simulation parameters.</p>
<p>The Monte Carlo stepping procedure is defined in the function <code>monte_carlo_step</code>. This function implements the core logic of the Monte Carlo algorithm, including selecting random sites, proposing changes, and accepting or rejecting those changes based on energy calculations.</p>
<p>The definition and calculation of the energy function H is implemented in different functions: <code>get_dH_adhesion</code> and <code>get_dH_volume</code> calculate contributions of individual terms and are then summed together in the function <code>calc_dH</code>, which is called by <code>monte_carlo_step</code>.</p>
<p>Running the code generates a plot with two subplots. The left one shows cells colored with a unique color according to their sigma value. The right subplot shows the tau field, where different cell types are colored differently according to their tau value.</p>
</blockquote>
<p><img src="images/6.1__0_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of a simulation run.</p>
<div id="exr-non" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 6.2 (Conceptual thinking - Interpreting the Hamiltonian energy function)</strong></span> The <strong>Hamiltonian</strong> energy function <em>H</em> is at the heart of a CPM/GGH simulation. <em>H</em> reflects our assumptions about the system and how forces affect the cell (the derivative of energy with respect to position is force).</p>
<p>In the script <code>01_cpm.py</code>, the following Hamiltonian is used.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/Hamiltonian.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Equation 2."><img src="images/Hamiltonian.png" class="img-fluid figure-img" alt="Equation 2."></a></p>
<figcaption>Equation 2.</figcaption>
</figure>
</div>
<p>where <em>J</em> is a symmetric matrix of interfacial energies for all cell type pairs <em>τ</em> (small Greek letter tau), <em>A(σ)</em> is the area sum of lattice sites belonging to spin <em>σ</em>, <em>A<sub>0,τ(σ)</sub></em> is the “target” area of the corresponding cell type <em>τ</em>, and <em>λ<sub>A(τ(σ))</sub></em> is a weighting factor that scales the importance of this term (also known as <strong>Lagrange multiplier</strong>). Each term represents a <strong>constraint</strong>.</p>
<p>Perhaps a more intuitive way to understand the terms is the following pseudo-code:</p>
<p><a href="images/pseudocode_table.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6"><img src="images/pseudocode_table.png" id="vegmini1" class="img-fluid" style="width:130.0%"></a></p>
<p>Compare the pseudo-code to the implementation in the script. Then answer the following questions:</p>
<ul>
<li>What are the biological processes modeled with this specific energy function?</li>
<li>Take a closer look at the summation terms. Over which domain is the first sum calculated? What about the second summation term?</li>
</ul>
</div>
<blockquote class="blockquote">
<p><strong>Answer</strong> The first Hamiltonian term corresponds to the function <code>get_dH_adhesion</code> and the second Hamiltonian term corresponds to the function <code>get_dH_volume</code>. The biological process calculated by <code>get_dH_adhesion</code> is the energy from cell-cell and cell-medium contacts. The energy of cell-cell contacts depends on the expression levels and the types of cell-cell adhesion molecules such as cadherins. The interfacial energy of cell-medium contacts depends on the expression levels and types of cell-matrix adhesion molecules such as integrins.</p>
<p>The biological process calculated by <code>get_dH_volume</code> is the effect of a combination of internal pressure and cytoskeletal tension that maintains the cell’s volume close to a homeostatic (target) volume.</p>
<p>The first Hamiltonian term sums over neighbours of the selected target site. The second Hamiltonian term sums over lattice sites of the sigma values that correspond to the target and the source sites.</p>
</blockquote>
<div id="exr-non" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 6.3 (Conceptual thinking - How parameters affect the Hamiltonian energy function)</strong></span> The modified Metropolis algorithm used in the Monte Carlo stepping procedure ensures that over time, on average, the sum of the energy of the entire sigma field will reach a minimum. However, the different Hamiltonian terms may work “against” each other: minimizing one term may lead to maximizing the value of the other term.</p>
<p>Let’s vary the parameters that affect the Hamiltonian terms to get an intuition for how they work. In the following, you may want to take screenshots of the final simulation state to put in your notes, so that it’s easier to compare the outputs.</p>
<ul>
<li>Change the default neighborhood to <code>“8”</code> and run the simulation again. What happens?</li>
<li>Keep the neighborhood at <code>“8”</code>, and increase the parameter for <code>“volume_weight”</code> from <code>[1, 1]</code> to <code>[2, 1]</code>. Then, run the simulation again. What happens?</li>
<li>Change the initialization mode (<code>“init_mode”</code>) from <code>“random_pixel”</code> to <code>“square_grid”</code>, and reset the parameter <code>“volume_weight”</code> to <code>[1, 1]</code>. What happens now if you simulate?</li>
<li>Explain why these settings and parameters that you just changed affect the simulation outcome.</li>
</ul>
</div>
<blockquote class="blockquote">
<p><strong>Answer</strong></p>
<p><strong>Reference simulation with default parameters</strong> Using default parameters, the simulation results in a small group of cells that adhere to each other and maintain their target volume.</p>
</blockquote>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/6.3__0_default_sim.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Reference simulation using default parameters"><img src="images/6.3__0_default_sim.png" class="img-fluid figure-img" alt="Reference simulation using default parameters"></a></p>
<figcaption>Reference simulation using default parameters</figcaption>
</figure>
</div>
<p><em>Figure:</em> Simulation using default parameters.</p>
<blockquote class="blockquote">
<p><strong>Changing neighborhood from “4” to “8”</strong> Increasing the neighborhood from “4” to “8” causes most cells to disappear. In most simulations there are no cells left at all.</p>
</blockquote>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/6.3__1_neighborhood_8.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Simulation with neighborhood changed to “8”"><img src="images/6.3__1_neighborhood_8.png" class="img-fluid figure-img" alt="Simulation with neighborhood changed to “8”"></a></p>
<figcaption>Simulation with neighborhood changed to “8”</figcaption>
</figure>
</div>
<p><em>Figure:</em> Simulation with neighborhood changed to “8”</p>
<blockquote class="blockquote">
<p><strong>Changing neighborhood from “4” to “8” and increasing “volume_weight” from [1, 1] to [2, 1]</strong> Again many cells disappear. The cells that remain tend to be of tau type 1 (corresponding to the red color).</p>
</blockquote>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/6.3__2_neighborhood_8_volumeweight_2-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="Simulation with neighborhood changed to “8”"><img src="images/6.3__2_neighborhood_8_volumeweight_2-1.png" class="img-fluid figure-img" alt="Simulation with neighborhood changed to “8”"></a></p>
<figcaption>Simulation with neighborhood changed to “8”</figcaption>
</figure>
</div>
<p><em>Figure:</em> Simulation with neighborhood changed to “8” and volume weight changed to [2, 1].</p>
<blockquote class="blockquote">
<p><strong>Changing neighborhood from “4” to “8” and initialization mode from “random_pixel” to “square_grid”</strong></p>
<p>With these changes, the cells are more likely to remain present throughout the simulation, regardless of their type.</p>
</blockquote>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/6.3__3_neighborhood_8_initmode_squaregrid.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="Simulation with neighborhood changed to “8” and initialization mode changed to “square_grid”"><img src="images/6.3__3_neighborhood_8_initmode_squaregrid.png" class="img-fluid figure-img" alt="Simulation with neighborhood changed to “8” and initialization mode changed to “square_grid”"></a></p>
<figcaption>Simulation with neighborhood changed to “8” and initialization mode changed to “square_grid”</figcaption>
</figure>
</div>
<blockquote class="blockquote">
<p><strong>Explanation of the observed effects</strong></p>
<p>Changing the neighborhood from “4” to “8” increases the number of neighboring sites considered for the first term (the adhesion energy) of the Hamiltonian energy calculation, which sums over the neighbors of the target site. This can lead to a higher likelihood of unfavorable interactions, causing cells to disappear if they start from a 1-pixel size, especially since adhesion to the medium is costly according to the default parameter set.</p>
<p>Changing the volume weight for tau type 1 cells from 1 to 2 increases the penalty for deviating from the target volume for these cells. This increases the contribution of the second term (the volume energy) of the Hamiltonian energy calculation. Thus, it makes it energetically less favorable for them to be copied into when they are small (1-pixel sized), leading to a <em>lower</em> chance of disappearance. In other words, the second term is now offsetting the effect of the first term more strongly for cells of tau type 1.</p>
<p>In the “random_pixel” mode, cells start as single pixels scattered randomly, making them highly susceptible to disappearance due to unfavorable cell-medium interactions. In the “square_grid” initialization mode, cells start off as a 9-pixel square in relative close proximity to other cells. With a few lucky copy attempts, they can get in contact with other cells, which has a more favorable adhesion energy compared to being in contact with the medium. This and the fact that they start out with a larger area, prevents cells from shrinking away immediately.</p>
</blockquote>
<div id="exr-non" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 6.4 (Algorithmic thinking - The Monte Carlo update algorithm)</strong></span> In addition to showing a visualization of the <em>σ</em> and <em>τ</em> fields, the script <code>01_cpm.py</code> also prints some information to the terminal.</p>
<p>Reset all parameters to their default values, then, based on the printed information, answer the following questions:</p>
<ul>
<li>How many copy attempts are made in total in one Monte Carlo Step?</li>
<li>How many of these copy attempts are accepted on average?
<ul>
<li>Calculate the average for 5 Monte Carlo Steps across 3 simulation runs.</li>
</ul></li>
<li>How many seconds does it take to run one simulation?
<ul>
<li>Calculate the average run time for 3 runs.</li>
</ul></li>
</ul>
<p>The script <code>01_cpm.py</code> uses the traditional update algorithm. In this algorithm, every copy attempt picks a target site randomly among all lattice sites, then subsequently picks a source site randomly among the neighbors of the target site. This leads to many invalid lattice pairs that are always rejected. The edge list algorithm is a clever way of speeding up this procedure by restricting copy attempts only to those interfaces where there is a possibility of acceptance.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/edgelist.png" class="lightbox" data-gallery="quarto-lightbox-gallery-11" title="Since a copy attempt affects a pair of neighboring lattice sites, we can keep track of valid pairs (productive site pairs). These can be represented by an edge, i.e.&nbsp;an arrow pointing from one site to the other. Edges have a directionality, so two neighboring sites are always joined by two edges with opposing direction."><img src="images/edgelist.png" class="img-fluid figure-img" alt="Since a copy attempt affects a pair of neighboring lattice sites, we can keep track of valid pairs (productive site pairs). These can be represented by an edge, i.e.&nbsp;an arrow pointing from one site to the other. Edges have a directionality, so two neighboring sites are always joined by two edges with opposing direction."></a></p>
<figcaption>Since a copy attempt affects a pair of neighboring lattice sites, we can keep track of valid pairs (productive site pairs). These can be represented by an edge, i.e.&nbsp;an arrow pointing from one site to the other. Edges have a directionality, so two neighboring sites are always joined by two edges with opposing direction.</figcaption>
</figure>
</div>
<p>The script <code>02_cpm_edgelist.py</code> implements the edge list algorithm. It’s quite complicated, so don’t worry about understanding all the technical details. Using this script, answer the above questions again and compare to the results you got with the traditional update algorithm.</p>
<p>Explain: Why does the edgelist algorithm reduce computation time? In which situations would you expect the difference in computation time between algorithms to be large?</p>
</div>
<blockquote class="blockquote">
<p><strong>Answer</strong> Each Monte Carlo steps consists of 2500 copy attempts. This is equal to the number of lattice sites in the 50x50 grid.</p>
<h3 id="script-01_cpm.py" class="anchored">Script 01_cpm.py</h3>
<p>For the sake of simplicity, I will pick the last 5 Monte Carlo steps across 3 simulations to calculate the averages. Note however that the proportion of accepted copy attempts varies over time, and is particularly quite different at the beginning of the simulation.</p>
</blockquote>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>sim 1</th>
<th>sim 2</th>
<th>sim 3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MCS 96</td>
<td>92</td>
<td>62</td>
<td>74</td>
</tr>
<tr class="even">
<td>MCS 97</td>
<td>97</td>
<td>93</td>
<td>75</td>
</tr>
<tr class="odd">
<td>MCS 98</td>
<td>69</td>
<td>74</td>
<td>54</td>
</tr>
<tr class="even">
<td>MCS 99</td>
<td>94</td>
<td>99</td>
<td>73</td>
</tr>
<tr class="odd">
<td>MCS100</td>
<td>74</td>
<td>77</td>
<td>86</td>
</tr>
<tr class="even">
<td>Average</td>
<td>85.2</td>
<td>81</td>
<td>72.4</td>
</tr>
</tbody>
</table>
<blockquote class="blockquote">
<p>The average accepted copy attempts is 79.5. This corresponds to an acceptance proportion of 3.18%</p>
</blockquote>
<blockquote class="blockquote">
<p>In terms of runtime, on my machine the simulations took 22.99 seconds, 18.67 seconds, and 18.54 seconds. On average, this makes 20.1 seconds per simulation.</p>
</blockquote>
<blockquote class="blockquote">
<h3 id="script-02_cpm_edgelist.py" class="anchored">Script 02_cpm_edgelist.py</h3>
</blockquote>
<blockquote class="blockquote">
<p>Again, I will pick the last 5 Monte Carlo steps across 3 simulations to calculate the averages.</p>
</blockquote>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>sim 1</th>
<th>sim 2</th>
<th>sim 3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MCS 96</td>
<td>275</td>
<td>266</td>
<td>245</td>
</tr>
<tr class="even">
<td>MCS 97</td>
<td>273</td>
<td>258</td>
<td>257</td>
</tr>
<tr class="odd">
<td>MCS 98</td>
<td>280</td>
<td>261</td>
<td>247</td>
</tr>
<tr class="even">
<td>MCS 99</td>
<td>281</td>
<td>252</td>
<td>246</td>
</tr>
<tr class="odd">
<td>MCS100</td>
<td>277</td>
<td>246</td>
<td>252</td>
</tr>
<tr class="even">
<td>Average</td>
<td>277.2</td>
<td>256.6</td>
<td>249.4</td>
</tr>
</tbody>
</table>
<blockquote class="blockquote">
<p>The average accepted copy attempts is 261.1.</p>
<p>Note that calculating the acceptance proportion requires also noting down the number of total copy attempts in the respective Monte Carlo Step. Approximately 70% of copy attempts are accepted.</p>
<p>In terms of runtime, on my machine the simulations took 15.33 seconds, 14.57 seconds, and 14.6 seconds. On average, this makes 14.8 seconds per simulation.</p>
</blockquote>
<blockquote class="blockquote">
<h3 id="explanation-of-edge-list-performance-improvement" class="anchored">Explanation of edge list performance improvement</h3>
<p>In the standard implementation, many copy attempts are made on lattice sites that are completely surrounded by pixels of the same sigma value. These copy attempts will always be rejected as they would not change the configuration. By maintaining an edge list of pairs of neighboring pixels with unlike sigma value, the edge list implementation ensures that every copy attempt has the potential to change the configuration. This not only leads to a much higher acceptance rate, but also completely eliminates unproductive copy attempts. By avoiding wasting time with unproductive copy attempts, the edge list implementation achieves a significant performance improvement.</p>
<p>Note that the edge list algorithm implemented here is based on the following publication: <span class="citation" data-cites="de2024shapes">Jong et al. (<a href="references.html#ref-de2024shapes" role="doc-biblioref">2024</a>)</span></p>
</blockquote>
<div id="exr-non" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 6.5 (Biology - Expanding the Hamiltonian)</strong></span> Suppose you want to add more mechanisms for cell shape changes to the model. This would involve the following steps:</p>
<ol type="1">
<li>Coming up with a hypothesis on how forces act on the cell shape.</li>
<li>Deriving a mathematical function that establishes the energy balance.</li>
<li>Add an additional function to the code that calculates the energy based on the cell configuration.</li>
<li>Call this function in the code that calculates the energy differential.</li>
</ol>
<p>Let’s walk through these steps together to create a <strong>perimeter constraint</strong>.</p>
<ol type="1">
<li><p>Animal cells possess a contractile actomyosin cortex connected to the cell membrane via actin-membrane linker proteins. Cortex contraction is regulated to maintain homeostasis of the membrane tension. Simply put, if the cell membrane gets “floppy”, the cortex contracts to pull the membrane in. Vice-versa, if the membrane is too tense, cortex contractility is reduced to allow the membrane to relax. We thus could advance the hypothesis that forces from the actin cortex strive to maintain a constant cell surface area.</p></li>
<li><p>We want cell surface area to reach a target homeostatic value <em>S<sub>0</sub></em>. Let’s call the actual cell surface area <em>S</em>. We need a function that has a minimum where <em>S<sub>0</sub> = S</em> and increases if <em>S</em> is larger or smaller than <em>S<sub>0</sub></em>. A simple function that does the trick is the parabola <em>(S- S<sub>0</sub>)<sup>2</sup></em>. We may also want to tune how much this term influences the entire Hamiltonian, so we introduce the weight factor <em>λ<sub>S</sub></em>. We also consider that both <em>S<sub>0</sub></em> and <em>λ<sub>S</sub></em> may depend on cell type <em>τ</em>.</p></li>
</ol>
<p>Thus, we write:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="images/perimeter.png" class="lightbox" data-gallery="quarto-lightbox-gallery-12" title="Equation 3."><img src="images/perimeter.png" class="img-fluid figure-img" style="width:60.0%" alt="Equation 3."></a></p>
<figcaption>Equation 3.</figcaption>
</figure>
</div>
<ul>
<li>For the implementation of steps 3 and 4, consult the script <code>03_cpm_perimeter.py</code>.</li>
<li>Study the new additions to the script (search for the string: <code>### NEW ###</code> to find them quickly), then run the simulation. Vary the parameters to gain an intuition of how this new Hamiltonian term affects the simulation outcome.</li>
<li>You may have noticed the simulation is running more slowly than before. Review the new code additions again. Can you identify any potential reasons for this decrease in computation speed?</li>
</ul>
</div>
<blockquote class="blockquote">
<p><strong>Answer</strong></p>
<h3 id="reference-simulation-with-default-parameters" class="anchored">Reference simulation with default parameters</h3>
<p>The default parameters in the script <code>03_cpm_perimeter.py</code> are set such that the cell type with tau = 2 (purple cells) have a higher homeostatic surface area (perimeter in 2D), while still having the same homeostatic volume as the cell type with tau = 1 (red cells). As a result, the purple cells have a ruffled appearance with long “protrusions” and even break apart into pieces, while the red cells stay more compact.</p>
</blockquote>
<p><img src="images/6.5__0_default_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of a simulation run using the default parameters.</p>
<blockquote class="blockquote">
<h3 id="changing-surface_weight-from-1-1-to-1-5" class="anchored">Changing “surface_weight” from [1, 1] to [1, 5]</h3>
<p>Increasing the surface_weight for tau type 2 cells from 1 to 5 increases the penalty for deviating from the homeostatic surface area for these cells. Since the surface term was already quite dominant for these cells, this change does not impact the final result much.</p>
</blockquote>
<p><img src="images/6.5__1_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of a simulation run.</p>
<blockquote class="blockquote">
<h3 id="changing-surface_weight-from-1-1-to-1-0.2" class="anchored">Changing “surface_weight” from [1, 1] to [1, 0.2]</h3>
<p>Decreasing the surface_weight for tau type 2 cells from 1 to 0.2 decreases the penalty for deviating from the homeostatic surface area for these cells. As a result, these cells are now much more compact, but still show more protrusions than tau type 1 cells.</p>
</blockquote>
<p><img src="images/6.5__2_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation run.</p>
<blockquote class="blockquote">
<h3 id="changing-surface_weight-from-1-1-to-5-1" class="anchored">Changing “surface_weight” from [1, 1] to [5, 1]</h3>
<p>Increasing the surface_weight for tau type 1 cells from 1 to 5 increases the penalty for deviating from the homeostatic surface area for these cells. However, the cells hardly change their appearance compared to the default simulation. Probably, the homeostatic surface area is already quite close to the actual surface area, so increasing the weight does not have a big effect.</p>
</blockquote>
<p><img src="images/6.5__3_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation run.</p>
<blockquote class="blockquote">
<h3 id="changing-surface_weight-from-1-1-to-5-1-and-surface_ideal-from-20-80-to-40-80" class="anchored">Changing “surface_weight” from [1, 1] to [5, 1] and “surface_ideal” from [20, 80] to [40, 80]</h3>
<p>Now both the red and purple cells form ruffles. The ruffles of the red cells are less pronounced than those of the purple cells, since their homeostatic surface area is not quite as high as the purple cells’.</p>
</blockquote>
<p><img src="images/6.5__4_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation run.</p>
<blockquote class="blockquote">
<h3 id="changing-surface_ideal-from-20-80-to-10-10" class="anchored">Changing “surface_ideal” from [20, 80] to [10, 10]</h3>
<p>The surface_weight was kept at the default value of [1, 1]. Reducing the homeostatic surface area for both cell types to a low value of 10 causes both cell types to become very small and compact, with hardly any movement. Note also how the cells take on a square appearance. This is because of the 4-neighborhood that is used in the simulation, which favors straight edges aligned with the grid.</p>
</blockquote>
<p><img src="images/6.5__5_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation run.</p>
<blockquote class="blockquote">
<h3 id="why-is-the-performance-worse" class="anchored">Why is the performance worse?</h3>
<p>Even though script <code>03_cpm_perimeter.py</code> is based on <code>02_cpm_edgelist.py</code> and thus uses the efficient edge list implementation of the Monte Carlo algorithm, it runs quite a bit slower. The reason for this is that calculating the surface area of a cell involves checking the neighborhood of each pixel of the cell to see how many of its neighbors belong to a different cell (or to the medium). Even though this is only done for non-zero source and target site sigmas (i.e.&nbsp;at most two cells per copy attempt), there are hundreds of copy attempts each Monte Carlo Step, so the calculation time adds up quickly. This computational overhead leads to a slower overall simulation time.</p>
</blockquote>
<div id="exr-non" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 6.6 (Biology - Imposing cell connectivity)</strong></span> In the previous simulations you ran, you may have noticed that cells sometimes break up into disjointed fragments. There are two alternative ways to prevent this: 1. Add a new Hamiltonian term that penalizes copy attempts that would break up the cell. 2. Modify the update algorithm to always reject copies that would break cells apart.</p>
<p>Script <code>04_cpm_connectivity.py</code> implements the second option using a flood fill algorithm to count the number of contiguous pixels of the non-medium target cell supposing that a copy succeeded.</p>
<p>Try out the simulation!</p>
<ul>
<li>Can you think of advantages and disadvantages to using the first or second option?</li>
<li>Once again, the simulation is running more slowly than before. What parts of the new code do you suspect may be causing the slowdown?</li>
</ul>
</div>
<blockquote class="blockquote">
<p><strong>Answer</strong></p>
<h3 id="advantages-disadvantages-to-the-two-implementations" class="anchored">Advantages &amp; Disadvantages to the two implementations</h3>
<p>Arguably, it should be possible for a cell to lose fragments. This is in fact frequently observed in cell culture. Physically, this happens when the forces exerted on parts of the cell are sufficient to rip apart the lipid membrane. As long as the “tear” is small enough, the membrane can reseal itself within a matter of milliseconds, so the cell can survive. This is also what allows us to experimentally microinject substances into cells (e.g.&nbsp;microinjections are routinely done in labs when manipulating fish embryos, <em>C. elegans</em>, or oocytes of mammals). Therefore, if one is aiming for physical realism, then it might be reasonable to enable cells to lose fragments. However, note that in the default CPM implementation, the fragments still “know” which cell they originally belonged to, since they keep their sigma value. A more realistic implementation would require adding additional logic to reassign the sigma value of fragments to new values, effectively creating new cells. This would however also require adding logic to prevent these cells from doing normal biological behavior, since fragments should not have a nucleus or other organelles.</p>
<p>The second option completely forbids fragmentation, and is computationally easier to implement, as there is no need to treat fragments in a special way. The fact that this approach ignores the physical reality may not really matter for most models. We are after all simplifying reality anyway, so as long as the model captures the essential biological behavior of interest, it should be fine.</p>
<h3 id="why-is-the-performance-worse-1" class="anchored">Why is the performance worse?</h3>
<p>Again there is a performance drop by adding a new feature. This is because checking for connectivity involves performing a flood-fill algorithm starting from one pixel of the cell and marking all connected pixels. This requires checking the neighborhood of each pixel of the cell, which becomes computationally expensive. Since this check needs to be performed for every copy attempt that involves a non-zero target sigma, the computational overhead accumulates quickly, leading to a slower overall simulation time.</p>
</blockquote>
<div id="exr-non" class="theorem exercise">
<p><span class="theorem-title"><strong>Exercise 6.7 (Biology - Exploring differential adhesion and cell sorting)</strong></span> Now let’s explore how changing adhesion affinities leads to different sorted cell configurations. To do that, you will need to run simulations for a longer time. To speed up computations, you will be using an optimized package (many scripts working together), which is contained in the folder <code>“cellularPotts”</code>. To make visualizations super-fast, this package uses the <code>PyQt5</code> module, which should be installed by default with your Anaconda distribution.</p>
<p><em>Note: If for some reason you cannot get <code>PyQt5</code> to work, there is an alternative package that uses matplotlib <code>“cellularPotts_MPL”</code>. However, this runs much slower.</em></p>
<p>To launch the simulation, run the <code>main.py</code> file in the <code>cellularPotts</code> folder. You can change the parameters by adjusting values in the <code>parameters.py</code> file.</p>
<p>Adjust the values of the adhesion table for the two cell types:</p>
<ul>
<li>Set equal adhesion affinities for all cell-cell interactions. Leave affinity to the medium at a low value.</li>
<li>Set the adhesion affinity of cell type 1 to itself to a larger value.</li>
<li>Set the affinities such that cell-medium interactions are more favorable than any cell-cell interactions.</li>
<li>Explore how other parameters such as volume and surface constraints affect the cell sorting simulations.</li>
</ul>
<p><em>(Master students)</em> Add a third cell type to the simulation by editing the <code>parameter.py</code> file. Can you get a sorted configuration where cell type 1 envelops cell type 2, which itself envelops cell type 3?</p>
</div>
<blockquote class="blockquote">
<p><strong>Answer</strong> ### Reference simulation with default parameters Note that the way the code of the CPM package is set up, the signs get flipped internally. Therefore, a more positive value implies stronger adhesion, and a more negative value implies repulsion.</p>
</blockquote>
<pre><code>adhesion_table = np.array([
    [     0,   0,    0], # adhesion medium - partner
    [   -16,  -2,    0], # adhesion cell type 1 - partner
    [   -16, -11,  -14], # adhesion cell type 2 - partner
])</code></pre>
<p><img src="images/6.7__0_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation run using default parameters. &gt; &gt; Cells create a sorted configuration with cell type 2 (magenta) enveloping cell type 1 (blue). Both cells have the same very negative adhesion energy to the medium, which means they try to minimize cell-medium contacts.Cell type 1 has a much stronger adhesion to itself than to cell type 2. Heterotypic adhesion (cell type 1 contacting cell type 2) is also energetically less favourable than cell type 1 sticking to itself. Therefore, cell type 1 clusters together to maximize self-interactions and minimize interactions with cell type 2 and the medium. For cell type 2, the adhesion to itself is actually slightly less favorable than adhesion to cell type 1. Thus, cell type 2 ends up surrounding cell type 1 to minimize contacts with the medium and maximizing contacts with cell type 1.</p>
<blockquote class="blockquote">
<h3 id="setting-all-cell-cell-adhesions-equal-to--5" class="anchored">Setting all cell-cell adhesions equal to -5</h3>
</blockquote>
<pre><code>adhesion_table = np.array([
    [     0,   0,    0], # adhesion medium - partner
    [   -16,  -5,    0], # adhesion cell type 1 - partner
    [   -16,  -5,   -5], # adhesion cell type 2 - partner
])</code></pre>
<p><img src="images/6.7__1_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation.</p>
<blockquote class="blockquote">
<p>Setting all cell-cell interactions equal (but smaller than cell-medium interactions) leads to a mixed configuration. Both cell types try to minimize contacts with the medium, but since they have equal adhesion to each other, there is no driving force for sorting.</p>
</blockquote>
<blockquote class="blockquote">
<h3 id="setting-cell-type-1-adhesion-to-itself-very-high--2-and-all-other-adhesions-to--16" class="anchored">Setting cell type 1 adhesion to itself very high (-2), and all other adhesions to -16</h3>
</blockquote>
<pre><code>adhesion_table = np.array([
    [     0,   0,    0], # adhesion medium - partner
    [   -16,  -2,    0], # adhesion cell type 1 - partner
    [   -16, -16,  -16], # adhesion cell type 2 - partner
])</code></pre>
<p><img src="images/6.7__3_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation.</p>
<blockquote class="blockquote">
<p>Cell type 1 (blue) is strongly cohesive, and creates clusters. The clusters have a hard time moving through cell type 2 (magenta), since heterotypic adhesion is very unfavorable. As a result, cell type 1 clusters remain more or less where they started. Letting the simulation continue for longer will eventually result in cell type 1 clusters merging together, as this minimizes the total interfacial energy.</p>
<h3 id="setting-cell-cell-affinities-lower-than-cell-medium-affinities" class="anchored">Setting cell-cell affinities lower than cell-medium affinities</h3>
</blockquote>
<pre><code>adhesion_table = np.array([
    [     0,   0,    0], # adhesion medium - partner
    [    -5, -10,    0], # adhesion cell type 1 - partner
    [    -5, -10,  -10], # adhesion cell type 2 - partner
])</code></pre>
<p><img src="images/6.7__4_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation.</p>
<pre><code>adhesion_table = np.array([
    [    0,    0,    0], # adhesion medium - partner
    [   -2,  -10,    0], # adhesion cell type 1 - partner
    [   -2,  -10,  -10], # adhesion cell type 2 - partner
])</code></pre>
<p><img src="images/6.7__8_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation.</p>
<blockquote class="blockquote">
<p>Cells now take a highly ruffled appearance as they attempt to maximize cell-medium contacts and minimize cell-cell contacts. The stronger the cell-medium adhesion (i.e., the closer to zero the adhesion values get), the more likely it is that cells will individualize and avoid cell-cell contacts.</p>
</blockquote>
<blockquote class="blockquote">
<h3 id="making-heterotypic-affinity-most-favorable" class="anchored">Making heterotypic affinity most favorable</h3>
</blockquote>
<pre><code>adhesion_table = np.array([
    [     0,   0,    0], # adhesion medium - partner
    [   -16, -10,    0], # adhesion cell type 1 - partner
    [   -16,  -2,  -10], # adhesion cell type 2 - partner
])</code></pre>
<p><img src="images/6.7__5_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation.</p>
<blockquote class="blockquote">
<p>Cells form a checkerboard-like pattern, maximizing heterotypic contacts and minimizing homotypic contacts as well as cell-medium contacts.</p>
</blockquote>
<blockquote class="blockquote">
<h3 id="highly-cohesive-cells" class="anchored">Highly cohesive cells</h3>
</blockquote>
<pre><code>adhesion_table = np.array([
    [     0,   0,    0], # adhesion medium - partner
    [   -16,  -2,    0], # adhesion cell type 1 - partner
    [   -16, -15,   -2], # adhesion cell type 2 - partner
])</code></pre>
<p><img src="images/6.7__6_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation.</p>
<blockquote class="blockquote">
<p>Cells form outbulging clusters that attempt to separate.</p>
</blockquote>
<blockquote class="blockquote">
<h3 id="very-high-cost-to-cell-medium-contacts" class="anchored">Very high cost to cell-medium contacts</h3>
</blockquote>
<pre><code>adhesion_table = np.array([
    [     0,   0,    0], # adhesion medium - partner
    [   -66,  -2,    0], # adhesion cell type 1 - partner
    [   -66, -15,   -2], # adhesion cell type 2 - partner
])</code></pre>
<p><img src="images/6.7__7_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation.</p>
<blockquote class="blockquote">
<p>Dispropportionally increasing one parameter makes copy attempts involving that parameter (in this case cell-medium adhesion) extremely improbable. This leads to lattice artifacts becoming more pronounced.</p>
</blockquote>
<blockquote class="blockquote">
<h3 id="highly-motile-clusters" class="anchored">Highly motile clusters</h3>
</blockquote>
<pre><code>adhesion_table = np.array([
    [    0,    0,    0], # adhesion medium - partner
    [   -2,  -10,    0], # adhesion cell type 1 - partner
    [   -2,  -10,   -2], # adhesion cell type 2 - partner
])</code></pre>
<p><img src="images/6.7__9_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation.</p>
<blockquote class="blockquote">
<p>Cells that are both highly adherent to each other and to the medium can form motile clusters that move through the medium while maintaining their integrity.</p>
<h2 id="adding-a-third-cell-type-and-concentric-sorting" data-number="6.5" class="anchored"><span class="header-section-number">6.5</span> Adding a third cell type and concentric sorting</h2>
<p>Adding a third cell type is pretty straightforward in this package, as the code is already set up to handle an arbitrary number of cell types. One simply needs to adjust the parameters accordingly, adding values for the third cell type in all the relevant parameter arrays.</p>
<p>The following is one example of an adhesion array that results in concentric sorting of three cell types:</p>
</blockquote>
<pre><code>adhesion_table = np.array([
    [    0,    0,    0,   0], # adhesion medium - partner
    [  -20,   -2,    0,   0], # adhesion cell type 1 - partner
    [  -20,   -6,   -4,   0], # adhesion cell type 2 - partner
    [  -10,  -12,   -7,  -5], # adhesion cell type 3 - partner
])</code></pre>
<p><img src="images/6.7__3types_sim.png" class="img-fluid" alt="Simulation Run"> <em>Figure:</em> Final state of the simulation.</p>
<blockquote class="blockquote">
<p>All other parameters (volume, surface) were kept equal for all three cell types.</p>
</blockquote>
<blockquote class="blockquote">
<p>The adhesion settings are such that cell type 1 (blue) has the strongest self-adhesion, followed by cell type 2 (magenta), and then cell type 3 (yellow). Heterotypic adhesion is less favorable than homotypic adhesion for all cell types, but cell type 1 prefers sticking to cell type 2, while cell type 2 prefers sticking to cell type 3. Cell type 3 has a pretty favourable interaction with the medium, so cells tend to flatten and envelop the entire aggregate. The differences in adhesion energies between cell types should not be too large, otherwise cell motility will be impaired, which makes sorting slower or downright impossible as cells get “frozen” in a local energy minimum configuration.</p>
<p>Note that other solutions are possible, especially when also altering other parameters such as volume and surface weights and their respective target values.</p>
</blockquote>
<section id="references" class="level4">
<h4 class="anchored" data-anchor-id="references">References</h4>
<p>[1] <span class="citation" data-cites="gilbert2016developmental">Gilbert and Barresi (<a href="references.html#ref-gilbert2016developmental" role="doc-biblioref">2016</a>)</span> (https://utrechtuniversity.on.worldcat.org/oclc/1035852599)</p>
<p>[2] <span class="citation" data-cites="graner1992simulation">Graner and Glazier (<a href="references.html#ref-graner1992simulation" role="doc-biblioref">1992</a>)</span> (https://doi.org/10.1103/PhysRevLett.69.2013)</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-gilbert2016developmental" class="csl-entry" role="listitem">
Gilbert, SCOTT F, and MJF Barresi. 2016. <span>“Developmental Biology. 11th Edn, 372.”</span> Sinauer Associates.
</div>
<div id="ref-graner1992simulation" class="csl-entry" role="listitem">
Graner, François, and James A Glazier. 1992. <span>“Simulation of Biological Cell Sorting Using a Two-Dimensional Extended Potts Model.”</span> <em>Physical Review Letters</em> 69 (13): 2013.
</div>
<div id="ref-de2024shapes" class="csl-entry" role="listitem">
Jong, Martijn A de, Esmée Adegeest, Noémie MLP Bérenger-Currias, Maria Mircea, Roeland MH Merks, and Stefan Semrau. 2024. <span>“The Shapes of Elongating Gastruloids Are Consistent with Convergent Extension Driven by a Combination of Active Cell Crawling and Differential Adhesion.”</span> <em>PLOS Computational Biology</em> 20 (2): e1011825.
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
          // default icon
          link.classList.add("external");
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./morpho_intro_text.html" class="pagination-link" aria-label="Introduction to Morphogenesis">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Introduction to Morphogenesis</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./differentiation_intro_text.html" class="pagination-link" aria-label="Cell differentiation introduction">
        <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Cell differentiation introduction</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Theoretical Biology, Utrecht University.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This book was made with <a href="https://quarto.org/">Quarto</a>.</p>
</div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"selector":".lightbox","loop":false,"openEffect":"zoom","descPosition":"bottom","closeEffect":"zoom"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>